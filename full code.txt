================================================================================
CODE DOCUMENTATION
Complete Source Code Archive
================================================================================

Generated: December 12, 2025
Total Files: 71
Generated by: Code PDF Builder

================================================================================
PROJECT STRUCTURE
================================================================================

Project Root/
├── CMakeLists.txt
├── .github/
│   └── workflows/
│       ├── build_ios.yml
│       ├── build_linux.yml
│       ├── build_mac.yml
│       └── build_windows.yml
└── src/
    ├── dsp/
    │   ├── CompressorProcessor.h
    │   ├── DelayProcessor.h
    │   ├── DynamicEQProcessor.h
    │   ├── EQProcessor.cpp
    │   ├── EQProcessor.h
    │   ├── ExciterProcessor.cpp
    │   ├── ExciterProcessor.h
    │   ├── HarmonizerProcessor.h
    │   ├── ReverbProcessor.cpp
    │   ├── ReverbProcessor.h
    │   └── SimplePitchShifter.h
    ├── engine/
    │   ├── NativeMediaPlayer_Apple.h
    │   ├── NativeMediaPlayer_Apple.mm
    │   ├── VideoSurfaceComponent.cpp
    │   ├── VideoSurfaceComponent.h
    │   ├── VLCMediaPlayer_Desktop.cpp
    │   ├── VLCMediaPlayer_Desktop.h
    │   ├── VLCMediaPlayer.cpp
    │   └── VLCMediaPlayer.h
    └── UI/
        ├── CompressorPanel.h
        ├── DebugConsole.h
        ├── DelayPanel.h
        ├── DualHandleSlider.h
        ├── DynamicEQPanel.h
        ├── EffectToggleButton.h
        ├── EQPanel.h
        ├── ExciterPanel.h
        ├── HarmonizerPanel.h
        ├── HeaderBar.cpp
        ├── HeaderBar.h
        ├── IOPage.cpp
        ├── IOPage.h
        ├── LevelMeter.h
        ├── LongPressDetector.h
        ├── MainComponent.cpp
        ├── MainComponent.h
        ├── ManualComponent.h
        ├── MasterMeter.cpp
        ├── MasterMeter.h
        ├── MediaPage.cpp
        ├── MediaPage.h
        ├── PlaylistComponent.cpp
        ├── PlaylistComponent.h
        ├── PlaylistDataStructures.h
        ├── RegistrationComponent.h
        ├── ReverbPanel.h
        ├── SignalLed.h
        ├── StyledSlider.h
        ├── TrackBannerComponent.cpp
        ├── TrackBannerComponent.h
        ├── VocalsPage.cpp
        └── VocalsPage.h
    ├── App.cpp
    ├── App.h
    ├── AppLogger.h
    ├── AudioEngine.cpp
    ├── AudioEngine.h
    ├── IOSettingsManager.cpp
    ├── IOSettingsManager.h
    ├── LegacyMainComponent.cpp
    ├── LegacyMainComponent.h
    ├── Main.cpp
    ├── PresetManager.cpp
    ├── PresetManager.h
    ├── RegistrationManager.cpp
    └── RegistrationManager.h


================================================================================
FILE DETAILS
================================================================================

1. .github/workflows/build_ios.yml
   Size: 1.73 KB
   Type: text/plain

2. .github/workflows/build_linux.yml
   Size: 1.89 KB
   Type: text/plain

3. .github/workflows/build_mac.yml
   Size: 3.03 KB
   Type: text/plain

4. .github/workflows/build_windows.yml
   Size: 3.50 KB
   Type: text/plain

5. src/App.cpp
   Size: 4.24 KB
   Type: text/plain

6. src/App.h
   Size: 1.79 KB
   Type: text/plain

7. src/AppLogger.h
   Size: 4.11 KB
   Type: text/plain

8. src/AudioEngine.cpp
   Size: 7.46 KB
   Type: text/plain

9. src/AudioEngine.h
   Size: 3.91 KB
   Type: text/plain

10. src/dsp/CompressorProcessor.h
   Size: 1.91 KB
   Type: text/plain

11. src/dsp/DelayProcessor.h
   Size: 5.04 KB
   Type: text/plain

12. src/dsp/DynamicEQProcessor.h
   Size: 3.92 KB
   Type: text/plain

13. src/dsp/EQProcessor.cpp
   Size: 4.48 KB
   Type: text/plain

14. src/dsp/EQProcessor.h
   Size: 2.49 KB
   Type: text/plain

15. src/dsp/ExciterProcessor.cpp
   Size: 2.82 KB
   Type: text/plain

16. src/dsp/ExciterProcessor.h
   Size: 1.46 KB
   Type: text/plain

17. src/dsp/HarmonizerProcessor.h
   Size: 4.14 KB
   Type: text/plain

18. src/dsp/ReverbProcessor.cpp
   Size: 3.56 KB
   Type: text/plain

19. src/dsp/ReverbProcessor.h
   Size: 1.85 KB
   Type: text/plain

20. src/dsp/SimplePitchShifter.h
   Size: 3.39 KB
   Type: text/plain

21. src/engine/NativeMediaPlayer_Apple.h
   Size: 1.91 KB
   Type: text/plain

22. src/engine/NativeMediaPlayer_Apple.mm
   Size: 8.17 KB
   Type: text/plain

23. src/engine/VideoSurfaceComponent.cpp
   Size: 0.92 KB
   Type: text/plain

24. src/engine/VideoSurfaceComponent.h
   Size: 0.70 KB
   Type: text/plain

25. src/engine/VLCMediaPlayer_Desktop.cpp
   Size: 9.41 KB
   Type: text/plain

26. src/engine/VLCMediaPlayer_Desktop.h
   Size: 2.70 KB
   Type: text/plain

27. src/engine/VLCMediaPlayer.cpp
   Size: 9.13 KB
   Type: text/plain

28. src/engine/VLCMediaPlayer.h
   Size: 0.79 KB
   Type: text/plain

29. src/IOSettingsManager.cpp
   Size: 9.96 KB
   Type: text/plain

30. src/IOSettingsManager.h
   Size: 3.14 KB
   Type: text/plain

31. src/LegacyMainComponent.cpp
   Size: 1.79 KB
   Type: text/plain

32. src/LegacyMainComponent.h
   Size: 0.76 KB
   Type: text/plain

33. src/Main.cpp
   Size: 2.78 KB
   Type: text/plain

34. src/PresetManager.cpp
   Size: 17.05 KB
   Type: text/plain

35. src/PresetManager.h
   Size: 1.44 KB
   Type: text/plain

36. src/RegistrationManager.cpp
   Size: 7.75 KB
   Type: text/plain

37. src/RegistrationManager.h
   Size: 1.12 KB
   Type: text/plain

38. src/UI/CompressorPanel.h
   Size: 6.02 KB
   Type: text/plain

39. src/UI/DebugConsole.h
   Size: 3.02 KB
   Type: text/plain

40. src/UI/DelayPanel.h
   Size: 6.40 KB
   Type: text/plain

41. src/UI/DualHandleSlider.h
   Size: 4.93 KB
   Type: text/plain

42. src/UI/DynamicEQPanel.h
   Size: 6.45 KB
   Type: text/plain

43. src/UI/EffectToggleButton.h
   Size: 2.31 KB
   Type: text/plain

44. src/UI/EQPanel.h
   Size: 7.84 KB
   Type: text/plain

45. src/UI/ExciterPanel.h
   Size: 4.96 KB
   Type: text/plain

46. src/UI/HarmonizerPanel.h
   Size: 8.30 KB
   Type: text/plain

47. src/UI/HeaderBar.cpp
   Size: 6.37 KB
   Type: text/plain

48. src/UI/HeaderBar.h
   Size: 1.07 KB
   Type: text/plain

49. src/UI/IOPage.cpp
   Size: 26.65 KB
   Type: text/plain

50. src/UI/IOPage.h
   Size: 4.59 KB
   Type: text/plain

51. src/UI/LevelMeter.h
   Size: 1.24 KB
   Type: text/plain

52. src/UI/LongPressDetector.h
   Size: 1.38 KB
   Type: text/plain

53. src/UI/MainComponent.cpp
   Size: 12.75 KB
   Type: text/plain

54. src/UI/MainComponent.h
   Size: 1.66 KB
   Type: text/plain

55. src/UI/ManualComponent.h
   Size: 9.88 KB
   Type: text/plain

56. src/UI/MasterMeter.cpp
   Size: 2.25 KB
   Type: text/plain

57. src/UI/MasterMeter.h
   Size: 0.67 KB
   Type: text/plain

58. src/UI/MediaPage.cpp
   Size: 5.57 KB
   Type: text/plain

59. src/UI/MediaPage.h
   Size: 1.10 KB
   Type: text/plain

60. src/UI/PlaylistComponent.cpp
   Size: 15.02 KB
   Type: text/plain

61. src/UI/PlaylistComponent.h
   Size: 2.67 KB
   Type: text/plain

62. src/UI/PlaylistDataStructures.h
   Size: 0.50 KB
   Type: text/plain

63. src/UI/RegistrationComponent.h
   Size: 9.47 KB
   Type: text/plain

64. src/UI/ReverbPanel.h
   Size: 6.38 KB
   Type: text/plain

65. src/UI/SignalLed.h
   Size: 1.19 KB
   Type: text/plain

66. src/UI/StyledSlider.h
   Size: 14.31 KB
   Type: text/plain

67. src/UI/TrackBannerComponent.cpp
   Size: 9.19 KB
   Type: text/plain

68. src/UI/TrackBannerComponent.h
   Size: 2.02 KB
   Type: text/plain

69. src/UI/VocalsPage.cpp
   Size: 5.50 KB
   Type: text/plain

70. src/UI/VocalsPage.h
   Size: 1.71 KB
   Type: text/plain

71. CMakeLists.txt
   Size: 9.75 KB
   Type: text/plain


================================================================================
SOURCE CODE FILES
================================================================================

--------------------------------------------------------------------------------
File: .github/workflows/build_ios.yml
Size: 1.73 KB
--------------------------------------------------------------------------------

name: Build iOS

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build_ios:
    name: Build OnStage (iOS)
    runs-on: macos-latest

    steps:
    # 1. Checkout Code
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    # 2. Install CMake & Ninia (Standard tools)
    - name: Install Tools
      run: |
        brew update
        brew install cmake ninja xcbeautify

    # 3. Download JUCE
    - name: Download JUCE
      run: |
        rm -rf JUCE
        git clone --depth 1 --branch master https://github.com/juce-framework/JUCE.git

    # 4. Configure CMake for iOS
    # We use the Xcode generator (-G Xcode) which is standard for iOS builds
    - name: Configure CMake
      run: |
        cmake -B build -G Xcode \
          -DCMAKE_SYSTEM_NAME=iOS \
          -DCMAKE_OSX_DEPLOYMENT_TARGET=15.0 \
          -DCMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM="" \
          -DCMAKE_XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY="" \
          -DCMAKE_XCODE_ATTRIBUTE_CODE_SIGNING_REQUIRED="NO" \
          -DCMAKE_XCODE_ATTRIBUTE_CODE_SIGNING_ALLOWED="NO"

    # 5. Build
    - name: Build App
      run: |
        cmake --build build --config Release | xcbeautify

    # 6. Package (Create .ipa payload structure)
    - name: Package IPA
      run: |
        cd build/Release-iphoneos
        mkdir Payload
        mv OnStage.app Payload/
        zip -r OnStage_iOS.ipa Payload
        mv OnStage_iOS.ipa ../../OnStage_iOS.ipa

    # 7. Upload Artifact
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: OnStage_iOS_App
        path: OnStage_iOS.ipa



--------------------------------------------------------------------------------
File: .github/workflows/build_linux.yml
Size: 1.89 KB
--------------------------------------------------------------------------------

name: Build Linux

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build_linux:
    name: Build OnStage (Ubuntu)
    runs-on: ubuntu-22.04

    steps:
    # 1. Checkout Code
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    # 2. Install Linux Dependencies (System Packages)
    - name: Install Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake pkg-config \
          libasound2-dev \
          libjack-jackd2-dev \
          libfreetype6-dev \
          libx11-dev libxinerama-dev libxrandr-dev libxcursor-dev libxcomposite-dev libxext-dev \
          libgl1-mesa-dev \
          libvlc-dev vlc

    # 3. Download JUCE
    - name: Download JUCE
      run: |
        rm -rf JUCE
        git clone --depth 1 --branch master https://github.com/juce-framework/JUCE.git

    # 4. Configure
    - name: Configure
      run: cmake -B build -DCMAKE_BUILD_TYPE=Release

    # 5. Build
    - name: Build
      run: cmake --build build --config Release

    # 6. Package
    - name: Zip Application
      run: |
        # Linux binaries usually don't have extensions, just "OnStage"
        if [ -f "build/OnStage" ]; then
          cd build
        elif [ -f "build/Release/OnStage" ]; then
          cd build/Release
        else
          echo "CRITICAL ERROR: OnStage binary not found!"
          find build -maxdepth 3
          exit 1
        fi
        
        # Create Zip
        zip -r OnStage_Linux.zip OnStage
        
        # Move to workspace root
        mv OnStage_Linux.zip $GITHUB_WORKSPACE/OnStage_Linux.zip

    # 7. Upload
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: OnStage_Linux_App
        path: OnStage_Linux.zip



--------------------------------------------------------------------------------
File: .github/workflows/build_mac.yml
Size: 3.03 KB
--------------------------------------------------------------------------------

name: Build macOS

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build_mac:
    name: Build OnStage (macOS)
    runs-on: macos-latest

    steps:
    # 1. Checkout Code
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    # 2. Install Dependencies (Manual VLC 3.0 Setup)
    - name: Install Dependencies
      run: |
        brew update
        brew install cmake pkg-config
        
        # 1. Install VLC Player (Cask)
        echo "Installing VLC Cask..."
        brew install --cask vlc
        
        # 2. Manually Setup Headers (Targeting 3.0 stable branch)
        echo "Fetching VLC 3.0 Headers..."
        git clone --depth=1 --branch 3.0.x https://github.com/videolan/vlc.git vlc_src
        
        # Create include directories
        sudo mkdir -p /usr/local/include
        sudo mkdir -p /opt/homebrew/include
        
        # Copy headers to system paths
        sudo cp -r vlc_src/include/vlc /usr/local/include/
        sudo cp -r vlc_src/include/vlc /opt/homebrew/include/
        
        # 3. Symlink Libraries from VLC.app to System Paths
        echo "Linking VLC Libraries..."
        sudo mkdir -p /usr/local/lib
        sudo mkdir -p /opt/homebrew/lib
        
        # Link libvlc.dylib
        sudo ln -sf /Applications/VLC.app/Contents/MacOS/lib/libvlc.dylib /usr/local/lib/libvlc.dylib
        sudo ln -sf /Applications/VLC.app/Contents/MacOS/lib/libvlc.dylib /opt/homebrew/lib/libvlc.dylib
        
        # Link libvlccore.dylib
        sudo ln -sf /Applications/VLC.app/Contents/MacOS/lib/libvlccore.dylib /usr/local/lib/libvlccore.dylib
        sudo ln -sf /Applications/VLC.app/Contents/MacOS/lib/libvlccore.dylib /opt/homebrew/lib/libvlccore.dylib
        
        # Verify
        ls -l /opt/homebrew/include/vlc/libvlc.h
        ls -l /opt/homebrew/lib/libvlc.dylib
        echo "VLC Environment Ready."

    # 3. Download JUCE
    - name: Download JUCE
      run: |
        rm -rf JUCE
        git clone --depth 1 --branch master https://github.com/juce-framework/JUCE.git

    # 4. Configure
    - name: Configure
      run: cmake -B build -DCMAKE_BUILD_TYPE=Release

    # 5. Build
    - name: Build
      run: cmake --build build --config Release

    # 6. Package
    - name: Zip Application
      run: |
        # Find where the .app was built
        if [ -d "build/Release/OnStage.app" ]; then
          cd build/Release
        elif [ -d "build/OnStage.app" ]; then
          cd build
        else
          echo "CRITICAL ERROR: OnStage.app not found!"
          exit 1
        fi
        
        # Zip it up
        zip -r OnStage_Mac.zip OnStage.app
        
        # Move to workspace root for upload
        mv OnStage_Mac.zip $GITHUB_WORKSPACE/OnStage_Mac.zip

    # 7. Upload
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: OnStage_Mac_App
        path: OnStage_Mac.zip



--------------------------------------------------------------------------------
File: .github/workflows/build_windows.yml
Size: 3.50 KB
--------------------------------------------------------------------------------

name: Build Windows

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build_windows:
    name: Build OnStage (Windows)
    runs-on: windows-2022

    steps:
    # 1. Checkout Code
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    # 2. Setup Tools
    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1

    # 3. Download JUCE
    - name: Download JUCE
      run: |
        if (Test-Path JUCE) { Remove-Item -Recurse -Force JUCE }
        git clone --depth 1 --branch master https://github.com/juce-framework/JUCE.git

    # 4. Download & Setup VLC SDK (FIXED DOWNLOADER)
    - name: Setup VLC SDK
      shell: pwsh
      run: |
        $vlcUrl = "https://get.videolan.org/vlc/3.0.21/win64/vlc-3.0.21-win64.7z"
        $outputFile = "vlc.7z"
        
        Write-Host "Downloading VLC from $vlcUrl using curl..."
        # Use curl with -L (follow redirects) and --retry
        curl -L -o $outputFile $vlcUrl --retry 5 --retry-delay 5
        
        # Verify file size (should be > 30MB)
        $size = (Get-Item $outputFile).Length
        if ($size -lt 1000000) { 
            Write-Error "Download failed! File is too small ($size bytes)."
            exit 1 
        }
        
        Write-Host "Extracting VLC..."
        7z x $outputFile -y
        
        # Normalize folder name
        if (Test-Path "vlc-3.0.21-win64") {
            Rename-Item "vlc-3.0.21-win64" "vlc-3.0.21"
        }
        
        # Verify SDK exists
        if (Test-Path "vlc-3.0.21/sdk/lib/libvlc.lib") {
            Write-Host "VLC SDK found and ready."
        } else {
            Write-Error "CRITICAL: VLC SDK not found in extracted folder!"
            exit 1
        }

    # 5. Configure CMake
    - name: Configure CMake
      run: |
        cmake -B build -G "Visual Studio 17 2022" -A x64 `
          -DCMAKE_BUILD_TYPE=Release `
          -DJUCE_ASIO=1

    # 6. Build
    - name: Build
      run: |
        cmake --build build --config Release

    # 7. Package
    - name: Package Release
      shell: pwsh
      run: |
        $buildDir = "build/Release"
        $zipName = "OnStage_Windows.zip"
        
        if (-Not (Test-Path "$buildDir/OnStage.exe")) {
            Write-Error "OnStage.exe not found!"
            exit 1
        }

        New-Item -ItemType Directory -Force -Path "dist"
        
        Copy-Item "$buildDir/OnStage.exe" -Destination "dist/"
        
        # Copy VLC DLLs
        if (Test-Path "vlc-3.0.21/libvlc.dll") {
            Copy-Item "vlc-3.0.21/libvlc.dll" -Destination "dist/"
            Copy-Item "vlc-3.0.21/libvlccore.dll" -Destination "dist/"
            Copy-Item -Recurse "vlc-3.0.21/plugins" -Destination "dist/plugins"
        } else {
             Write-Warning "VLC DLLs not found in source folder, checking build output..."
             # Fallback if CMake copied them
             Copy-Item "$buildDir/libvlc.dll" -Destination "dist/"
             Copy-Item "$buildDir/libvlccore.dll" -Destination "dist/"
             Copy-Item -Recurse "$buildDir/plugins" -Destination "dist/plugins"
        }
        
        Compress-Archive -Path "dist/*" -DestinationPath $zipName
        Move-Item $zipName -Destination .

    # 8. Upload
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: OnStage_Windows_App
        path: OnStage_Windows.zip



--------------------------------------------------------------------------------
File: src/App.cpp
Size: 4.24 KB
--------------------------------------------------------------------------------

#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_events/juce_events.h>
#include "App.h"
#include "UI/MainComponent.h"
#include "AppLogger.h"

// ==============================================================================
// OnStageApplication Implementation
// ==============================================================================

OnStageApplication::OnStageApplication()
{
    // Logger is initialized via singleton when needed, 
    // but we can log the start here.
    // Note: AppLogger::getInstance() creates the log file.
}

OnStageApplication::~OnStageApplication()
{
}

const juce::String OnStageApplication::getApplicationName()
{
    return "OnStage";
}

const juce::String OnStageApplication::getApplicationVersion()
{
    return "1.0.0";
}

bool OnStageApplication::moreThanOneInstanceAllowed()
{
    return true;
}

void OnStageApplication::initialise(const juce::String& commandLine)
{
    juce::ignoreUnused(commandLine);
    
    LOG_INFO("=== OnStageApplication::initialise START ===");

    try {
        LOG_INFO("Creating MainWindow...");
        mainWindow.reset(new MainWindow(getApplicationName()));
        LOG_INFO("MainWindow created successfully");
    }
    catch (const std::exception& e) {
        LOG_ERROR("EXCEPTION during initialise: " + juce::String(e.what()));
        juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::WarningIcon,
            "Startup Error", 
            "Failed to create main window: " + juce::String(e.what()));
        quit();
    }
    catch (...) {
        LOG_ERROR("UNKNOWN EXCEPTION during initialise");
        juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::WarningIcon,
            "Startup Error", 
            "Unknown error occurred during startup");
        quit();
    }
    
    LOG_INFO("=== OnStageApplication::initialise COMPLETE ===");
}

void OnStageApplication::shutdown()
{
    LOG_INFO("OnStageApplication shutdown - closing MainWindow");
    mainWindow = nullptr;
}

void OnStageApplication::systemRequestedQuit()
{
    LOG_INFO("System requested quit");
    quit();
}

void OnStageApplication::anotherInstanceStarted(const juce::String& commandLine)
{
    juce::ignoreUnused(commandLine);
}

// ==============================================================================
// MainWindow Implementation
// ==============================================================================

OnStageApplication::MainWindow::MainWindow(juce::String name)
    : DocumentWindow(name,
        juce::Desktop::getInstance().getDefaultLookAndFeel()
            .findColour(juce::ResizableWindow::backgroundColourId),
        DocumentWindow::allButtons)
{
    LOG_INFO("MainWindow constructor starting");
    
    try {
        LOG_INFO("Step 1: Setting native title bar");
        setUsingNativeTitleBar(true);
        
        LOG_INFO("Step 2: Creating MainComponent...");
        auto* mainComp = new MainComponent();
        mainComponentPtr = mainComp; // Store pointer for restoration callback

        LOG_INFO("Step 3: MainComponent created, setting as content");
        setContentOwned(mainComp, true);
        
        LOG_INFO("Step 4: Window set as resizable");
        setResizable(true, false);

        LOG_INFO("Step 5: Window centered with size 1280x720");
        centreWithSize(1280, 720);

        LOG_INFO("Step 6: Window set to visible");
        setVisible(true);
        
        LOG_INFO("MainWindow constructor completed successfully");
        
        // CRITICAL FIX: Restore ASIO settings AFTER window is fully shown
        // This prevents race conditions during construction
        juce::Timer::callAfterDelay(200, [this]() {
            if (mainComponentPtr != nullptr)
            {
                LOG_INFO("Triggering restoreIOSettings() from MainWindow");
                mainComponentPtr->restoreIOSettings();
            }
        });
    }
    catch (const std::exception& e) {
        LOG_ERROR("Exception in MainWindow constructor: " + juce::String(e.what()));
        throw;
    }
    catch (...) {
        LOG_ERROR("Unknown exception in MainWindow constructor");
        throw;
    }
}

void OnStageApplication::MainWindow::closeButtonPressed()
{
    LOG_INFO("Close button pressed - quitting application");
    juce::JUCEApplication::getInstance()->systemRequestedQuit();
}



--------------------------------------------------------------------------------
File: src/App.h
Size: 1.79 KB
--------------------------------------------------------------------------------

#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_events/juce_events.h>
#include <juce_core/juce_core.h>
#include "AppLogger.h"
#include "UI/MainComponent.h"

// ======================================================================
// OnStageApplication - JUCE's auto-generated WinMain entry point
// ======================================================================
class OnStageApplication : public juce::JUCEApplication
{
public:
    OnStageApplication();
    ~OnStageApplication() override;

    // JUCE Required Overrides
    const juce::String getApplicationName() override;
    const juce::String getApplicationVersion() override;
    bool moreThanOneInstanceAllowed() override;

    // Initialize app (creates main window)
    void initialise(const juce::String& commandLine) override;

    // Shutdown app
    void shutdown() override;

    // Handle system quit (e.g., close button)
    void systemRequestedQuit() override;
    
    // Handle another instance (needed since we defined it in cpp previously)
    void anotherInstanceStarted(const juce::String& commandLine) override;

    // Suspend/resume (for mobile, ignore on desktop)
    void suspended() override {}
    void resumed() override {}

private:
    // Main Window Class Declaration
    // Implementation will be in App.cpp
    class MainWindow : public juce::DocumentWindow
    {
    public:
        MainWindow(juce::String name);
        void closeButtonPressed() override;

    private:
        MainComponent* mainComponentPtr = nullptr;
        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainWindow)
    };

    // Main window instance
    std::unique_ptr<MainWindow> mainWindow;
};



--------------------------------------------------------------------------------
File: src/AppLogger.h
Size: 4.11 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_core/juce_core.h>
#include <fstream>
#include <mutex>

class AppLogger
{
public:
    enum class Level
    {
        Info,
        Warning,
        Error,
        Debug
    };

    static AppLogger& getInstance()
    {
        static AppLogger instance;
        return instance;
    }

    void log(Level level, const juce::String& message)
    {
        std::lock_guard<std::mutex> lock(mutex);
        
        if (!logFile.is_open())
        {
            // Try to reopen if closed
            tryOpenLogFile();
        }
        
        if (!logFile.is_open())
        {
            // If still can't open, at least output to debugger
            DBG("[LOGFILE FAILED] " + message);
            return;
        }
            
        auto time = juce::Time::getCurrentTime().toString(true, true, true, true);
        juce::String levelStr;
        
        switch (level)
        {
            case Level::Info:    levelStr = "INFO"; break;
            case Level::Warning: levelStr = "WARN"; break;
            case Level::Error:   levelStr = "ERROR"; break;
            case Level::Debug:   levelStr = "DEBUG"; break;
        }
        
        juce::String logLine = "[" + time + "] [" + levelStr + "] " + message;
        logFile << logLine.toStdString() << std::endl;
        logFile.flush(); // Force immediate write
        
        // Also output to debugger
        DBG(logLine);
    }

    void logInfo(const juce::String& message)    { log(Level::Info, message); }
    void logWarning(const juce::String& message) { log(Level::Warning, message); }
    void logError(const juce::String& message)   { log(Level::Error, message); }
    void logDebug(const juce::String& message)   { log(Level::Debug, message); }

private:
    AppLogger()
    {
        tryOpenLogFile();
        
        if (logFile.is_open())
        {
            log(Level::Info, "========================================");
            log(Level::Info, "OnStage Application Started");
            log(Level::Info, "Log file: " + logFilePath.getFullPathName());
            log(Level::Info, "Working directory: " + juce::File::getCurrentWorkingDirectory().getFullPathName());
            log(Level::Info, "========================================");
        }
        else
        {
            DBG("CRITICAL: Failed to create log file at: " + logFilePath.getFullPathName());
        }
    }

    ~AppLogger()
    {
        if (logFile.is_open())
        {
            log(Level::Info, "OnStage Application Closed");
            log(Level::Info, "========================================");
            logFile.close();
        }
    }
    
    void tryOpenLogFile()
    {
        // Try multiple locations for log file
        juce::File possibleLocations[] = {
            juce::File::getCurrentWorkingDirectory().getChildFile("onstage.log"),
            juce::File::getSpecialLocation(juce::File::userDocumentsDirectory).getChildFile("onstage.log"),
            juce::File::getSpecialLocation(juce::File::userDesktopDirectory).getChildFile("onstage.log"),
            juce::File::getSpecialLocation(juce::File::tempDirectory).getChildFile("onstage.log")
        };
        
        for (auto& location : possibleLocations)
        {
            logFilePath = location;
            logFile.open(logFilePath.getFullPathName().toStdString(), 
                        std::ios::out | std::ios::app);
            
            if (logFile.is_open())
            {
                logFile << "\n" << std::endl; // Test write
                logFile.flush();
                DBG("Log file opened successfully at: " + logFilePath.getFullPathName());
                return;
            }
        }
        
        DBG("CRITICAL: Could not open log file at any location!");
    }

    std::ofstream logFile;
    std::mutex mutex;
    juce::File logFilePath;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AppLogger)
};

// Convenience macros
#define LOG_INFO(msg)    AppLogger::getInstance().logInfo(msg)
#define LOG_WARNING(msg) AppLogger::getInstance().logWarning(msg)
#define LOG_ERROR(msg)   AppLogger::getInstance().logError(msg)
#define LOG_DEBUG(msg)   AppLogger::getInstance().logDebug(msg)




--------------------------------------------------------------------------------
File: src/AudioEngine.cpp
Size: 7.46 KB
--------------------------------------------------------------------------------

// Updated to use the new class instances.

/*
  ==============================================================================

    AudioEngine.cpp
    Playlisted2

  ==============================================================================
*/

#include "AudioEngine.h"
#include "AppLogger.h"

#if JUCE_WINDOWS
#include <windows.h>
#endif

using namespace juce;

AudioEngine::AudioEngine()
{
    formatManager.registerBasicFormats();
    remotePlayer = std::make_unique<RemotePlayerFacade>(ipc);
    
    launchEngine();
    startTimer(200); 
}

AudioEngine::~AudioEngine()
{
    stopTimer();
    stopAllPlayback();
    terminateEngine();
}

void AudioEngine::setPitchSemitones(int semitones)
{
    // FIX: Update both shifters
    pitchShifterL.setPitchSemitones((float)semitones);
    pitchShifterR.setPitchSemitones((float)semitones);
}

void AudioEngine::timerCallback()
{
    if (!ipc.isConnected()) 
    {
        if (startupRetries < 20)
        {
            ipc.initialize();
            if (!engineProcess.isRunning())
            {
                launchEngine();
            }
            startupRetries++;
        }
    }
    else 
    {
        if (getTimerInterval() != 40) startTimer(40);
        if (startupRetries < 999) 
        {
             showVideoWindow();
             startupRetries = 999; 
        }
        remotePlayer->updateStatus();
    }
}

void AudioEngine::launchEngine()
{
    if (engineProcess.isRunning()) return;

    File engineExe;
    File appFile = File::getSpecialLocation(File::currentApplicationFile);
    File siblingExe = appFile.getSiblingFile("PlaylistedEngine.exe");

    if (siblingExe.existsAsFile())
    {
        engineExe = siblingExe;
    }
    else
    {
        #if JUCE_WINDOWS
            HMODULE hModule = NULL;
            static int dummy = 0;
            if (GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | 
                                   GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
                                   (LPCSTR)&dummy, &hModule))
            {
                char path[MAX_PATH];
                if (GetModuleFileNameA(hModule, path, MAX_PATH))
                {
                    File dllDir = File(path).getParentDirectory();
                    engineExe = dllDir.getChildFile("PlaylistedEngine.exe");
                }
            }
        #endif
    }

    if (engineExe.existsAsFile())
    {
        LOG_INFO("AudioEngine: Launching External Process: " + engineExe.getFullPathName());
        bool started = engineProcess.start(engineExe.getFullPathName());
        
        if (started)
        {
            LOG_INFO("AudioEngine: Process started successfully.");
            ipc.initialize();
        }
        else
        {
            LOG_ERROR("AudioEngine: Failed to start process!");
        }
    }
    else
    {
        LOG_ERROR("AudioEngine: CRITICAL - Could not find PlaylistedEngine.exe!");
    }
}

void AudioEngine::showVideoWindow()
{
    if (!ipc.isConnected())
    {
        if (!engineProcess.isRunning()) launchEngine();
        return;
    }
    juce::DynamicObject::Ptr o = new juce::DynamicObject();
    o->setProperty("type", "show_window");
    ipc.sendCommand(JSON::toString(var(o.get())));
}

void AudioEngine::terminateEngine() 
{
    if (engineProcess.isRunning())
    {
        engineProcess.kill();
    }
}

void AudioEngine::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    ipcBuffer.setSize(2, samplesPerBlock);
    
    // FIX: Prepare pitch shifters
    pitchShifterL.prepare(sampleRate, samplesPerBlock);
    pitchShifterR.prepare(sampleRate, samplesPerBlock);
    pitchShifterL.reset();
    pitchShifterR.reset();
    
    showVideoWindow();
}

void AudioEngine::releaseResources() {
    ipcBuffer.setSize(0, 0);
}

void AudioEngine::processPluginBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    const int numSamples = buffer.getNumSamples();
    
    if (ipcBuffer.getNumSamples() < numSamples)
        ipcBuffer.setSize(2, numSamples);

    buffer.clear();
    ipcBuffer.clear();

    handleMidi(midiMessages);

    if (!ipc.isConnected())
    {
        ipc.initialize();
    }
    
    if (ipc.isConnected())
    {
        ipc.popAudio(ipcBuffer);
        
        // Copy IPC to Main Buffer
        for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
        {
            if (ch < 2) 
            {
                buffer.copyFrom(ch, 0, ipcBuffer, ch, 0, numSamples);
            }
        }
        
        // FIX: Process Pitch Shifting here
        // We process the buffer in-place
        if (buffer.getNumChannels() > 0)
            pitchShifterL.processBlock(buffer.getWritePointer(0), numSamples);
            
        if (buffer.getNumChannels() > 1)
            pitchShifterR.processBlock(buffer.getWritePointer(1), numSamples);
    }
}

void AudioEngine::handleMidi(juce::MidiBuffer& midiMessages)
{
    for (const auto metadata : midiMessages)
    {
        auto message = metadata.getMessage();
        if (message.isNoteOn())
        {
            int note = message.getNoteNumber();
            if (note == 15) // Play/Pause
            {
                if (remotePlayer->isPlaying()) remotePlayer->pause();
                else remotePlayer->play();
            }
            else if (note == 16) // Stop
            {
                stopAllPlayback();
            }
            else if (note == 17)
            {
                showVideoWindow();
            }
        }
    }
}

void AudioEngine::stopAllPlayback()
{
    if (remotePlayer) remotePlayer->stop();
    // Reset pitch shifters on stop to clear delay lines
    pitchShifterL.reset();
    pitchShifterR.reset();
}

void AudioEngine::updateCrossfadeState()
{
    if (remotePlayer) remotePlayer->updateStatus();
}

XmlElement* AudioEngine::getStateXml()
{
    auto* xml = new XmlElement("OnStageState");
    auto* playlistXml = new XmlElement("Playlist");
    for (const auto& item : playlist)
    {
        auto* itemXml = new XmlElement("Item");
        itemXml->setAttribute("path", item.filePath);
        itemXml->setAttribute("title", item.title);
        itemXml->setAttribute("vol", item.volume);
        itemXml->setAttribute("pitch", item.pitchSemitones);
        itemXml->setAttribute("speed", item.playbackSpeed);
        itemXml->setAttribute("delay", item.transitionDelaySec);
        itemXml->setAttribute("xfade", item.isCrossfade);
        playlistXml->addChildElement(itemXml);
    }
    xml->addChildElement(playlistXml);
    return xml;
}

void AudioEngine::setStateXml(const XmlElement* xml)
{
    if (!xml) return;
    playlist.clear();
    if (auto* playlistXml = xml->getChildByName("Playlist"))
    {
        for (auto* itemXml : playlistXml->getChildIterator())
        {
            PlaylistItem item;
            item.filePath = itemXml->getStringAttribute("path");
            item.title = itemXml->getStringAttribute("title");
            item.volume = (float)itemXml->getDoubleAttribute("vol", 1.0);
            item.pitchSemitones = itemXml->getIntAttribute("pitch", 0);
            item.playbackSpeed = (float)itemXml->getDoubleAttribute("speed", 1.0);
            item.transitionDelaySec = itemXml->getIntAttribute("delay", 0);
            item.isCrossfade = itemXml->getBoolAttribute("xfade", false);
            playlist.push_back(item);
        }
    }

    if (!playlist.empty())
    {
        auto& first = playlist[0];
        remotePlayer->loadFile(first.filePath);
        remotePlayer->setVolume(first.volume);
        remotePlayer->setRate(first.playbackSpeed);
        setPitchSemitones(first.pitchSemitones);
    }
}



--------------------------------------------------------------------------------
File: src/AudioEngine.h
Size: 3.91 KB
--------------------------------------------------------------------------------

// Updated to include `SimplePitchShifter.h` and remove the old raw variables.

#pragma once

#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_graphics/juce_graphics.h>
#include "IPC/SharedMemoryManager.h"
#include "UI/PlaylistDataStructures.h"
// FIX: Include the new DSP class
#include "dsp/SimplePitchShifter.h" 

class RemotePlayerFacade
{
public:
    RemotePlayerFacade(SharedMemoryManager& m) : ipc(m) {}

    bool isPlaying() const { return status.playing; }
    bool hasFinished() const { return status.finished; } 
    bool isWindowOpen() const { return status.winOpen; }
    
    float getPosition() const { return status.pos; }
    int64_t getLengthMs() const { return status.len; }

    juce::Image getCurrentVideoFrame() { return juce::Image(); }

    void play()  { if (ipc.isConnected()) send("play"); }
    void pause() { if (ipc.isConnected()) send("pause"); }
    void stop()  { if (ipc.isConnected()) send("stop"); }
    void setVolume(float v) { if (ipc.isConnected()) send("volume", "val", v); }
    void setRate(float r)   { if (ipc.isConnected()) send("rate", "val", r); }
    void setPosition(float p) { if (ipc.isConnected()) send("seek", "pos", p); }

    void updateStatus() { if (ipc.isConnected()) status = ipc.getEngineStatus(); }
    
    bool loadFile(const juce::String& path) {
        if (!ipc.isConnected()) return false;
        juce::DynamicObject::Ptr o = new juce::DynamicObject();
        o->setProperty("type", "load");
        o->setProperty("path", path);
        o->setProperty("vol", 1.0f);
        o->setProperty("speed", 1.0f);
        ipc.sendCommand(juce::JSON::toString(juce::var(o.get())));
        return true;
    }

private:
    SharedMemoryManager& ipc;
    SharedMemoryManager::EngineStatus status;

    void send(const juce::String& type) {
        juce::DynamicObject::Ptr o = new juce::DynamicObject();
        o->setProperty("type", type);
        ipc.sendCommand(juce::JSON::toString(juce::var(o.get())));
    }
    
    void send(const juce::String& type, const juce::String& key, float val) {
        juce::DynamicObject::Ptr o = new juce::DynamicObject();
        o->setProperty("type", type);
        o->setProperty(key, val);
        ipc.sendCommand(juce::JSON::toString(juce::var(o.get())));
    }
};

class AudioEngine : private juce::Timer
{
public:
    AudioEngine();
    ~AudioEngine();
    void prepareToPlay(double sampleRate, int samplesPerBlockExpected);
    void releaseResources();
    void processPluginBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages);
    void stopAllPlayback();
    
    RemotePlayerFacade& getMediaPlayer() { return *remotePlayer; }
    std::vector<PlaylistItem>& getPlaylist() { return playlist; }
    juce::AudioFormatManager& getFormatManager() { return formatManager; }
    
    void updateCrossfadeState();
    void showVideoWindow();

    // Pitch Control
    void setPitchSemitones(int semitones);

    int getActiveTrackIndex() const { return activeTrackIndex; }
    void setActiveTrackIndex(int i) { activeTrackIndex = i; }
    
    juce::XmlElement* getStateXml();
    void setStateXml(const juce::XmlElement* xml);
    
private:
    void launchEngine();
    void terminateEngine();
    void handleMidi(juce::MidiBuffer& midiMessages);
    void timerCallback() override;

    // --- Pitch Shifter DSP ---
    // FIX: Using the robust class for each channel
    SimplePitchShifter pitchShifterL;
    SimplePitchShifter pitchShifterR;

    juce::AudioFormatManager formatManager;
    juce::AudioBuffer<float> ipcBuffer;
    SharedMemoryManager ipc { SharedMemoryManager::Mode::Plugin_Client };
    std::unique_ptr<RemotePlayerFacade> remotePlayer;
    juce::ChildProcess engineProcess;
    
    std::vector<PlaylistItem> playlist;
    int startupRetries = 0;

    int activeTrackIndex = -1;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AudioEngine)
};



--------------------------------------------------------------------------------
File: src/dsp/CompressorProcessor.h
Size: 1.91 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_dsp/juce_dsp.h>

class CompressorProcessor
{
public:
    struct Params
    {
        float thresholdDb { -18.0f };
        float ratio { 3.0f };
        float attackMs { 8.0f };
        float releaseMs { 120.0f };
        float makeupDb { 0.0f };
        
        bool operator==(const Params& other) const
        {
            return thresholdDb == other.thresholdDb &&
                   ratio == other.ratio &&
                   attackMs == other.attackMs &&
                   releaseMs == other.releaseMs &&
                   makeupDb == other.makeupDb;
        }
        
        bool operator!=(const Params& other) const { return !(*this == other); }
    };

    void prepare (const juce::dsp::ProcessSpec& spec)
    {
        comp.reset(); makeup.reset();
        comp.prepare (spec);
        makeup.prepare (spec);
        applyParams();
        isPrepared = true;
    }

    void reset()
    {
        comp.reset();
        makeup.reset();
    }

    void setParams (const Params& p)
    {
        params = p;
        if (isPrepared)
            applyParams();
    }

    Params getParams() const { return params; }

    template <typename Context>
    void process (Context&& ctx)
    {
        if (bypassed || !isPrepared)
            return; // Skip processing if bypassed or not ready

        comp.process (ctx);
        makeup.process (ctx);
    }

    void setBypassed(bool shouldBypass) { bypassed = shouldBypass; }
    bool isBypassed() const { return bypassed; }

private:
    void applyParams()
    {
        comp.setThreshold (params.thresholdDb);
        comp.setRatio (params.ratio);
        comp.setAttack (params.attackMs / 1000.0f);
        comp.setRelease (params.releaseMs / 1000.0f);
        makeup.setGainDecibels (params.makeupDb);
    }

    Params params;
    bool bypassed = false;
    bool isPrepared = false;
    juce::dsp::Compressor<float> comp;
    juce::dsp::Gain<float> makeup;
};



--------------------------------------------------------------------------------
File: src/dsp/DelayProcessor.h
Size: 5.04 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_dsp/juce_dsp.h>

class DelayProcessor
{
public:
    struct Params
    {
        float delayMs = 350.0f;
        
        // "Ratio": Loudness of first repeat (0.0 to 1.0) relative to Dry
        float ratio = 0.5f; 
        
        // "Stage": Gain reduction per repeat (0.0 = no reduction, 1.0 = full kill)
        float stage = 0.25f; 
        
        // "Mix": Master volume for the wet signal (0.0 to 1.0)
        float mix = 1.0f;

        float stereoWidth = 1.0f;
        float lowCutHz = 200.0f;
        float highCutHz = 8000.0f;
        
        bool operator==(const Params& other) const
        {
            return delayMs == other.delayMs &&
                   ratio == other.ratio &&
                   stage == other.stage &&
                   mix == other.mix &&
                   stereoWidth == other.stereoWidth &&
                   lowCutHz == other.lowCutHz &&
                   highCutHz == other.highCutHz;
        }
        
        bool operator!=(const Params& other) const { return !(*this == other); }
    };

    void prepare (double sampleRate, int samplesPerBlock, int numChannels)
    {
        sRate = sampleRate;
        juce::dsp::ProcessSpec spec { sampleRate,
            static_cast<juce::uint32>(samplesPerBlock),
            static_cast<juce::uint32>(numChannels) };

        delayL.reset (new juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Linear> (maxDelaySamples));
        delayR.reset (new juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Linear> (maxDelaySamples));
        delayL->prepare (spec);
        delayR->prepare (spec);

        lowCutL.prepare(spec);
        lowCutR.prepare(spec);
        highCutL.prepare(spec);
        highCutR.prepare(spec);

        updateFilters();
        reset();
        applyParams();
    }

    void reset()
    {
        if (delayL) delayL->reset();
        if (delayR) delayR->reset();

        lowCutL.reset();
        lowCutR.reset();
        highCutL.reset();
        highCutR.reset();
    }

    void process (juce::AudioBuffer<float>& buffer)
    {
        if (bypassed)
            return;

        auto n = buffer.getNumSamples();
        auto* l = buffer.getWritePointer (0);
        auto* r = buffer.getNumChannels() > 1 ? buffer.getWritePointer (1) : nullptr;

        // Feedback calculation
        const float feedbackGain = juce::jlimit(0.0f, 1.0f, 1.0f - params.stage);
        
        // Combined Output Gain = Ratio (First Repeat) * Mix (Master Wet)
        const float outputGain = params.ratio * params.mix;

        for (int i = 0; i < n; ++i)
        {
            const float inL = l[i];
            const float inR = r ? r[i] : inL;

            // 1. Read from Delay Line
            const float dl = delayL->popSample (0, delaySamples);
            const float dr = delayR->popSample (0, delaySamples);

            // 2. Calculate Feedback Signal (for the NEXT repeat)
            float fbL = dl * feedbackGain;
            float fbR = dr * feedbackGain;

            // 3. Apply Filters to Feedback
            fbL = lowCutL.processSample(fbL);
            fbL = highCutL.processSample(fbL);
            fbR = lowCutR.processSample(fbR);
            fbR = highCutR.processSample(fbR);

            // 4. Apply Stereo Width to Feedback
            const float mid = (fbL + fbR) * 0.5f;
            const float side = (fbL - fbR) * 0.5f * params.stereoWidth;
            fbL = mid + side;
            fbR = mid - side;

            // 5. Write Feedback + Input back into Delay Line
            delayL->pushSample (0, inL + fbL);
            delayR->pushSample (0, inR + fbR);

            // 6. Output Mix: Dry + (Delayed * OutputGain)
            l[i] = inL + (dl * outputGain);
            if (r) r[i] = inR + (dr * outputGain);
        }
    }

    void setParams(const Params& p)
    {
        params = p;
        applyParams();
        updateFilters();
    }

    Params getParams() const { return params; }

    void setBypassed(bool shouldBypass) { bypassed = shouldBypass; }
    bool isBypassed() const { return bypassed; }

private:
    void applyParams()
    {
        delaySamples = static_cast<int> (std::round (params.delayMs * 0.001 * sRate));
        delaySamples = juce::jlimit (1, maxDelaySamples - 1, delaySamples);
    }

    void updateFilters()
    {
        auto lowCutCoeffs = juce::dsp::IIR::Coefficients<float>::makeHighPass(sRate, params.lowCutHz, 0.707f);
        lowCutL.coefficients = lowCutCoeffs;
        lowCutR.coefficients = lowCutCoeffs;

        auto highCutCoeffs = juce::dsp::IIR::Coefficients<float>::makeLowPass(sRate, params.highCutHz, 0.707f);
        highCutL.coefficients = highCutCoeffs;
        highCutR.coefficients = highCutCoeffs;
    }

    static constexpr int maxDelaySamples = 96000 * 4;
    double sRate = 44100.0;
    
    std::unique_ptr<juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Linear>> delayL, delayR;
    juce::dsp::IIR::Filter<float> lowCutL, lowCutR;
    juce::dsp::IIR::Filter<float> highCutL, highCutR;

    Params params;
    int delaySamples = 44100 / 2;
    bool bypassed = false;
};



--------------------------------------------------------------------------------
File: src/dsp/DynamicEQProcessor.h
Size: 3.92 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_dsp/juce_dsp.h>
#include <juce_audio_basics/juce_audio_basics.h>

class DynamicEQProcessor
{
public:
    struct Params
    {
        float duckBandHz = 1000.0f;
        float q = 2.0f;
        float shape = 0.5f;
        float threshold = -30.0f;
        float ratio = 4.0f;
        float attack = 10.0f;
        float release = 150.0f;
    };

    DynamicEQProcessor() = default;

    void prepare(const juce::dsp::ProcessSpec& spec)
    {
        sampleRate = spec.sampleRate;
        
        for (int ch = 0; ch < 2; ++ch)
        {
            duckFilter[ch].prepare(spec);
            duckFilter[ch].reset();
        }
        
        updateFilterCoefficients();
        
        envelopeLevel = 0.0f;
        attackCoeff = 0.0f;
        releaseCoeff = 0.0f;
        updateEnvelopeCoefficients();
    }

    void reset()
    {
        for (int ch = 0; ch < 2; ++ch)
            duckFilter[ch].reset();
        envelopeLevel = 0.0f;
    }

    void process(juce::AudioBuffer<float>& backingTracks, 
                 const juce::AudioBuffer<float>& vocalSidechain)
    {
        if (bypassed)
            return;

        const int numSamples = backingTracks.getNumSamples();
        const int numChannels = juce::jmin(2, backingTracks.getNumChannels());

        float vocalEnergy = 0.0f;
        for (int ch = 0; ch < vocalSidechain.getNumChannels(); ++ch)
        {
            const float* data = vocalSidechain.getReadPointer(ch);
            for (int i = 0; i < numSamples; ++i)
                vocalEnergy += data[i] * data[i];
        }
        vocalEnergy = std::sqrt(vocalEnergy / (numSamples * vocalSidechain.getNumChannels()));
        float vocalDb = juce::Decibels::gainToDecibels(vocalEnergy + 1e-6f);

        float gainReductionDb = 0.0f;
        if (vocalDb > params.threshold)
        {
            float overThresholdDb = vocalDb - params.threshold;
            gainReductionDb = overThresholdDb * (1.0f - (1.0f / params.ratio));
        }

        float targetGainReduction = juce::Decibels::decibelsToGain(-gainReductionDb);
        
        for (int i = 0; i < numSamples; ++i)
        {
            if (targetGainReduction < envelopeLevel)
                envelopeLevel += (targetGainReduction - envelopeLevel) * attackCoeff;
            else
                envelopeLevel += (targetGainReduction - envelopeLevel) * releaseCoeff;

            float freqGain = calculateFrequencyGain();
            float finalGain = 1.0f - ((1.0f - envelopeLevel) * freqGain);

            for (int ch = 0; ch < numChannels; ++ch)
            {
                float* channelData = backingTracks.getWritePointer(ch);
                channelData[i] *= finalGain;
            }
        }
    }

    void setParams(const Params& newParams)
    {
        params = newParams;
        updateFilterCoefficients();
        updateEnvelopeCoefficients();
    }

    Params getParams() const { return params; }
    void setBypassed(bool shouldBypass) { bypassed = shouldBypass; }
    bool isBypassed() const { return bypassed; }

private:
    void updateFilterCoefficients()
    {
        auto coeffs = juce::dsp::IIR::Coefficients<float>::makePeakFilter(
            sampleRate, params.duckBandHz, params.q, 1.0f);

        for (int ch = 0; ch < 2; ++ch)
            duckFilter[ch].coefficients = coeffs;
    }

    void updateEnvelopeCoefficients()
    {
        attackCoeff = 1.0f - std::exp(-1.0f / (params.attack * 0.001f * sampleRate));
        releaseCoeff = 1.0f - std::exp(-1.0f / (params.release * 0.001f * sampleRate));
    }

    float calculateFrequencyGain()
    {
        float shapeAmount = juce::jmap(params.shape, 0.0f, 1.0f, 0.3f, 1.0f);
        return shapeAmount;
    }

    Params params;
    bool bypassed = false;
    double sampleRate = 44100.0;

    juce::dsp::IIR::Filter<float> duckFilter[2];

    float envelopeLevel = 0.0f;
    float attackCoeff = 0.0f;
    float releaseCoeff = 0.0f;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DynamicEQProcessor)
};




--------------------------------------------------------------------------------
File: src/dsp/EQProcessor.cpp
Size: 4.48 KB
--------------------------------------------------------------------------------

#include "EQProcessor.h"

EQProcessor::EQProcessor()
    : lowFreq(100.0f)
    , midFreq(1000.0f)
    , highFreq(10000.0f)
    , lowGain(0.0f)
    , midGain(0.0f)
    , highGain(0.0f)
    , lowQ(0.707f)
    , midQ(0.707f)
    , highQ(0.707f)
    , sampleRate(44100.0)
    , bypassed(false)
{
}

void EQProcessor::prepare(const juce::dsp::ProcessSpec& spec)
{
    sampleRate = spec.sampleRate;
    for (int ch = 0; ch < 2; ++ch)
    {
        lowShelf[ch].prepare(spec);
        midPeak[ch].prepare(spec);
        highShelf[ch].prepare(spec);
    }
    
    updateFilters();
}

void EQProcessor::process(juce::dsp::ProcessContextReplacing<float>& context)
{
    if (bypassed)
        return;
    
    auto& outputBlock = context.getOutputBlock();
    const int numChannels = static_cast<int>(outputBlock.getNumChannels());
    const int numSamples = static_cast<int>(outputBlock.getNumSamples());

    for (int channel = 0; channel < numChannels && channel < 2; ++channel)
    {
        auto* channelData = outputBlock.getChannelPointer(channel);
        for (int sample = 0; sample < numSamples; ++sample)
        {
            float input = channelData[sample];
            float output = lowShelf[channel].processSample(input);
            output = midPeak[channel].processSample(output);
            output = highShelf[channel].processSample(output);
            
            channelData[sample] = output;
        }
    }
}

void EQProcessor::reset()
{
    for (int ch = 0; ch < 2; ++ch)
    {
        lowShelf[ch].reset();
        midPeak[ch].reset();
        highShelf[ch].reset();
    }
}

void EQProcessor::setParams(const Params& p)
{
    lowFreq = p.lowFreq;
    midFreq = p.midFreq;
    highFreq = p.highFreq;
    lowGain = p.lowGain;
    midGain = p.midGain;
    highGain = p.highGain;
    lowQ = p.lowQ;
    midQ = p.midQ;
    highQ = p.highQ;
    updateFilters();
}

EQProcessor::Params EQProcessor::getParams() const
{
    Params p;
    p.lowFreq = lowFreq; p.midFreq = midFreq; p.highFreq = highFreq;
    p.lowGain = lowGain; p.midGain = midGain; p.highGain = highGain;
    p.lowQ = lowQ; p.midQ = midQ; p.highQ = highQ;
    return p;
}

void EQProcessor::setBypassed(bool shouldBeBypassed) { bypassed = shouldBeBypassed; }
bool EQProcessor::isBypassed() const { return bypassed; }

void EQProcessor::setLowFrequency(float freq) { lowFreq = juce::jlimit(20.0f, 2000.0f, freq); updateFilters(); }
void EQProcessor::setMidFrequency(float freq) { midFreq = juce::jlimit(20.0f, 10000.0f, freq); updateFilters(); }
void EQProcessor::setHighFrequency(float freq) { highFreq = juce::jlimit(2000.0f, 20000.0f, freq); updateFilters(); }
void EQProcessor::setLowGain(float gain) { lowGain = juce::jlimit(-24.0f, 24.0f, gain); updateFilters(); }
void EQProcessor::setMidGain(float gain) { midGain = juce::jlimit(-24.0f, 24.0f, gain); updateFilters(); }
void EQProcessor::setHighGain(float gain) { highGain = juce::jlimit(-24.0f, 24.0f, gain); updateFilters(); }
void EQProcessor::setLowQ(float q) { lowQ = juce::jlimit(0.1f, 10.0f, q); updateFilters(); }
void EQProcessor::setMidQ(float q) { midQ = juce::jlimit(0.1f, 10.0f, q); updateFilters(); }
void EQProcessor::setHighQ(float q) { highQ = juce::jlimit(0.1f, 10.0f, q); updateFilters(); }

float EQProcessor::getLowFrequency() const { return lowFreq; }
float EQProcessor::getMidFrequency() const { return midFreq; }
float EQProcessor::getHighFrequency() const { return highFreq; }
float EQProcessor::getLowGain() const { return lowGain; }
float EQProcessor::getMidGain() const { return midGain; }
float EQProcessor::getHighGain() const { return highGain; }
float EQProcessor::getLowQ() const { return lowQ; }
float EQProcessor::getMidQ() const { return midQ; }
float EQProcessor::getHighQ() const { return highQ; }

void EQProcessor::updateFilters()
{
    if (sampleRate <= 0.0)
        return;

    // FIX: Assign smart pointers directly (avoids crash on null dereference)
    auto lowCoeffs = juce::dsp::IIR::Coefficients<float>::makeLowShelf(
        sampleRate, lowFreq, lowQ, juce::Decibels::decibelsToGain(lowGain)
    );
    auto midCoeffs = juce::dsp::IIR::Coefficients<float>::makePeakFilter(
        sampleRate, midFreq, midQ, juce::Decibels::decibelsToGain(midGain)
    );
    auto highCoeffs = juce::dsp::IIR::Coefficients<float>::makeHighShelf(
        sampleRate, highFreq, highQ, juce::Decibels::decibelsToGain(highGain)
    );

    for (int ch = 0; ch < 2; ++ch)
    {
        lowShelf[ch].coefficients = lowCoeffs;
        midPeak[ch].coefficients = midCoeffs;
        highShelf[ch].coefficients = highCoeffs;
    }
}



--------------------------------------------------------------------------------
File: src/dsp/EQProcessor.h
Size: 2.49 KB
--------------------------------------------------------------------------------

#pragma once

#include <juce_dsp/juce_dsp.h>

// ============================================================================
// EQProcessor - 3-band EQ with Low/Mid/High controls
// ============================================================================
class EQProcessor
{
public:
    // NEW: Params struct for PresetManager
    struct Params
    {
        float lowFreq = 100.0f;
        float midFreq = 1000.0f;
        float highFreq = 10000.0f;
        
        float lowGain = 0.0f;
        float midGain = 0.0f;
        float highGain = 0.0f;
        
        float lowQ = 0.707f;
        float midQ = 0.707f;
        float highQ = 0.707f;

        bool operator==(const Params& other) const
        {
            return lowFreq == other.lowFreq && midFreq == other.midFreq && highFreq == other.highFreq &&
                   lowGain == other.lowGain && midGain == other.midGain && highGain == other.highGain &&
                   lowQ == other.lowQ && midQ == other.midQ && highQ == other.highQ;
        }
        bool operator!=(const Params& other) const { return !(*this == other); }
    };

    EQProcessor();
    void prepare(const juce::dsp::ProcessSpec& spec);
    void process(juce::dsp::ProcessContextReplacing<float>& context);
    void reset();
    
    // Param management (This was missing in the cpp)
    void setParams(const Params& params);
    Params getParams() const;

    // Bypass control
    void setBypassed(bool shouldBeBypassed);
    bool isBypassed() const;
    
    // Frequency setters
    void setLowFrequency(float freq);
    void setMidFrequency(float freq);
    void setHighFrequency(float freq);
    // Gain setters (in dB)
    void setLowGain(float gain);
    void setMidGain(float gain);
    void setHighGain(float gain);
    // Q factor setters
    void setLowQ(float q);
    void setMidQ(float q);
    void setHighQ(float q);
    // Getters
    float getLowFrequency() const;
    float getMidFrequency() const;
    float getHighFrequency() const;
    float getLowGain() const;
    float getMidGain() const;
    float getHighGain() const;
    float getLowQ() const;
    float getMidQ() const;
    float getHighQ() const;

private:
    // Filter parameters
    float lowFreq, midFreq, highFreq;
    float lowGain, midGain, highGain;
    float lowQ, midQ, highQ;
    double sampleRate;
    bool bypassed;
    
    // Filters
    juce::dsp::IIR::Filter<float> lowShelf[2];
    juce::dsp::IIR::Filter<float> midPeak[2];
    juce::dsp::IIR::Filter<float> highShelf[2];
    
    void updateFilters();
};



--------------------------------------------------------------------------------
File: src/dsp/ExciterProcessor.cpp
Size: 2.82 KB
--------------------------------------------------------------------------------

#include "ExciterProcessor.h"

ExciterProcessor::ExciterProcessor()
{
}

void ExciterProcessor::prepare(const juce::dsp::ProcessSpec& spec)
{
    sampleRate = spec.sampleRate;
    
    highPassFilter.prepare(spec);
    driveGain.prepare(spec);
    driveGain.setRampDurationSeconds(0.05);
    
    wetBuffer.setSize(spec.numChannels, spec.maximumBlockSize);
    
    updateFilter();
}

void ExciterProcessor::reset()
{
    highPassFilter.reset();
    driveGain.reset();
    wetBuffer.clear();
}

void ExciterProcessor::setParams(const Params& newParams)
{
    if (params != newParams)
    {
        params = newParams;
        updateFilter();
        
        // Convert dB to linear gain for the drive
        driveGain.setGainDecibels(params.amount);
    }
}

void ExciterProcessor::updateFilter()
{
    if (sampleRate <= 0.0) return;
    
    *highPassFilter.state = *juce::dsp::IIR::Coefficients<float>::makeHighPass(sampleRate, params.frequency);
}

void ExciterProcessor::process(juce::dsp::ProcessContextReplacing<float>& context)
{
    if (bypassed || params.mix <= 0.001f)
        return;

    const auto& inputBlock = context.getInputBlock();
    auto& outputBlock = context.getOutputBlock();
    const int numSamples = (int)outputBlock.getNumSamples();
    const int numChannels = (int)outputBlock.getNumChannels();

    // 1. Prepare Wet Buffer (Copy Input)
    // We need a scratch buffer because we are splitting the signal
    if (wetBuffer.getNumSamples() < numSamples)
        wetBuffer.setSize(numChannels, numSamples, true, false, true);

    juce::dsp::AudioBlock<float> wetBlock(wetBuffer.getArrayOfWritePointers(), numChannels, numSamples);
    wetBlock.copyFrom(inputBlock);

    juce::dsp::ProcessContextReplacing<float> wetContext(wetBlock);

    // 2. Filter: Keep only high frequencies
    highPassFilter.process(wetContext);

    // 3. Drive: Boost level into saturation
    driveGain.process(wetContext);

    // 4. Saturate: Generate Harmonics using tanh (Soft Clipping)
    for (int ch = 0; ch < numChannels; ++ch)
    {
        auto* data = wetBlock.getChannelPointer(ch);
        for (int i = 0; i < numSamples; ++i)
        {
            // Tanh generates odd harmonics
            // Rectification (std::abs) would generate even harmonics, 
            // but tanh is standard for basic exciters.
            data[i] = std::tanh(data[i]);
        }
    }

    // 5. Mix: Add Wet ("Air") back to Dry
    // Exciter is typically additive.
    float mix = params.mix;

    for (int ch = 0; ch < numChannels; ++ch)
    {
        auto* src = inputBlock.getChannelPointer(ch);
        auto* wet = wetBlock.getChannelPointer(ch);
        auto* dst = outputBlock.getChannelPointer(ch);

        for (int i = 0; i < numSamples; ++i)
        {
            // Original Dry + (Excited Highs * Mix)
            dst[i] = src[i] + (wet[i] * mix);
        }
    }
}



--------------------------------------------------------------------------------
File: src/dsp/ExciterProcessor.h
Size: 1.46 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_dsp/juce_dsp.h>

class ExciterProcessor
{
public:
    struct Params
    {
        float frequency = 3000.0f; // High-pass cutoff (1000Hz - 10000Hz)
        float amount = 0.0f;       // Drive/Harmonics (0dB - 24dB)
        float mix = 0.0f;          // Mix amount (0.0 - 1.0)

        bool operator==(const Params& other) const {
            return frequency == other.frequency && 
                   amount == other.amount && 
                   mix == other.mix;
        }
        bool operator!=(const Params& other) const { return !(*this == other); }
    };

    ExciterProcessor();
    
    void prepare(const juce::dsp::ProcessSpec& spec);
    void reset();
    void process(juce::dsp::ProcessContextReplacing<float>& context);
    
    void setParams(const Params& newParams);
    Params getParams() const { return params; }
    
    void setBypassed(bool shouldBypass) { bypassed = shouldBypass; }
    bool isBypassed() const { return bypassed; }

private:
    void updateFilter();

    Params params;
    bool bypassed = false;
    double sampleRate = 44100.0;

    // High-pass filter to isolate the "Air" frequencies
    juce::dsp::ProcessorDuplicator<juce::dsp::IIR::Filter<float>, juce::dsp::IIR::Coefficients<float>> highPassFilter;
    
    // Drive gain for saturation
    juce::dsp::Gain<float> driveGain;
    
    // Wet signal buffer
    juce::AudioBuffer<float> wetBuffer;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ExciterProcessor)
};



--------------------------------------------------------------------------------
File: src/dsp/HarmonizerProcessor.h
Size: 4.14 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_dsp/juce_dsp.h>
#include "SimplePitchShifter.h" // Include the shared class

class HarmonizerProcessor
{
public:
    struct Params
    {
        bool enabled = true;
        float wetDb = 0.0f; 
        float glideMs = 50.0f;
        bool useDiatonicMode = false;
        int keyRoot = 0;
        bool isMinorScale = false;
        struct Voice
        {
            bool enabled = false;
            int steps = 0; 
            float fixedSemitones = 0.0f;
            float centsDetune = 0.0f;
            float gainDb = 0.0f;
            float pan = 0.0f;
            float delayMs = 0.0f;
            
            bool operator==(const Voice& other) const {
                return enabled == other.enabled && steps == other.steps && fixedSemitones == other.fixedSemitones &&
                       centsDetune == other.centsDetune && gainDb == other.gainDb;
            }
        };

        Voice voices[2];
        bool operator==(const Params& other) const {
            return enabled == other.enabled && wetDb == other.wetDb && voices[0] == other.voices[0] && voices[1] == other.voices[1];
        }
        bool operator!=(const Params& other) const { return !(*this == other);
        }
    };

    HarmonizerProcessor()
    {
        params.voices[0].enabled = false;
        params.voices[0].fixedSemitones = 3.0f;
        params.voices[1].enabled = false;
        params.voices[1].fixedSemitones = 7.0f;
        params.voices[1].gainDb = -3.0f;
    }

    void prepare(const juce::dsp::ProcessSpec& spec)
    {
        sampleRate = spec.sampleRate;
        for (int i = 0; i < 2; ++i)
            pitchShifters[i].prepare(sampleRate, (int)spec.maximumBlockSize);
        currentPitchShift[0] = 0.0f;
        currentPitchShift[1] = 0.0f;
        
        wetBuffer.setSize(1, spec.maximumBlockSize);
    }

    void reset()
    {
        for (int i = 0; i < 2; ++i) pitchShifters[i].reset();
        currentPitchShift[0] = 0.0f;
        currentPitchShift[1] = 0.0f;
    }

    void setParams(const Params& p) { params = p;
    }
    Params getParams() const { return params;
    }
    void setBypassed(bool shouldBypass) { bypassed = shouldBypass;
    }
    bool isBypassed() const { return bypassed;
    }

    template <typename Context>
    void process(Context&& ctx)
    {
        if (!params.enabled || bypassed) return;
        auto& block = ctx.getOutputBlock();
        auto* channelData = block.getChannelPointer(0);
        int numSamples = (int)block.getNumSamples();

        float targetShift[2];
        for (int v = 0; v < 2; ++v)
            targetShift[v] = params.voices[v].enabled ?
            params.voices[v].fixedSemitones + params.voices[v].centsDetune * 0.01f : 0.0f;

        float glideCoeff = 1.0f - std::exp(-1.0f / (params.glideMs * 0.001f * sampleRate / numSamples));
        for (int v = 0; v < 2; ++v)
            currentPitchShift[v] += (targetShift[v] - currentPitchShift[v]) * glideCoeff;
        if (wetBuffer.getNumSamples() < numSamples)
            wetBuffer.setSize(1, numSamples, true, false, true);
        juce::FloatVectorOperations::clear(wetBuffer.getWritePointer(0), numSamples);
        float* wetData = wetBuffer.getWritePointer(0);

        for (int v = 0; v < 2; ++v)
        {
            if (!params.voices[v].enabled) continue;
            pitchShifters[v].setTransposeSemitones(currentPitchShift[v]);
            float gain = juce::Decibels::decibelsToGain(params.voices[v].gainDb);

            for (int i = 0; i < numSamples; ++i)
            {
                float shifted;
                pitchShifters[v].processSample(channelData[i], shifted);
                wetData[i] += shifted * gain;
            }
        }

        // MIX: Additive instead of replacement
        float wetGain = juce::Decibels::decibelsToGain(params.wetDb);
        for (int i = 0; i < numSamples; ++i)
        {
            // Add harmonies on top of dry signal
            channelData[i] += wetData[i] * wetGain;
        }
    }

private:
    Params params;
    bool bypassed = false;
    double sampleRate = 44100.0;
    SimplePitchShifter pitchShifters[2];
    float currentPitchShift[2] = {0.0f, 0.0f};
    
    juce::AudioBuffer<float> wetBuffer; 
};



--------------------------------------------------------------------------------
File: src/dsp/ReverbProcessor.cpp
Size: 3.56 KB
--------------------------------------------------------------------------------

#include "ReverbProcessor.h"
#include "BinaryData.h" 

ReverbProcessor::ReverbProcessor()
{
}

void ReverbProcessor::prepare(const juce::dsp::ProcessSpec& spec)
{
    sampleRate = spec.sampleRate;
    
    convolution.prepare(spec);
    
    // Load IR *after* prepare to ensure sample rate is known for resampling
    if (params.irFilePath.isNotEmpty())
    {
        loadExternalIR(juce::File(params.irFilePath));
    }
    else
    {
        loadEmbeddedIR();
    }
    
    lowCutFilter.prepare(spec);
    highCutFilter.prepare(spec);
    
    updateFilters();

    dryBuffer.setSize(spec.numChannels, spec.maximumBlockSize);
}

void ReverbProcessor::reset()
{
    convolution.reset();
    lowCutFilter.reset();
    highCutFilter.reset();
}

void ReverbProcessor::loadEmbeddedIR()
{
    if (BinaryData::ir_wavSize > 0)
    {
        convolution.loadImpulseResponse(
            BinaryData::ir_wav,
            BinaryData::ir_wavSize,
            juce::dsp::Convolution::Stereo::yes,
            juce::dsp::Convolution::Trim::no,
            0,
            juce::dsp::Convolution::Normalise::yes
        );
        convolution.reset(); // CRITICAL: Reset state after load
        currentIrName = "Default (Internal)";
    }
}

void ReverbProcessor::loadExternalIR(const juce::File& file)
{
    if (file.existsAsFile())
    {
        convolution.loadImpulseResponse(
            file,
            juce::dsp::Convolution::Stereo::yes,
            juce::dsp::Convolution::Trim::no,
            0,
            juce::dsp::Convolution::Normalise::yes
        );
        convolution.reset(); // CRITICAL: Reset state after load
        currentIrName = file.getFileNameWithoutExtension();
    }
    else
    {
        loadEmbeddedIR();
        currentIrName = "File Not Found (Default)";
    }
}

juce::String ReverbProcessor::getCurrentIrName() const
{
    return currentIrName;
}

void ReverbProcessor::process(juce::AudioBuffer<float>& buffer)
{
    if (bypassed)
        return;

    const int numSamples = buffer.getNumSamples();
    const int numChannels = buffer.getNumChannels();

    // Ensure scratch buffer size
    if (dryBuffer.getNumSamples() < numSamples)
        dryBuffer.setSize(numChannels, numSamples, true, false, true);

    // 1. Save Dry Signal
    for (int ch = 0; ch < numChannels; ++ch)
        dryBuffer.copyFrom(ch, 0, buffer.getReadPointer(ch), numSamples);

    // 2. Process Convolution (Replaces buffer with Wet signal)
    juce::dsp::AudioBlock<float> block(buffer);
    juce::dsp::ProcessContextReplacing<float> context(block);
    convolution.process(context);

    // 3. Process Post-EQ on Wet
    lowCutFilter.process(context);
    highCutFilter.process(context);

    // 4. Apply Wet Gain to the Wet signal
    buffer.applyGain(0, numSamples, params.wetGain);

    // 5. Add Dry Signal back
    for (int ch = 0; ch < numChannels; ++ch)
    {
        buffer.addFrom(ch, 0, dryBuffer.getReadPointer(ch), numSamples);
    }
}

void ReverbProcessor::setParams(const Params& newParams)
{
    bool irChanged = (params.irFilePath != newParams.irFilePath);
    params = newParams;
    
    if (irChanged)
    {
        if (params.irFilePath.isNotEmpty())
            loadExternalIR(juce::File(params.irFilePath));
        else
            loadEmbeddedIR();
    }

    updateFilters();
}

void ReverbProcessor::updateFilters()
{
    if (sampleRate <= 0.0) return;

    *lowCutFilter.state = *juce::dsp::IIR::Coefficients<float>::makeHighPass(
        sampleRate, params.lowCutHz, 0.707f);

    *highCutFilter.state = *juce::dsp::IIR::Coefficients<float>::makeLowPass(
        sampleRate, params.highCutHz, 0.707f);
}



--------------------------------------------------------------------------------
File: src/dsp/ReverbProcessor.h
Size: 1.85 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_dsp/juce_dsp.h>
#include <juce_audio_basics/juce_audio_basics.h>

class ReverbProcessor
{
public:
    struct Params
    {
        float wetGain = 0.5f;     // Wet Gain (0.0 to 1.0+)
        float lowCutHz = 20.0f;   
        float highCutHz = 20000.0f;
        
        // Store the full path to the IR file. 
        // Empty string "" means "Use Default Embedded IR".
        juce::String irFilePath = ""; 
        
        bool operator==(const Params& other) const {
            return wetGain == other.wetGain && 
                   lowCutHz == other.lowCutHz && 
                   highCutHz == other.highCutHz &&
                   irFilePath == other.irFilePath;
        }
        bool operator!=(const Params& other) const { return !(*this == other); }
    };

    ReverbProcessor();
    
    void prepare(const juce::dsp::ProcessSpec& spec);
    void reset();
    void process(juce::AudioBuffer<float>& buffer);
    
    void setParams(const Params& newParams);
    Params getParams() const { return params; }
    
    void setBypassed(bool shouldBypass) { bypassed = shouldBypass; }
    bool isBypassed() const { return bypassed; }

    juce::String getCurrentIrName() const;

private:
    void updateFilters();
    void loadEmbeddedIR();
    void loadExternalIR(const juce::File& file);

    Params params;
    bool bypassed = false;
    double sampleRate = 44100.0;
    juce::String currentIrName = "Default (Internal)";

    juce::dsp::Convolution convolution;
    
    juce::dsp::ProcessorDuplicator<juce::dsp::IIR::Filter<float>, juce::dsp::IIR::Coefficients<float>> lowCutFilter;
    juce::dsp::ProcessorDuplicator<juce::dsp::IIR::Filter<float>, juce::dsp::IIR::Coefficients<float>> highCutFilter;

    // SCRATCH BUFFER (Pre-allocated)
    juce::AudioBuffer<float> dryBuffer;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ReverbProcessor)
};



--------------------------------------------------------------------------------
File: src/dsp/SimplePitchShifter.h
Size: 3.39 KB
--------------------------------------------------------------------------------

// This handles the math robustly with thread safety.

#pragma once
#include <vector>
#include <cmath>
#include <algorithm>
#include <juce_core/juce_core.h>

class SimplePitchShifter
{
public:
    void prepare(double sampleRate, int maxBlockSize)
    {
        // 8192 samples is ~180ms at 44.1k, plenty of room for the window
        bufferSize = 8192;
        buffer.resize(bufferSize, 0.0f);
        
        // Window size determines grain length. 
        // 4096 (~90ms) is good for polyphonic material.
        windowSize = 4096; 
        
        writePos = 0;
        phasor = 0.0f;
        currentRatio = 1.0f;
        targetRatio = 1.0f;
    }

    void reset()
    {
        std::fill(buffer.begin(), buffer.end(), 0.0f);
        writePos = 0;
        phasor = 0.0f;
    }

    void setPitchSemitones(float semitones)
    {
        // Calculate ratio: 2^(semitones/12)
        targetRatio = std::pow(2.0f, semitones / 12.0f);
    }

    void processBlock(float* data, int numSamples)
    {
        // SNAPSHOT: Smooth the ratio once per block or per sample to prevent zippering
        // For efficiency, we can smooth it per block or use a small slew.
        
        for (int i = 0; i < numSamples; ++i)
        {
            // 1. Parameter Smoothing (One-pole filter)
            // This prevents clicks when moving the slider
            currentRatio = 0.999f * currentRatio + 0.001f * targetRatio;

            // 2. Input Input
            float input = data[i];
            buffer[writePos] = input;

            // 3. Update Phasor
            // Ratio 1.0 -> step 0.0 (No pitch shift)
            // Ratio 2.0 -> step -1.0/win (Read faster)
            // Ratio 0.5 -> step +0.5/win (Read slower)
            double step = (1.0 - (double)currentRatio) / (double)windowSize;
            phasor += (float)step;

            // Wrap Phasor [0.0, 1.0]
            if (phasor >= 1.0f) phasor -= 1.0f;
            if (phasor < 0.0f)  phasor += 1.0f;

            // 4. Calculate Delay Taps
            // Tap A: Aligned with phasor
            // Tap B: Offset by 0.5 (180 degrees)
            float delayA = phasor * (windowSize - 1);
            float delayB = std::fmod(phasor + 0.5f, 1.0f) * (windowSize - 1);

            // 5. Read from Buffer (Linear Interpolation)
            float sampleA = readBuffer(writePos - delayA);
            float sampleB = readBuffer(writePos - delayB);

            // 6. Windowing (Triangle / Hanning approximation)
            // Gain is 0 at phase edges, 1 at center.
            float gainA = 1.0f - 2.0f * std::abs(phasor - 0.5f);
            float gainB = 1.0f - 2.0f * std::abs(std::fmod(phasor + 0.5f, 1.0f) - 0.5f);

            // 7. Output
            data[i] = (sampleA * gainA) + (sampleB * gainB);

            // 8. Advance Write Head
            writePos = (writePos + 1) % bufferSize;
        }
    }

private:
    // Helper to read with wrapping
    float readBuffer(float position)
    {
        while (position < 0.0f) position += bufferSize;
        while (position >= bufferSize) position -= bufferSize;

        int idxA = (int)position;
        int idxB = (idxA + 1) % bufferSize;
        float frac = position - idxA;

        return buffer[idxA] * (1.0f - frac) + buffer[idxB] * frac;
    }

    std::vector<float> buffer;
    int bufferSize = 8192;
    int windowSize = 4096;
    int writePos = 0;
    
    float phasor = 0.0f;
    float currentRatio = 1.0f;
    float targetRatio = 1.0f;
};



--------------------------------------------------------------------------------
File: src/engine/NativeMediaPlayer_Apple.h
Size: 1.91 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    NativeMediaPlayer_Apple.h
    OnStage

    Shared Native implementation for iOS AND macOS using AVFoundation.
    Uses juce::AudioTransportSource for audio and AVPlayerItemVideoOutput for video.

  ==============================================================================
*/

#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_graphics/juce_graphics.h>

// Forward declaration for the Obj-C++ video wrapper
class VideoFrameExtractor; 

class NativeMediaPlayer_Apple
{
public:
    NativeMediaPlayer_Apple();
    ~NativeMediaPlayer_Apple();

    bool prepareToPlay(int samplesPerBlock, double sampleRate);
    void releaseResources();
    
    bool loadFile(const juce::String& path);
    
    void play();
    void pause();
    void stop();
    
    void setVolume(float newVolume);
    float getVolume() const;
    
    void setRate(float newRate);
    float getRate() const;
    
    bool hasFinished() const;
    bool isPlaying() const;
    
    // Position/Length
    float getPosition() const;
    void setPosition(float pos);
    int64_t getLengthMs() const;

    // Callbacks
    void getNextAudioBlock(const juce::AudioSourceChannelInfo& info);
    juce::Image getCurrentVideoFrame();

private:
    juce::AudioFormatManager formatManager;
    std::unique_ptr<juce::AudioFormatReaderSource> readerSource;
    juce::AudioTransportSource transportSource;
    
    // Resampler to handle rate changes and sample rate mismatches
    juce::ResamplingAudioSource resampleSource {&transportSource, false, 2};

    double currentSampleRate = 44100.0;
    double originalSampleRate = 44100.0;
    float currentRate = 1.0f;

    std::unique_ptr<VideoFrameExtractor> videoExtractor;
    juce::Image currentVideoImage;
    bool isVideoLoaded = false;
};



--------------------------------------------------------------------------------
File: src/engine/NativeMediaPlayer_Apple.mm
Size: 8.17 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    NativeMediaPlayer_Apple.mm
    OnStage

    Implementation using AVFoundation (Shared for macOS & iOS).

  ==============================================================================
*/

#include "NativeMediaPlayer_Apple.h"
#import <AVFoundation/AVFoundation.h>
#import <CoreVideo/CoreVideo.h>

// ==============================================================================
// VideoFrameExtractor
// Helper class to extract video frames synchronized to a timestamp
// ==============================================================================
class VideoFrameExtractor
{
public:
    VideoFrameExtractor() {}
    ~VideoFrameExtractor() { cleanUp(); }

    void loadVideo(const juce::String& path)
    {
        cleanUp();
        
        NSURL* url = [NSURL fileURLWithPath: [NSString stringWithUTF8String: path.toRawUTF8()]];
        
        // Load the asset
        asset = [AVURLAsset assetWithURL:url];
        if (!asset) return;

        // Setup Video Output settings (BGRA is standard for CoreVideo on Apple Silicon & Intel)
        NSDictionary* settings = @{ (id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
        output = [[AVPlayerItemVideoOutput alloc] initWithPixelBufferAttributes:settings];
        
        playerItem = [AVPlayerItem playerItemWithAsset:asset];
        [playerItem addOutput:output];
        
        // We create a player just to hold the item status (loading/ready), 
        // but we drive the time manually via getFrameAtTime
        player = [AVPlayer playerWithPlayerItem:playerItem];
        player.muted = YES; 
        player.actionAtItemEnd = AVPlayerActionAtItemEndPause;
    }

    juce::Image getFrameAtTime(double seconds)
    {
        if (!output) return juce::Image();

        // Timebase 600 is standard for video
        CMTime time = CMTimeMakeWithSeconds(seconds, 600);
        
        // Check if a pixel buffer is available for this timestamp
        if ([output hasNewPixelBufferForItemTime:time])
        {
            CMTime actualTime;
            CVPixelBufferRef buffer = [output copyPixelBufferForItemTime:time itemTimeForDisplay:&actualTime];
            
            if (buffer)
            {
                juce::Image img = convertPixelBufferToImage(buffer);
                CVPixelBufferRelease(buffer); // Important: Release the buffer
                return img;
            }
        }
        return juce::Image(); // Return invalid image if no new frame
    }

    void cleanUp() {
        player = nil;
        playerItem = nil;
        output = nil;
        asset = nil;
    }

private:
    AVPlayer* player = nil;
    AVPlayerItem* playerItem = nil;
    AVPlayerItemVideoOutput* output = nil;
    AVAsset* asset = nil;

    juce::Image convertPixelBufferToImage(CVPixelBufferRef buffer)
    {
        CVPixelBufferLockBaseAddress(buffer, kCVPixelBufferLock_ReadOnly);
        
        int width = (int)CVPixelBufferGetWidth(buffer);
        int height = (int)CVPixelBufferGetHeight(buffer);
        uint8* srcData = (uint8*)CVPixelBufferGetBaseAddress(buffer);
        size_t bytesPerRow = CVPixelBufferGetBytesPerRow(buffer);

        // JUCE ARGB vs CoreVideo BGRA
        // JUCE's ARGB format in memory is typically B-G-R-A on little-endian architectures
        // (which includes both Intel Macs and Apple Silicon).
        // A direct memcpy usually results in correct colors.
        
        juce::Image image(juce::Image::ARGB, width, height, true);
        juce::Image::BitmapData destData(image, juce::Image::BitmapData::writeOnly);

        for (int y = 0; y < height; ++y)
        {
            const uint8* srcRow = srcData + (y * bytesPerRow);
            uint8* destRow = destData.getLinePointer(y);
            memcpy(destRow, srcRow, width * 4);
        }

        CVPixelBufferUnlockBaseAddress(buffer, kCVPixelBufferLock_ReadOnly);
        return image;
    }
};

// ==============================================================================
// NativeMediaPlayer_Apple Implementation
// ==============================================================================

NativeMediaPlayer_Apple::NativeMediaPlayer_Apple()
{
    formatManager.registerBasicFormats(); 
    videoExtractor = std::make_unique<VideoFrameExtractor>();
}

NativeMediaPlayer_Apple::~NativeMediaPlayer_Apple()
{
    transportSource.setSource(nullptr);
}

bool NativeMediaPlayer_Apple::prepareToPlay(int samplesPerBlock, double sampleRate)
{
    currentSampleRate = sampleRate;
    resampleSource.prepareToPlay(samplesPerBlock, sampleRate);
    return true;
}

void NativeMediaPlayer_Apple::releaseResources()
{
    transportSource.releaseResources();
    resampleSource.releaseResources();
}

bool NativeMediaPlayer_Apple::loadFile(const juce::String& path)
{
    transportSource.stop();
    transportSource.setSource(nullptr);
    videoExtractor->cleanUp();
    isVideoLoaded = false;
    currentVideoImage = juce::Image();

    juce::File file(path);
    auto* reader = formatManager.createReaderFor(file);
    
    if (reader != nullptr)
    {
        originalSampleRate = reader->sampleRate;
        readerSource.reset(new juce::AudioFormatReaderSource(reader, true));
        
        // Link transport to source. Small buffer helps prevent glitches.
        transportSource.setSource(readerSource.get(), 32768, nullptr, reader->sampleRate);
        
        // Reset Resampler
        double ratio = (originalSampleRate / currentSampleRate) / (double)currentRate;
        resampleSource.setResamplingRatio(ratio);

        // Load Video Side if applicable
        if (path.endsWithIgnoreCase(".mp4") || path.endsWithIgnoreCase(".mov") || path.endsWithIgnoreCase(".m4v") || path.endsWithIgnoreCase(".avi"))
        {
            videoExtractor->loadVideo(path);
            isVideoLoaded = true;
        }
        
        return true;
    }
    return false;
}

void NativeMediaPlayer_Apple::play() 
{ 
    transportSource.start(); 
}

void NativeMediaPlayer_Apple::pause() 
{ 
    transportSource.stop(); 
}

void NativeMediaPlayer_Apple::stop()  
{ 
    transportSource.stop(); 
    transportSource.setPosition(0); 
    if (currentVideoImage.isValid())
        currentVideoImage.clear(currentVideoImage.getBounds(), juce::Colours::black);
}

void NativeMediaPlayer_Apple::setVolume(float newVolume) 
{ 
    transportSource.setGain(newVolume); 
}

float NativeMediaPlayer_Apple::getVolume() const 
{ 
    return transportSource.getGain(); 
}

void NativeMediaPlayer_Apple::setRate(float newRate)
{
    currentRate = newRate;
    if (currentSampleRate > 0 && originalSampleRate > 0)
    {
        // Resampling ratio = (SourceRate / TargetRate) / Speed
        double ratio = (originalSampleRate / currentSampleRate) / (double)newRate;
        resampleSource.setResamplingRatio(ratio);
    }
}

float NativeMediaPlayer_Apple::getRate() const 
{ 
    return currentRate; 
}

bool NativeMediaPlayer_Apple::hasFinished() const 
{ 
    return transportSource.hasStreamFinished(); 
}

bool NativeMediaPlayer_Apple::isPlaying() const 
{ 
    return transportSource.isPlaying(); 
}

float NativeMediaPlayer_Apple::getPosition() const
{
    if (transportSource.getLengthInSeconds() > 0)
        return (float)(transportSource.getCurrentPosition() / transportSource.getLengthInSeconds());
    return 0.0f;
}

void NativeMediaPlayer_Apple::setPosition(float pos)
{
    if (transportSource.getLengthInSeconds() > 0)
        transportSource.setPosition(pos * transportSource.getLengthInSeconds());
}

int64_t NativeMediaPlayer_Apple::getLengthMs() const
{
    return (int64_t)(transportSource.getLengthInSeconds() * 1000.0);
}

void NativeMediaPlayer_Apple::getNextAudioBlock(const juce::AudioSourceChannelInfo& info)
{
    // Pull audio from the Resampler (which pulls from Transport -> Reader)
    resampleSource.getNextAudioBlock(info);
}

juce::Image NativeMediaPlayer_Apple::getCurrentVideoFrame()
{
    if (!isVideoLoaded) return juce::Image();

    // Sync: Ask for the frame corresponding to the current AUDIO time
    double currentSeconds = transportSource.getCurrentPosition();
    juce::Image frame = videoExtractor->getFrameAtTime(currentSeconds);
    
    if (frame.isValid())
        currentVideoImage = frame;
        
    return currentVideoImage;
}



--------------------------------------------------------------------------------
File: src/engine/VideoSurfaceComponent.cpp
Size: 0.92 KB
--------------------------------------------------------------------------------

// **Fix:** Updated the constructor to accept `AudioEngine&` instead of the old player reference, matching the header file we updated earlier.

#include "VideoSurfaceComponent.h"
#include "../AudioEngine.h" // Include full definition here

VideoSurfaceComponent::VideoSurfaceComponent(AudioEngine& engine)
    : audioEngine(engine)
{
    setOpaque(true);
    startTimerHz(60);
}

VideoSurfaceComponent::~VideoSurfaceComponent()
{
    stopTimer();
}

void VideoSurfaceComponent::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colours::black);
    
    // Safely access the ACTIVE player via the engine
    juce::Image frame = audioEngine.getMediaPlayer().getCurrentVideoFrame();
    
    if (frame.isValid())
    {
        g.drawImage(frame, getLocalBounds().toFloat(), 
                    juce::RectanglePlacement::centred);
    }
}

void VideoSurfaceComponent::resized()
{
}

void VideoSurfaceComponent::timerCallback()
{
    repaint();
}



--------------------------------------------------------------------------------
File: src/engine/VideoSurfaceComponent.h
Size: 0.70 KB
--------------------------------------------------------------------------------

// This ensures a clean forward declaration to prevent circular include loops.

#ifndef ONSTAGE_ENGINE_VIDEO_SURFACE_COMPONENT_H
#define ONSTAGE_ENGINE_VIDEO_SURFACE_COMPONENT_H

#include <juce_gui_basics/juce_gui_basics.h>

// Forward Declaration only - do NOT include AudioEngine.h here
class AudioEngine; 

class VideoSurfaceComponent : public juce::Component, private juce::Timer
{
public:
    VideoSurfaceComponent(AudioEngine& engine);
    ~VideoSurfaceComponent() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    void timerCallback() override;
    
    AudioEngine& audioEngine;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VideoSurfaceComponent)
};
#endif



--------------------------------------------------------------------------------
File: src/engine/VLCMediaPlayer_Desktop.cpp
Size: 9.41 KB
--------------------------------------------------------------------------------

// ### **4. The iOS Native Header** This interface mirrors the Desktop one exactly but uses JUCE native classes and an internal video extractor.

/*
  ==============================================================================

    VLCMediaPlayer_Desktop.cpp
    OnStage

    Original LibVLC implementation logic.
    Renamed class to VLCMediaPlayer_Desktop.

  ==============================================================================
*/

#include "VLCMediaPlayer_Desktop.h"
#include <cstring>
#include <juce_core/juce_core.h>

#if JUCE_LINUX
#include <stdlib.h>
#endif

VLCMediaPlayer_Desktop::VLCMediaPlayer_Desktop()
{
    // CRITICAL FIX: Ensure VLC finds its plugins relative to the executable
    juce::File appDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
    juce::File pluginDir = appDir.getChildFile("plugins");
    
    #if JUCE_WINDOWS
        juce::String pathEnv = "VLC_PLUGIN_PATH=" + pluginDir.getFullPathName();
        _putenv(pathEnv.toRawUTF8());
    #elif JUCE_LINUX
        // setenv("VLC_PLUGIN_PATH", "/path/to/plugins", 1);
    #endif

    const char* args[] = { 
        "--aout=amem", 
        "--vout=vmem",
        "--no-video-title-show",
        "--no-osd"
    };
    m_instance = libvlc_new(sizeof(args) / sizeof(args[0]), args);
    
    if (m_instance)
    {
        m_mediaPlayer = libvlc_media_player_new(m_instance);
        if (m_mediaPlayer)
        {
            libvlc_audio_set_callbacks(m_mediaPlayer, audioPlay, audioPause, audioResume, audioFlush, audioDrain, this);
            libvlc_audio_set_format(m_mediaPlayer, "S16N", 44100, 2);

            libvlc_video_set_callbacks(m_mediaPlayer, videoLock, videoUnlock, videoDisplay, this);
            libvlc_video_set_format(m_mediaPlayer, "RV32", videoWidth, videoHeight, videoWidth * 4);
            
            currentVideoImage = juce::Image(juce::Image::ARGB, videoWidth, videoHeight, true);
            bufferVideoImage = juce::Image(juce::Image::ARGB, videoWidth, videoHeight, true);
            
            currentVideoImage.clear(currentVideoImage.getBounds(), juce::Colours::black);
            bufferVideoImage.clear(bufferVideoImage.getBounds(), juce::Colours::black);
        }
    }
    else
    {
        DBG("CRITICAL: libvlc_new failed. Check plugin path: " + pluginDir.getFullPathName());
    }
}

VLCMediaPlayer_Desktop::~VLCMediaPlayer_Desktop()
{
    stop();
    if (m_mediaPlayer) libvlc_media_player_release(m_mediaPlayer);
    if (m_instance) libvlc_release(m_instance);
}

bool VLCMediaPlayer_Desktop::prepareToPlay(int samplesPerBlock, double sampleRate)
{
    if (sampleRate > 1000.0)
        currentSampleRate = sampleRate;
    else
        currentSampleRate = 44100.0;

    maxBlockSize = samplesPerBlock;
    
    ringBuffer.setSize(2, 65536); 
    fifo.setTotalSize(ringBuffer.getNumSamples());
    fifo.reset();
    if (m_mediaPlayer)
    {
        libvlc_audio_set_format(m_mediaPlayer, "S16N", static_cast<int>(currentSampleRate), 2);
    }

    isPrepared = true;
    return true;
}

void VLCMediaPlayer_Desktop::releaseResources()
{
    stop();
    fifo.reset();
    ringBuffer.clear();
    isPrepared = false;
}

bool VLCMediaPlayer_Desktop::loadFile(const juce::String& path)
{
    stop();
    if (!m_instance || !m_mediaPlayer) return false;
    int rate = (currentSampleRate > 0) ? static_cast<int>(currentSampleRate) : 44100;
    libvlc_audio_set_format(m_mediaPlayer, "S16N", rate, 2);

    libvlc_media_t* media = libvlc_media_new_path(m_instance, path.toUTF8());
    if (media == nullptr) return false;

    libvlc_media_player_set_media(m_mediaPlayer, media);
    libvlc_media_release(media);
    return true;
}

void VLCMediaPlayer_Desktop::play()
{
    if (m_mediaPlayer) 
    {
        int rate = (currentSampleRate > 0) ? static_cast<int>(currentSampleRate) : 44100;
        libvlc_audio_set_format(m_mediaPlayer, "S16N", rate, 2);
        libvlc_media_player_play(m_mediaPlayer);
    }
}

void VLCMediaPlayer_Desktop::pause()
{
    if (m_mediaPlayer) libvlc_media_player_pause(m_mediaPlayer);
}

void VLCMediaPlayer_Desktop::stop()
{
    if (m_mediaPlayer) libvlc_media_player_stop(m_mediaPlayer);
    
    juce::ScopedLock sl(audioLock);
    fifo.reset();
    ringBuffer.clear();
    
    juce::ScopedLock slV(videoLockMutex);
    if (currentVideoImage.isValid())
        currentVideoImage.clear(currentVideoImage.getBounds(), juce::Colours::black);
}

void VLCMediaPlayer_Desktop::setVolume(float newVolume)
{
    volume = juce::jlimit(0.0f, 20.0f, newVolume);
}

float VLCMediaPlayer_Desktop::getVolume() const { return volume; }

void VLCMediaPlayer_Desktop::setRate(float newRate)
{
    if (m_mediaPlayer) libvlc_media_player_set_rate(m_mediaPlayer, newRate);
}

float VLCMediaPlayer_Desktop::getRate() const
{
    return m_mediaPlayer ? libvlc_media_player_get_rate(m_mediaPlayer) : 1.0f;
}

bool VLCMediaPlayer_Desktop::hasFinished() const
{
    if (!m_mediaPlayer) return false;
    return libvlc_media_player_get_state(m_mediaPlayer) == libvlc_Ended;
}

bool VLCMediaPlayer_Desktop::isPlaying() const
{
    if (!m_mediaPlayer) return false;
    return libvlc_media_player_is_playing(m_mediaPlayer) != 0;
}

float VLCMediaPlayer_Desktop::getPosition() const
{
    if (!m_mediaPlayer) return 0.0f;
    return libvlc_media_player_get_position(m_mediaPlayer);
}

void VLCMediaPlayer_Desktop::setPosition(float pos)
{
    if (m_mediaPlayer) libvlc_media_player_set_position(m_mediaPlayer, pos);
}

int64_t VLCMediaPlayer_Desktop::getLengthMs() const
{
    if (!m_mediaPlayer) return 0;
    return libvlc_media_player_get_length(m_mediaPlayer);
}

void* VLCMediaPlayer_Desktop::videoLock(void* data, void** planes)
{
    auto* self = static_cast<VLCMediaPlayer_Desktop*>(data);
    if (self && self->bufferVideoImage.isValid())
    {
        juce::Image::BitmapData bitmapData(self->bufferVideoImage, juce::Image::BitmapData::readWrite);
        *planes = bitmapData.data;
        return nullptr;
    }
    return nullptr;
}

void VLCMediaPlayer_Desktop::videoUnlock(void* data, void* picture, void* const* planes)
{
    juce::ignoreUnused(data, picture, planes);
}

void VLCMediaPlayer_Desktop::videoDisplay(void* data, void* picture)
{
    auto* self = static_cast<VLCMediaPlayer_Desktop*>(data);
    if (self)
    {
        juce::ScopedLock sl(self->videoLockMutex);
        if (self->bufferVideoImage.isValid())
            self->currentVideoImage = self->bufferVideoImage.createCopy();
    }
}

juce::Image VLCMediaPlayer_Desktop::getCurrentVideoFrame()
{
    juce::ScopedLock sl(videoLockMutex);
    if (currentVideoImage.isValid())
        return currentVideoImage;
    return juce::Image();
}

void VLCMediaPlayer_Desktop::audioPlay(void* data, const void* samples, unsigned count, int64_t pts) {
    auto* self = static_cast<VLCMediaPlayer_Desktop*>(data);
    if (self) self->addAudioSamples(samples, count, pts);
}
void VLCMediaPlayer_Desktop::audioPause(void*, int64_t) {}
void VLCMediaPlayer_Desktop::audioResume(void*, int64_t) {}
void VLCMediaPlayer_Desktop::audioFlush(void* data, int64_t) {
    auto* self = static_cast<VLCMediaPlayer_Desktop*>(data);
    if (self) { juce::ScopedLock sl(self->audioLock); self->fifo.reset(); }
}
void VLCMediaPlayer_Desktop::audioDrain(void*) {}

void VLCMediaPlayer_Desktop::addAudioSamples(const void* samples, unsigned count, int64_t pts)
{
    juce::ScopedLock sl(audioLock);
    const int space = fifo.getFreeSpace();
    int toWrite = juce::jmin(static_cast<int>(count), space);
    if (toWrite > 0)
    {
        int start1, size1, start2, size2;
        fifo.prepareToWrite(toWrite, start1, size1, start2, size2);
        
        const int16_t* src = static_cast<const int16_t*>(samples);
        const float scale = 1.0f / 32768.0f;
        if (size1 > 0) {
            for (int i = 0; i < size1; ++i) {
                float left = src[i * 2] * scale;
                float right = src[i * 2 + 1] * scale;
                ringBuffer.setSample(0, start1 + i, left);
                ringBuffer.setSample(1, start1 + i, right);
            }
        }
        if (size2 > 0) {
            for (int i = 0; i < size2; ++i) {
                float left = src[(size1 + i) * 2] * scale;
                float right = src[(size1 + i) * 2 + 1] * scale;
                ringBuffer.setSample(0, start2 + i, left);
                ringBuffer.setSample(1, start2 + i, right);
            }
        }
        fifo.finishedWrite(size1 + size2);
    }
}

void VLCMediaPlayer_Desktop::getNextAudioBlock(const juce::AudioSourceChannelInfo& info)
{
    if (!isPrepared) { info.clearActiveBufferRegion(); return; }
    
    if (libvlc_media_player_get_state(m_mediaPlayer) == libvlc_Paused)
    {
        info.clearActiveBufferRegion();
        return;
    }

    juce::ScopedLock sl(audioLock);
    
    int numSamples = info.numSamples;
    int available = fifo.getNumReady();
    int toRead = juce::jmin(numSamples, available);
    if (toRead > 0) {
        int start1, size1, start2, size2;
        fifo.prepareToRead(toRead, start1, size1, start2, size2);
        
        if (size1 > 0) {
            for (int ch = 0; ch < 2; ++ch) 
                info.buffer->addFrom(ch, info.startSample, ringBuffer, ch, start1, size1, volume);
        }
        if (size2 > 0) {
            for (int ch = 0; ch < 2; ++ch)
                info.buffer->addFrom(ch, info.startSample + size1, ringBuffer, ch, start2, size2, volume);
        }
        fifo.finishedRead(size1 + size2);
    }
    
    if (toRead < numSamples) 
        info.buffer->clear(info.startSample + toRead, numSamples - toRead);
}



--------------------------------------------------------------------------------
File: src/engine/VLCMediaPlayer_Desktop.h
Size: 2.70 KB
--------------------------------------------------------------------------------

// ### **3. The Desktop Implementation (Source)** Your **original** `VLCMediaPlayer.cpp`, adapted to implement `VLCMediaPlayer_Desktop`.

/*
  ==============================================================================

    VLCMediaPlayer_Desktop.h
    OnStage

    Original LibVLC implementation for Windows/Mac/Linux.
    Renamed from VLCMediaPlayer to VLCMediaPlayer_Desktop.

  ==============================================================================
*/

#ifndef ONSTAGE_ENGINE_VLC_MEDIA_PLAYER_DESKTOP_H
#define ONSTAGE_ENGINE_VLC_MEDIA_PLAYER_DESKTOP_H

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_graphics/juce_graphics.h> 

extern "C" {
    #include <vlc/libvlc.h>
    #include <vlc/libvlc_media.h>
    #include <vlc/libvlc_renderer_discoverer.h> 
    #include <vlc/libvlc_media_player.h>
}

class VLCMediaPlayer_Desktop
{
public:
    VLCMediaPlayer_Desktop();
    ~VLCMediaPlayer_Desktop();

    bool prepareToPlay(int samplesPerBlock, double sampleRate);
    void releaseResources();
    bool loadFile(const juce::String& path);
    void play();
    void pause();
    void stop();
    void setVolume(float newVolume);
    float getVolume() const;
    void setRate(float newRate);
    float getRate() const;
    bool hasFinished() const;

    void getNextAudioBlock(const juce::AudioSourceChannelInfo& info);
    juce::Image getCurrentVideoFrame();

    bool isPlaying() const;
    float getPosition() const;
    void setPosition(float pos);
    int64_t getLengthMs() const;

private:
    static void audioPlay(void* data, const void* samples, unsigned count, int64_t pts);
    static void audioPause(void* data, int64_t pts);
    static void audioResume(void* data, int64_t pts);
    static void audioFlush(void* data, int64_t pts);
    static void audioDrain(void* data);

    static void* videoLock(void* data, void** planes);
    static void videoUnlock(void* data, void* picture, void* const* planes);
    static void videoDisplay(void* data, void* picture);

    void addAudioSamples(const void* samples, unsigned count, int64_t pts);

    libvlc_instance_t* m_instance = nullptr;
    libvlc_media_player_t* m_mediaPlayer = nullptr;
    
    juce::CriticalSection audioLock;
    juce::AudioBuffer<float> ringBuffer {2, 65536}; 
    juce::AbstractFifo fifo {65536};

    juce::CriticalSection videoLockMutex;
    juce::Image currentVideoImage; 
    juce::Image bufferVideoImage;
    int videoWidth = 1280;
    int videoHeight = 720;

    double currentSampleRate = 44100.0;
    int maxBlockSize = 512;
    float volume = 1.0f;
    bool isPrepared = false;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VLCMediaPlayer_Desktop)
};
#endif // ONSTAGE_ENGINE_VLC_MEDIA_PLAYER_DESKTOP_H



--------------------------------------------------------------------------------
File: src/engine/VLCMediaPlayer.cpp
Size: 9.13 KB
--------------------------------------------------------------------------------

#include "VLCMediaPlayer.h"
#include <cstring>
#include <juce_core/juce_core.h>

#if JUCE_LINUX
#include <stdlib.h>
#endif

VLCMediaPlayer::VLCMediaPlayer()
{
    // CRITICAL FIX: Ensure VLC finds its plugins relative to the executable
    juce::File appDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
    juce::File pluginDir = appDir.getChildFile("plugins");
    
    #if JUCE_WINDOWS
        juce::String pathEnv = "VLC_PLUGIN_PATH=" + pluginDir.getFullPathName();
        _putenv(pathEnv.toRawUTF8());
    #elif JUCE_LINUX
        // On Linux, if using system VLC, we typically don't need this.
        // But if you bundle libs, use setenv.
        // setenv("VLC_PLUGIN_PATH", "/path/to/plugins", 1);
    #endif

    // FIX: Added --vout=vmem to explicitly enable Video Memory output callbacks
    const char* args[] = { 
        "--aout=amem", 
        "--vout=vmem",
        "--no-video-title-show",
        "--no-osd"
    };

    m_instance = libvlc_new(sizeof(args) / sizeof(args[0]), args);
    
    if (m_instance)
    {
        m_mediaPlayer = libvlc_media_player_new(m_instance);
        if (m_mediaPlayer)
        {
            libvlc_audio_set_callbacks(m_mediaPlayer, audioPlay, audioPause, audioResume, audioFlush, audioDrain, this);
            libvlc_audio_set_format(m_mediaPlayer, "S16N", 44100, 2);

            libvlc_video_set_callbacks(m_mediaPlayer, videoLock, videoUnlock, videoDisplay, this);
            libvlc_video_set_format(m_mediaPlayer, "RV32", videoWidth, videoHeight, videoWidth * 4);
            
            // Initialize images only if player exists
            currentVideoImage = juce::Image(juce::Image::ARGB, videoWidth, videoHeight, true);
            bufferVideoImage = juce::Image(juce::Image::ARGB, videoWidth, videoHeight, true);
            
            // Clear to black initially
            currentVideoImage.clear(currentVideoImage.getBounds(), juce::Colours::black);
            bufferVideoImage.clear(bufferVideoImage.getBounds(), juce::Colours::black);
        }
    }
    else
    {
        // Log critical failure (Debugger only)
        DBG("CRITICAL: libvlc_new failed. Check plugin path: " + pluginDir.getFullPathName());
    }
}

VLCMediaPlayer::~VLCMediaPlayer()
{
    stop();
    if (m_mediaPlayer) libvlc_media_player_release(m_mediaPlayer);
    if (m_instance) libvlc_release(m_instance);
}

bool VLCMediaPlayer::prepareToPlay(int samplesPerBlock, double sampleRate)
{
    if (sampleRate > 1000.0)
        currentSampleRate = sampleRate;
    else
        currentSampleRate = 44100.0;

    maxBlockSize = samplesPerBlock;
    
    ringBuffer.setSize(2, 65536); 
    fifo.setTotalSize(ringBuffer.getNumSamples());
    fifo.reset();

    if (m_mediaPlayer)
    {
        libvlc_audio_set_format(m_mediaPlayer, "S16N", static_cast<int>(currentSampleRate), 2);
    }

    isPrepared = true;
    return true;
}

void VLCMediaPlayer::releaseResources()
{
    stop();
    fifo.reset();
    ringBuffer.clear();
    isPrepared = false;
}

bool VLCMediaPlayer::loadFile(const juce::String& path)
{
    stop();
    if (!m_instance || !m_mediaPlayer) return false;

    int rate = (currentSampleRate > 0) ? static_cast<int>(currentSampleRate) : 44100;
    libvlc_audio_set_format(m_mediaPlayer, "S16N", rate, 2);

    libvlc_media_t* media = libvlc_media_new_path(m_instance, path.toUTF8());
    if (media == nullptr) return false;

    libvlc_media_player_set_media(m_mediaPlayer, media);
    libvlc_media_release(media);
    return true;
}

void VLCMediaPlayer::play()
{
    if (m_mediaPlayer) 
    {
        int rate = (currentSampleRate > 0) ? static_cast<int>(currentSampleRate) : 44100;
        libvlc_audio_set_format(m_mediaPlayer, "S16N", rate, 2);
             
        libvlc_media_player_play(m_mediaPlayer);
    }
}

void VLCMediaPlayer::pause()
{
    if (m_mediaPlayer) libvlc_media_player_pause(m_mediaPlayer);
}

void VLCMediaPlayer::stop()
{
    if (m_mediaPlayer) libvlc_media_player_stop(m_mediaPlayer);
    
    juce::ScopedLock sl(audioLock);
    fifo.reset();
    ringBuffer.clear();
    
    juce::ScopedLock slV(videoLockMutex);
    // Instead of clear, fill with black
    if (currentVideoImage.isValid())
        currentVideoImage.clear(currentVideoImage.getBounds(), juce::Colours::black);
}

void VLCMediaPlayer::setVolume(float newVolume)
{
    volume = juce::jlimit(0.0f, 20.0f, newVolume);
}

float VLCMediaPlayer::getVolume() const { return volume; }

void VLCMediaPlayer::setRate(float newRate)
{
    if (m_mediaPlayer) libvlc_media_player_set_rate(m_mediaPlayer, newRate);
}

float VLCMediaPlayer::getRate() const
{
    return m_mediaPlayer ? libvlc_media_player_get_rate(m_mediaPlayer) : 1.0f;
}

bool VLCMediaPlayer::hasFinished() const
{
    if (!m_mediaPlayer) return false;
    return libvlc_media_player_get_state(m_mediaPlayer) == libvlc_Ended;
}

bool VLCMediaPlayer::isPlaying() const
{
    if (!m_mediaPlayer) return false;
    return libvlc_media_player_is_playing(m_mediaPlayer) != 0;
}

float VLCMediaPlayer::getPosition() const
{
    if (!m_mediaPlayer) return 0.0f;
    return libvlc_media_player_get_position(m_mediaPlayer);
}

void VLCMediaPlayer::setPosition(float pos)
{
    if (m_mediaPlayer) libvlc_media_player_set_position(m_mediaPlayer, pos);
}

int64_t VLCMediaPlayer::getLengthMs() const
{
    if (!m_mediaPlayer) return 0;
    return libvlc_media_player_get_length(m_mediaPlayer);
}

void* VLCMediaPlayer::videoLock(void* data, void** planes)
{
    auto* self = static_cast<VLCMediaPlayer*>(data);
    if (self && self->bufferVideoImage.isValid())
    {
        juce::Image::BitmapData bitmapData(self->bufferVideoImage, juce::Image::BitmapData::readWrite);
        *planes = bitmapData.data;
        return nullptr;
    }
    return nullptr;
}

void VLCMediaPlayer::videoUnlock(void* data, void* picture, void* const* planes)
{
    juce::ignoreUnused(data, picture, planes);
}

void VLCMediaPlayer::videoDisplay(void* data, void* picture)
{
    auto* self = static_cast<VLCMediaPlayer*>(data);
    if (self)
    {
        juce::ScopedLock sl(self->videoLockMutex);
        if (self->bufferVideoImage.isValid())
            self->currentVideoImage = self->bufferVideoImage.createCopy();
    }
}

juce::Image VLCMediaPlayer::getCurrentVideoFrame()
{
    juce::ScopedLock sl(videoLockMutex);
    if (currentVideoImage.isValid())
        return currentVideoImage;
    return juce::Image(); // Return null image if not valid
}

void VLCMediaPlayer::audioPlay(void* data, const void* samples, unsigned count, int64_t pts) {
    auto* self = static_cast<VLCMediaPlayer*>(data);
    if (self) self->addAudioSamples(samples, count, pts);
}
void VLCMediaPlayer::audioPause(void*, int64_t) {}
void VLCMediaPlayer::audioResume(void*, int64_t) {}
void VLCMediaPlayer::audioFlush(void* data, int64_t) {
    auto* self = static_cast<VLCMediaPlayer*>(data);
    if (self) { juce::ScopedLock sl(self->audioLock); self->fifo.reset(); }
}
void VLCMediaPlayer::audioDrain(void*) {}

void VLCMediaPlayer::addAudioSamples(const void* samples, unsigned count, int64_t pts)
{
    juce::ScopedLock sl(audioLock);
    const int space = fifo.getFreeSpace();
    int toWrite = juce::jmin(static_cast<int>(count), space);
    if (toWrite > 0)
    {
        int start1, size1, start2, size2;
        fifo.prepareToWrite(toWrite, start1, size1, start2, size2);
        
        const int16_t* src = static_cast<const int16_t*>(samples);
        const float scale = 1.0f / 32768.0f;
        if (size1 > 0) {
            for (int i = 0; i < size1; ++i) {
                float left = src[i * 2] * scale;
                float right = src[i * 2 + 1] * scale;
                ringBuffer.setSample(0, start1 + i, left);
                ringBuffer.setSample(1, start1 + i, right);
            }
        }
        if (size2 > 0) {
            for (int i = 0; i < size2; ++i) {
                float left = src[(size1 + i) * 2] * scale;
                float right = src[(size1 + i) * 2 + 1] * scale;
                ringBuffer.setSample(0, start2 + i, left);
                ringBuffer.setSample(1, start2 + i, right);
            }
        }
        fifo.finishedWrite(size1 + size2);
    }
}

void VLCMediaPlayer::getNextAudioBlock(const juce::AudioSourceChannelInfo& info)
{
    if (!isPrepared) { info.clearActiveBufferRegion(); return; }
    
    if (libvlc_media_player_get_state(m_mediaPlayer) == libvlc_Paused)
    {
        info.clearActiveBufferRegion();
        return;
    }

    juce::ScopedLock sl(audioLock);
    
    int numSamples = info.numSamples;
    int available = fifo.getNumReady();
    int toRead = juce::jmin(numSamples, available);
    if (toRead > 0) {
        int start1, size1, start2, size2;
        fifo.prepareToRead(toRead, start1, size1, start2, size2);
        
        if (size1 > 0) {
            for (int ch = 0; ch < 2; ++ch) 
                info.buffer->addFrom(ch, info.startSample, ringBuffer, ch, start1, size1, volume);
        }
        if (size2 > 0) {
            for (int ch = 0; ch < 2; ++ch)
                info.buffer->addFrom(ch, info.startSample + size1, ringBuffer, ch, start2, size2, volume);
        }
        fifo.finishedRead(size1 + size2);
    }
    
    if (toRead < numSamples) 
        info.buffer->clear(info.startSample + toRead, numSamples - toRead);
}



--------------------------------------------------------------------------------
File: src/engine/VLCMediaPlayer.h
Size: 0.79 KB
--------------------------------------------------------------------------------

/*
  ==============================================================================

    VLCMediaPlayer.h
    OnStage

    Acts as a facade to select between the Desktop (VLC) and Apple (Native) 
    media player implementations.

  ==============================================================================
*/

#ifndef ONSTAGE_ENGINE_VLC_MEDIA_PLAYER_FACADE_H
#define ONSTAGE_ENGINE_VLC_MEDIA_PLAYER_FACADE_H

#include <juce_core/juce_core.h>

#if JUCE_MAC || JUCE_IOS
    // Use Native AVFoundation for both macOS and iOS
    #include "NativeMediaPlayer_Apple.h"
    using VLCMediaPlayer = NativeMediaPlayer_Apple;
#else
    // Use VLC for Windows and Linux
    #include "VLCMediaPlayer_Desktop.h"
    using VLCMediaPlayer = VLCMediaPlayer_Desktop;
#endif

#endif // ONSTAGE_ENGINE_VLC_MEDIA_PLAYER_FACADE_H



--------------------------------------------------------------------------------
File: src/IOSettingsManager.cpp
Size: 9.96 KB
--------------------------------------------------------------------------------

#include "IOSettingsManager.h"
#include "AppLogger.h"
#include <juce_core/juce_core.h>

IOSettingsManager::IOSettingsManager()
{
    lastDriverType = "";
    lastSpecificDriver = "";
    lastMediaFolder = juce::File::getSpecialLocation(juce::File::userMusicDirectory).getFullPathName();
    lastPlaylistFolder = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory).getFullPathName();
    lastLatencyMs = 0.0f;
    lastVocalBoostDb = 0.0f;
    lastMidiDevice = "";
    
    // Initialize Mic Settings
    for (int i = 0; i < 2; ++i) {
        micSettings[i].inputName = "OFF";
        micSettings[i].isMuted = false;
        micSettings[i].isBypassed = false;
    }

    for (int i = 0; i < 9; ++i)
    {
        backingTrackInputs[i].enabled = false;
        backingTrackInputs[i].mappedInput = -1;
        backingTrackInputs[i].leftSelection = "OFF";
        backingTrackInputs[i].rightSelection = "OFF";
        backingTrackInputs[i].gain = 1.0f;
    }
}

void IOSettingsManager::saveDriverType(const juce::String& driverType) { lastDriverType = driverType;
saveToFile(); }
void IOSettingsManager::saveSpecificDriver(const juce::String& driverName) { lastSpecificDriver = driverName; saveToFile();
}

// UPDATED: Mic Save Functions
void IOSettingsManager::saveMicInput(int micIndex, const juce::String& inputName) {
    if (micIndex >= 0 && micIndex < 2) {
        micSettings[micIndex].inputName = inputName;
        saveToFile();
    }
}

void IOSettingsManager::saveMicMute(int micIndex, bool shouldMute) {
    if (micIndex >= 0 && micIndex < 2) {
        micSettings[micIndex].isMuted = shouldMute;
        saveToFile();
    }
}

void IOSettingsManager::saveMicBypass(int micIndex, bool shouldBypass) {
    if (micIndex >= 0 && micIndex < 2) {
        micSettings[micIndex].isBypassed = shouldBypass;
        saveToFile();
    }
}

// NEW: Save Output Routing Map
void IOSettingsManager::saveOutputRouting(const std::map<juce::String, int>& routingMap) {
    outputRoutingMap = routingMap;
    saveToFile();
}

void IOSettingsManager::saveBackingTrackInput(int index, bool enabled, int mappedInput, 
                                              const juce::String& leftSelection, 
                                              const juce::String& rightSelection,
                                              float gain) 
{
    if (index >= 0 && index < 9) {
        backingTrackInputs[index].enabled = enabled;
        backingTrackInputs[index].mappedInput = mappedInput;
        backingTrackInputs[index].leftSelection = leftSelection;
        backingTrackInputs[index].rightSelection = rightSelection;
        backingTrackInputs[index].gain = gain;
        saveToFile();
    }
}

void IOSettingsManager::saveMediaFolder(const juce::String& path) { lastMediaFolder = path; saveToFile(); }
void IOSettingsManager::savePlaylistFolder(const juce::String& path) { lastPlaylistFolder = path; saveToFile();
}
void IOSettingsManager::saveVocalSettings(float latencyMs, float boostDb) { lastLatencyMs = latencyMs; lastVocalBoostDb = boostDb; saveToFile();
}
void IOSettingsManager::saveMidiDevice(const juce::String& deviceName) { lastMidiDevice = deviceName; saveToFile(); }

bool IOSettingsManager::loadSettings()
{
    auto file = getSettingsFile();
    if (!file.existsAsFile()) {
        LOG_INFO("IOSettingsManager: Settings file not found at " + file.getFullPathName());
        return false;
    }
    
    LOG_INFO("IOSettingsManager: Loading settings from " + file.getFullPathName());
    try {
        auto json = juce::JSON::parse(file);
        if (auto* obj = json.getDynamicObject())
        {
            lastDriverType = obj->getProperty("driverType").toString();
            lastSpecificDriver = obj->getProperty("specificDriver").toString();
            
            if (obj->hasProperty("mediaFolder")) lastMediaFolder = obj->getProperty("mediaFolder").toString();
            if (obj->hasProperty("playlistFolder")) lastPlaylistFolder = obj->getProperty("playlistFolder").toString();
            if (obj->hasProperty("latencyMs")) lastLatencyMs = (float)obj->getProperty("latencyMs");
            if (obj->hasProperty("vocalBoostDb")) lastVocalBoostDb = (float)obj->getProperty("vocalBoostDb");
            if (obj->hasProperty("midiDevice")) lastMidiDevice = obj->getProperty("midiDevice").toString();
            // UPDATED: Load Mic Settings (Backwards compatible with old string arrays)
            if (auto* mics = obj->getProperty("micInputs").getArray()) {
                for (int i = 0; i < juce::jmin(2, mics->size()); ++i) {
                    // Check if it's an object (New Format) or just a string (Old Format)
                    if (auto* micObj = mics->getReference(i).getDynamicObject()) {
                        micSettings[i].inputName = micObj->getProperty("name").toString();
                        micSettings[i].isMuted = micObj->getProperty("mute");
                        micSettings[i].isBypassed = micObj->getProperty("bypass");
                    } else {
                        // Old format: just the name string
                        micSettings[i].inputName = mics->getReference(i).toString();
                        micSettings[i].isMuted = false;
                        micSettings[i].isBypassed = false;
                    }
                }
            }

            // NEW: Load Output Routing
            outputRoutingMap.clear();
            if (auto* outputs = obj->getProperty("outputRouting").getArray()) {
                for (auto& item : *outputs) {
                    if (auto* routeObj = item.getDynamicObject()) {
                        juce::String name = routeObj->getProperty("name").toString();
                        int mask = (int)routeObj->getProperty("mask");
                        outputRoutingMap[name] = mask;
                    }
                }
            } else if (auto* oldOutputs = obj->getProperty("outputs").getArray()) {
                // FALLBACK: Load old list format if present
                for (auto& item : *oldOutputs) {
                    outputRoutingMap[item.toString()] = 3; // Enable both L+R for migrated outputs
                }
            }
            
            if (auto* backing = obj->getProperty("backingTrackInputs").getArray()) {
                for (int i = 0; i < juce::jmin(9, backing->size()); ++i) {
                    if (auto* btObj = backing->getReference(i).getDynamicObject()) {
                        backingTrackInputs[i].enabled = btObj->getProperty("enabled");
                        backingTrackInputs[i].mappedInput = btObj->getProperty("mappedInput");
                        backingTrackInputs[i].leftSelection = btObj->getProperty("leftSelection").toString();
                        backingTrackInputs[i].rightSelection = btObj->getProperty("rightSelection").toString();
                        if (btObj->hasProperty("gain")) backingTrackInputs[i].gain = (float)btObj->getProperty("gain");
                        else backingTrackInputs[i].gain = 1.0f;
                    }
                }
            }
            LOG_INFO("IOSettingsManager: Load Complete. Driver=" + lastSpecificDriver);
            return true;
        }
    }
    catch (...) {
        LOG_ERROR("IOSettingsManager: Failed to parse JSON");
    }
    return false;
}

IOSettingsManager::MicSettings IOSettingsManager::getMicSettings(int index) const {
    if (index >= 0 && index < 2) return micSettings[index];
    return MicSettings();
}

IOSettingsManager::BackingTrackInputState IOSettingsManager::getBackingTrackInput(int index) const { 
    if (index >= 0 && index < 9) return backingTrackInputs[index];
    return BackingTrackInputState();
}

bool IOSettingsManager::hasExistingSettings() const { return getSettingsFile().existsAsFile(); }

juce::File IOSettingsManager::getSettingsFile() const {
    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory);
    auto onstageDir = appDataDir.getChildFile("OnStage");
    if (!onstageDir.exists()) onstageDir.createDirectory();
    return onstageDir.getChildFile("io_settings.json");
}

bool IOSettingsManager::saveToFile()
{
    auto file = getSettingsFile();
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("driverType", lastDriverType);
    obj->setProperty("specificDriver", lastSpecificDriver);
    obj->setProperty("mediaFolder", lastMediaFolder);
    obj->setProperty("playlistFolder", lastPlaylistFolder);
    obj->setProperty("latencyMs", lastLatencyMs);
    obj->setProperty("vocalBoostDb", lastVocalBoostDb);
    obj->setProperty("midiDevice", lastMidiDevice);
    // UPDATED: Save Mic Settings as Objects
    juce::Array<juce::var> mics;
    for (int i = 0; i < 2; ++i) {
        juce::DynamicObject::Ptr micObj = new juce::DynamicObject();
        micObj->setProperty("name", micSettings[i].inputName);
        micObj->setProperty("mute", micSettings[i].isMuted);
        micObj->setProperty("bypass", micSettings[i].isBypassed);
        mics.add(micObj.get());
    }
    obj->setProperty("micInputs", mics);
    
    // NEW: Save Output Routing Map
    juce::Array<juce::var> outputArr;
    for (auto const& [name, mask] : outputRoutingMap) {
        juce::DynamicObject::Ptr routeObj = new juce::DynamicObject();
        routeObj->setProperty("name", name);
        routeObj->setProperty("mask", mask);
        outputArr.add(routeObj.get());
    }
    obj->setProperty("outputRouting", outputArr);

    juce::Array<juce::var> backing;
    for (int i = 0; i < 9; ++i) {
        juce::DynamicObject::Ptr btObj = new juce::DynamicObject();
        btObj->setProperty("enabled", backingTrackInputs[i].enabled);
        btObj->setProperty("mappedInput", backingTrackInputs[i].mappedInput);
        btObj->setProperty("leftSelection", backingTrackInputs[i].leftSelection);
        btObj->setProperty("rightSelection", backingTrackInputs[i].rightSelection);
        btObj->setProperty("gain", backingTrackInputs[i].gain);
        backing.add(btObj.get());
    }
    obj->setProperty("backingTrackInputs", backing);

    file.replaceWithText(juce::JSON::toString(juce::var(obj.get())));
    return true;
}



--------------------------------------------------------------------------------
File: src/IOSettingsManager.h
Size: 3.14 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_core/juce_core.h>
#include <juce_data_structures/juce_data_structures.h>
#include <map>

class IOSettingsManager
{
public:
    IOSettingsManager();
    ~IOSettingsManager() = default;

    void saveDriverType(const juce::String& driverType);
    void saveSpecificDriver(const juce::String& driverName);
    // UPDATED: New separated save functions for Mic State
    void saveMicInput(int micIndex, const juce::String& inputName);
    void saveMicMute(int micIndex, bool shouldMute);
    void saveMicBypass(int micIndex, bool shouldBypass);

    // NEW: Save Output Routing (Name -> Mask)
    void saveOutputRouting(const std::map<juce::String, int>& routingMap);
    
    void saveBackingTrackInput(int index, bool enabled, int mappedInput, 
                               const juce::String& leftSelection = "OFF", 
                               const juce::String& rightSelection = "OFF",
                               float gain = 1.0f);
    
    void saveMediaFolder(const juce::String& path);
    juce::String getMediaFolder() const { return lastMediaFolder; }

    void savePlaylistFolder(const juce::String& path);
    juce::String getPlaylistFolder() const { return lastPlaylistFolder; }

    // Vocal Recording Settings
    void saveVocalSettings(float latencyMs, float boostDb);
    float getLastLatencyMs() const { return lastLatencyMs; }
    float getLastVocalBoostDb() const { return lastVocalBoostDb; }

    // MIDI Settings
    void saveMidiDevice(const juce::String& deviceName);
    juce::String getLastMidiDevice() const { return lastMidiDevice; }

    bool loadSettings();

    juce::String getLastDriverType() const { return lastDriverType; }
    juce::String getLastSpecificDriver() const { return lastSpecificDriver; }
    
    // UPDATED: Struct to hold full mic state
    struct MicSettings
    {
        juce::String inputName = "OFF";
        bool isMuted = false;
        bool isBypassed = false;
    };

    MicSettings getMicSettings(int index) const;
    
    // NEW: Get Output Routing Map
    std::map<juce::String, int> getOutputRouting() const { return outputRoutingMap; }

    struct BackingTrackInputState
    {
        bool enabled = false;
        int mappedInput = -1;
        juce::String leftSelection = "OFF";
        juce::String rightSelection = "OFF";
        float gain = 1.0f;
        bool isValid() const { return enabled && mappedInput >= 0; }
    };

    BackingTrackInputState getBackingTrackInput(int index) const;
    bool hasExistingSettings() const;

private:
    juce::File getSettingsFile() const;
    bool saveToFile();

    juce::String lastDriverType;
    juce::String lastSpecificDriver;
    // UPDATED: Store full settings instead of just name
    MicSettings micSettings[2];
    
    // NEW: Map of Output Name -> Routing Mask (0=Off, 1=L, 2=R, 3=LR)
    std::map<juce::String, int> outputRoutingMap;
    
    BackingTrackInputState backingTrackInputs[9];
    juce::String lastMediaFolder = ""; 
    juce::String lastPlaylistFolder = "";
    
    float lastLatencyMs = 0.0f;
    float lastVocalBoostDb = 0.0f;
    juce::String lastMidiDevice = "";
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(IOSettingsManager)
};



--------------------------------------------------------------------------------
File: src/LegacyMainComponent.cpp
Size: 1.79 KB
--------------------------------------------------------------------------------

// *(Formerly `src/MainComponent.cpp` - Renamed class/includes)*

#include "LegacyMainComponent.h"
#include "UI/RegistrationComponent.h" 

LegacyMainComponent::LegacyMainComponent()
{
    addAndMakeVisible (headerRegisterButton);
    headerRegisterButton.addListener (this);
    
    if (registrationManager.isProMode())
    {
        headerRegisterButton.setButtonText("License Info");
    }
    else
    {
        headerRegisterButton.setButtonText("REGISTER");
        headerRegisterButton.setColour(juce::TextButton::textColourOffId, juce::Colours::orange);
    }

    setSize (800, 600);
}

LegacyMainComponent::~LegacyMainComponent()
{
    headerRegisterButton.removeListener (this);
}

void LegacyMainComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::darkgrey);
    g.setColour (juce::Colours::black);
    g.fillRect (getLocalBounds().removeFromTop (50));
    
    g.setColour (juce::Colours::white);
    g.setFont (20.0f);
    g.drawText ("Panduri VSTi (Legacy View)", 20, 0, 200, 50, juce::Justification::centredLeft);
}

void LegacyMainComponent::resized()
{
    auto headerArea = getLocalBounds().removeFromTop (50);
    headerRegisterButton.setBounds (headerArea.removeFromRight (120).reduced (10));
}

void LegacyMainComponent::buttonClicked (juce::Button* button)
{
    if (button == &headerRegisterButton)
    {
        juce::DialogWindow::LaunchOptions options;
        auto* dialogContent = new RegistrationComponent();
        options.content.setOwned (dialogContent);
        options.dialogTitle = "Registration";
        options.componentToCentreAround = this;
        options.dialogBackgroundColour = juce::Colour(0xffd35400);
        options.escapeKeyTriggersCloseButton = true;
        options.useNativeTitleBar = false;
        options.resizable = false;
        options.launchAsync();
    }
}



--------------------------------------------------------------------------------
File: src/LegacyMainComponent.h
Size: 0.76 KB
--------------------------------------------------------------------------------

// *(Formerly `src/MainComponent.h` - Renamed class to avoid conflict)*

#pragma once
#include <JuceHeader.h>
#include "RegistrationManager.h"
// NOTE: This is the legacy component. The active one is in src/UI/MainComponent.h

class LegacyMainComponent  : public juce::Component,
                             public juce::Button::Listener
{
public:
    LegacyMainComponent();
    ~LegacyMainComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    
    void buttonClicked (juce::Button* button) override;

private:
    RegistrationManager& registrationManager = RegistrationManager::getInstance();
    
    juce::TextButton headerRegisterButton { "Register" };
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (LegacyMainComponent)
};



--------------------------------------------------------------------------------
File: src/Main.cpp
Size: 2.78 KB
--------------------------------------------------------------------------------

// **Fix:** Wrapped `WinMain` in a `try/catch` block to capture and log the crash reason.

// ======================================================================
// Main.cpp - OnStage Entry Point (Explicit WinMain)
// ======================================================================
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_events/juce_events.h>
#include <juce_core/juce_core.h>
#include "App.h"
#include "AppLogger.h" // Include logger to report crashes

// ======================================================================
// Factory function for creating the app
// ======================================================================
juce::JUCEApplicationBase* juce_CreateApplication()
{
    return new OnStageApplication();
}

// ======================================================================
// Explicit WinMain Entry Point for Windows
// ======================================================================
#if defined(_WIN32) || defined(_WIN64)

#include <windows.h>

int __stdcall WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
    juce::JUCEApplicationBase::createInstance = &juce_CreateApplication;
    
    try 
    {
        return juce::JUCEApplicationBase::main();
    }
    catch (const std::exception& e)
    {
        // NAIL THE PROBLEM: Log the standard exception
        juce::String errorMsg = "CRITICAL CRASH: " + juce::String(e.what());
        
        // Log to file if possible
        // We try-catch this too in case Logger isn't ready
        try { AppLogger::getInstance().logError(errorMsg); } catch(...) {}
        
        // Show a loud box to the user so they know exactly what happened
        juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::WarningIcon,
            "Application Crashed", 
            errorMsg + "\n\nPlease check the log file.");
            
        return -1;
    }
    catch (...)
    {
        // Catch non-standard exceptions
        juce::String errorMsg = "CRITICAL CRASH: Unknown Exception occurred!";
        try { AppLogger::getInstance().logError(errorMsg); } catch(...) {}
        
        juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::WarningIcon,
            "Application Crashed", 
            "An unknown system error occurred.");
            
        return -1;
    }
}

#else

// ======================================================================
// Standard main() for non-Windows platforms
// ======================================================================
int main(int argc, char* argv[])
{
    juce::JUCEApplicationBase::createInstance = &juce_CreateApplication;
    return juce::JUCEApplicationBase::main(argc, (const char**)argv);
}

#endif



--------------------------------------------------------------------------------
File: src/PresetManager.cpp
Size: 17.05 KB
--------------------------------------------------------------------------------

#include "PresetManager.h"
#include <juce_core/juce_core.h>

PresetManager::PresetManager(AudioEngine& engine)
    : audioEngine(engine), currentPresetName("Default")
{
    loadDefaultPreset();
}

void PresetManager::loadDefaultPreset()
{
    // ==============================================================================
    // Channel 1 settings (Based on UPDATED Preset "a12")
    // ==============================================================================
    audioEngine.setMicPreampGain(0, -1.9f);
    audioEngine.setMicMute(0, false);       // Updated: Mute is false
    audioEngine.setFxBypass(0, false);

    // --- EQ 1 ---
    auto& eq1 = audioEngine.getEQProcessor(0);
    eq1.setLowFrequency(638.05f);
    eq1.setMidFrequency(1000.0f);
    eq1.setHighFrequency(2713.07f);
    
    eq1.setLowGain(-4.92f);
    eq1.setMidGain(0.0f);
    eq1.setHighGain(0.0f);
    
    eq1.setLowQ(2.38f);
    eq1.setMidQ(6.49f);
    eq1.setHighQ(5.69f);
    
    eq1.setBypassed(false);
    
    // --- Compressor 1 ---
    auto& comp1 = audioEngine.getCompressorProcessor(0);
    CompressorProcessor::Params params1;
    params1.thresholdDb = -18.0f;
    params1.ratio = 2.33f;
    params1.attackMs = 0.1f;
    params1.releaseMs = 54.55f;
    params1.makeupDb = 3.96f;
    comp1.setParams(params1);
    comp1.setBypassed(false);

    // --- Exciter 1 ---
    auto& exc1 = audioEngine.getExciterProcessor(0);
    ExciterProcessor::Params exParams1;
    exParams1.frequency = 1990.0f;
    exParams1.amount = 6.96f;  // Updated
    exParams1.mix = 0.58f;
    exc1.setParams(exParams1);
    exc1.setBypassed(false);
    
    // ==============================================================================
    // Channel 2 settings
    // ==============================================================================
    audioEngine.setMicPreampGain(1, 0.0f);
    audioEngine.setMicMute(1, false);
    audioEngine.setFxBypass(1, false);

    // --- EQ 2 ---
    auto& eq2 = audioEngine.getEQProcessor(1);
    eq2.setLowFrequency(648.96f); // Updated
    eq2.setMidFrequency(1000.0f);
    eq2.setHighFrequency(2731.96f); // Updated
    
    eq2.setLowGain(0.0f);
    eq2.setMidGain(0.0f);
    eq2.setHighGain(0.0f);
    
    eq2.setLowQ(0.707f);
    eq2.setMidQ(0.707f);
    eq2.setHighQ(0.707f);
    
    eq2.setBypassed(false);
    
    // --- Compressor 2 ---
    auto& comp2 = audioEngine.getCompressorProcessor(1);
    CompressorProcessor::Params params2;
    params2.thresholdDb = -18.0f;
    params2.ratio = 3.0f;
    params2.attackMs = 8.0f;
    params2.releaseMs = 120.0f;
    params2.makeupDb = 0.0f;
    comp2.setParams(params2);
    comp2.setBypassed(false);

    // --- Exciter 2 ---
    auto& exc2 = audioEngine.getExciterProcessor(1);
    ExciterProcessor::Params exParams2;
    exParams2.frequency = 2350.0f; // Updated
    exParams2.amount = 1.92f;      // Updated
    exParams2.mix = 0.11f;         // Updated
    exc2.setParams(exParams2);
    exc2.setBypassed(false);

    // ==============================================================================
    // Global Effects
    // ==============================================================================

    // --- Harmonizer ---
    auto& harmonizer = audioEngine.getHarmonizerProcessor();
    HarmonizerProcessor::Params harmParams;
    harmParams.enabled = true;
    harmParams.wetDb = -3.12f;
    harmParams.glideMs = 50.0f; 
    
    harmParams.voices[0].enabled = true;
    harmParams.voices[0].fixedSemitones = 2.88f;
    harmParams.voices[0].gainDb = -6.0f;
    
    harmParams.voices[1].enabled = true;
    harmParams.voices[1].fixedSemitones = 7.20f;
    harmParams.voices[1].gainDb = -6.0f;
    
    harmonizer.setParams(harmParams);
    harmonizer.setBypassed(true); // Updated: Harmonizer bypass is TRUE in new JSON

    // --- Reverb ---
    auto& reverb = audioEngine.getReverbProcessor();
    ReverbProcessor::Params reverbParams;
    reverbParams.wetGain = 1.9f; // Updated
    reverbParams.lowCutHz = 470.8f;
    reverbParams.highCutHz = 9360.0f;
    reverbParams.irFilePath = ""; 
    reverb.setParams(reverbParams);
    reverb.setBypassed(false);

    // --- Delay ---
    auto& delay = audioEngine.getDelayProcessor();
    DelayProcessor::Params delayParams;
    delayParams.delayMs = 350.0f;
    delayParams.ratio = 0.3f;   
    delayParams.stage = 0.25f; 
    delayParams.mix = 1.0f;
    delayParams.stereoWidth = 1.0f;
    delayParams.lowCutHz = 200.0f;
    delayParams.highCutHz = 8000.0f;
    delay.setParams(delayParams);
    delay.setBypassed(true);

    // --- Dynamic EQ (Sidechain) ---
    auto& dynEQ = audioEngine.getDynamicEQProcessor();
    DynamicEQProcessor::Params dynEQParams;
    dynEQParams.duckBandHz = 1838.0f;
    dynEQParams.q = 7.33f;
    dynEQParams.shape = 0.5f;
    dynEQParams.threshold = -14.4f;
    dynEQParams.ratio = 2.52f;
    dynEQParams.attack = 6.09f;
    dynEQParams.release = 128.8f;
    dynEQ.setParams(dynEQParams);
    dynEQ.setBypassed(false);
    
    currentPresetName = "a12";
}

juce::String PresetManager::getCurrentPresetName() const
{
    return currentPresetName;
}

// ==============================================================================
// SAVE
// ==============================================================================
bool PresetManager::savePreset(const juce::File& file)
{
    juce::DynamicObject::Ptr root = new juce::DynamicObject();
    root->setProperty("presetName", file.getFileNameWithoutExtension());
    root->setProperty("version", "1.0");

    // --- Mics ---
    juce::Array<juce::var> mics;
    for (int i = 0; i < 2; ++i)
    {
        juce::DynamicObject::Ptr micObj = new juce::DynamicObject();
        micObj->setProperty("preampGain", audioEngine.getMicPreampGain(i));
        micObj->setProperty("mute", audioEngine.isMicMuted(i));
        micObj->setProperty("fxBypass", audioEngine.isFxBypassed(i));

        auto& eq = audioEngine.getEQProcessor(i);
        juce::DynamicObject::Ptr eqObj = new juce::DynamicObject();
        eqObj->setProperty("lowFreq", eq.getLowFrequency());
        eqObj->setProperty("midFreq", eq.getMidFrequency());
        eqObj->setProperty("highFreq", eq.getHighFrequency());
        eqObj->setProperty("lowGain", eq.getLowGain());
        eqObj->setProperty("midGain", eq.getMidGain());
        eqObj->setProperty("highGain", eq.getHighGain());
        eqObj->setProperty("lowQ", eq.getLowQ());
        eqObj->setProperty("midQ", eq.getMidQ());
        eqObj->setProperty("highQ", eq.getHighQ());
        micObj->setProperty("eq", eqObj.get());
        micObj->setProperty("eqBypass", eq.isBypassed());

        auto& comp = audioEngine.getCompressorProcessor(i);
        micObj->setProperty("compressor", compParamsToVar(comp.getParams()));
        micObj->setProperty("compBypass", comp.isBypassed());

        auto& exc = audioEngine.getExciterProcessor(i);
        micObj->setProperty("exciter", exciterParamsToVar(exc.getParams()));
        micObj->setProperty("excBypass", exc.isBypassed());

        mics.add(micObj.get());
    }
    root->setProperty("mics", mics);

    // --- Globals ---
    auto& harm = audioEngine.getHarmonizerProcessor();
    root->setProperty("harmonizer", harmonizerParamsToVar(harm.getParams()));
    root->setProperty("harmonizerBypass", harm.isBypassed());

    auto& verb = audioEngine.getReverbProcessor();
    root->setProperty("reverb", reverbParamsToVar(verb.getParams()));
    root->setProperty("reverbBypass", verb.isBypassed());

    auto& delay = audioEngine.getDelayProcessor();
    root->setProperty("delay", delayParamsToVar(delay.getParams()));
    root->setProperty("delayBypass", delay.isBypassed());

    auto& dynEq = audioEngine.getDynamicEQProcessor();
    root->setProperty("dynamicEQ", dynEqParamsToVar(dynEq.getParams()));
    root->setProperty("dynEqBypass", dynEq.isBypassed());

    juce::String jsonString = juce::JSON::toString(juce::var(root), false);
    if (file.replaceWithText(jsonString))
    {
        currentPresetName = file.getFileNameWithoutExtension();
        return true;
    }
    return false;
}

// ==============================================================================
// LOAD
// ==============================================================================
bool PresetManager::loadPreset(const juce::File& file)
{
    if (!file.existsAsFile()) return false;
    auto jsonVar = juce::JSON::parse(file);
    if (!jsonVar.isObject()) return false;

    auto* root = jsonVar.getDynamicObject();

    if (auto* mics = root->getProperty("mics").getArray())
    {
        for (int i = 0; i < juce::jmin(2, mics->size()); ++i)
        {
            if (auto* micObj = mics->getReference(i).getDynamicObject())
            {
                audioEngine.setMicPreampGain(i, (float)micObj->getProperty("preampGain"));
                audioEngine.setMicMute(i, (bool)micObj->getProperty("mute"));
                audioEngine.setFxBypass(i, (bool)micObj->getProperty("fxBypass"));

                if (auto* eqObj = micObj->getProperty("eq").getDynamicObject())
                {
                    auto& eq = audioEngine.getEQProcessor(i);
                    eq.setLowFrequency((float)eqObj->getProperty("lowFreq"));
                    eq.setMidFrequency((float)eqObj->getProperty("midFreq"));
                    eq.setHighFrequency((float)eqObj->getProperty("highFreq"));
                    eq.setLowGain((float)eqObj->getProperty("lowGain"));
                    eq.setMidGain((float)eqObj->getProperty("midGain"));
                    eq.setHighGain((float)eqObj->getProperty("highGain"));
                    eq.setLowQ((float)eqObj->getProperty("lowQ"));
                    eq.setMidQ((float)eqObj->getProperty("midQ"));
                    eq.setHighQ((float)eqObj->getProperty("highQ"));
                    eq.setBypassed((bool)micObj->getProperty("eqBypass"));
                }

                auto& comp = audioEngine.getCompressorProcessor(i);
                comp.setParams(varToCompParams(micObj->getProperty("compressor")));
                comp.setBypassed((bool)micObj->getProperty("compBypass"));

                auto& exc = audioEngine.getExciterProcessor(i);
                if (micObj->hasProperty("exciter"))
                {
                    exc.setParams(varToExciterParams(micObj->getProperty("exciter")));
                    exc.setBypassed((bool)micObj->getProperty("excBypass"));
                }
            }
        }
    }

    auto& harm = audioEngine.getHarmonizerProcessor();
    harm.setParams(varToHarmonizerParams(root->getProperty("harmonizer")));
    harm.setBypassed((bool)root->getProperty("harmonizerBypass"));

    auto& verb = audioEngine.getReverbProcessor();
    verb.setParams(varToReverbParams(root->getProperty("reverb")));
    verb.setBypassed((bool)root->getProperty("reverbBypass"));

    auto& delay = audioEngine.getDelayProcessor();
    delay.setParams(varToDelayParams(root->getProperty("delay")));
    delay.setBypassed((bool)root->getProperty("delayBypass"));

    auto& dynEq = audioEngine.getDynamicEQProcessor();
    dynEq.setParams(varToDynEqParams(root->getProperty("dynamicEQ")));
    dynEq.setBypassed((bool)root->getProperty("dynEqBypass"));

    currentPresetName = file.getFileNameWithoutExtension();
    return true;
}

// ==============================================================================
// HELPERS
// ==============================================================================

juce::var PresetManager::eqParamsToVar(const EQProcessor::Params& params) { return {}; }

juce::var PresetManager::compParamsToVar(const CompressorProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("thresh", p.thresholdDb);
    obj->setProperty("ratio", p.ratio);
    obj->setProperty("attack", p.attackMs);
    obj->setProperty("release", p.releaseMs);
    obj->setProperty("makeup", p.makeupDb);
    return obj.get();
}

CompressorProcessor::Params PresetManager::varToCompParams(const juce::var& v)
{
    CompressorProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.thresholdDb = (float)obj->getProperty("thresh");
        p.ratio = (float)obj->getProperty("ratio");
        p.attackMs = (float)obj->getProperty("attack");
        p.releaseMs = (float)obj->getProperty("release");
        p.makeupDb = (float)obj->getProperty("makeup");
    }
    return p;
}

juce::var PresetManager::exciterParamsToVar(const ExciterProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("freq", p.frequency);
    obj->setProperty("drive", p.amount);
    obj->setProperty("mix", p.mix);
    return obj.get();
}

ExciterProcessor::Params PresetManager::varToExciterParams(const juce::var& v)
{
    ExciterProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.frequency = (float)obj->getProperty("freq");
        p.amount = (float)obj->getProperty("drive");
        p.mix = (float)obj->getProperty("mix");
    }
    return p;
}

juce::var PresetManager::reverbParamsToVar(const ReverbProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("wet", p.wetGain);
    obj->setProperty("loCut", p.lowCutHz);
    obj->setProperty("hiCut", p.highCutHz);
    obj->setProperty("irPath", p.irFilePath);
    return obj.get();
}

ReverbProcessor::Params PresetManager::varToReverbParams(const juce::var& v)
{
    ReverbProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.wetGain = (float)obj->getProperty("wet");
        p.lowCutHz = (float)obj->getProperty("loCut");
        p.highCutHz = (float)obj->getProperty("hiCut");
        p.irFilePath = obj->getProperty("irPath").toString();
    }
    return p;
}

juce::var PresetManager::delayParamsToVar(const DelayProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("time", p.delayMs);
    obj->setProperty("ratio", p.ratio);
    obj->setProperty("stage", p.stage);
    obj->setProperty("mix", p.mix);
    obj->setProperty("width", p.stereoWidth);
    obj->setProperty("loCut", p.lowCutHz);
    obj->setProperty("hiCut", p.highCutHz);
    return obj.get();
}

DelayProcessor::Params PresetManager::varToDelayParams(const juce::var& v)
{
    DelayProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.delayMs = (float)obj->getProperty("time");
        p.ratio = (float)obj->getProperty("ratio");
        p.stage = (float)obj->getProperty("stage");
        p.mix = (float)obj->getProperty("mix");
        p.stereoWidth = (float)obj->getProperty("width");
        p.lowCutHz = (float)obj->getProperty("loCut");
        p.highCutHz = (float)obj->getProperty("hiCut");
    }
    return p;
}

juce::var PresetManager::harmonizerParamsToVar(const HarmonizerProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("enabled", p.enabled);
    obj->setProperty("wet", p.wetDb);
    
    juce::DynamicObject::Ptr v1 = new juce::DynamicObject();
    v1->setProperty("on", p.voices[0].enabled);
    v1->setProperty("pitch", p.voices[0].fixedSemitones);
    v1->setProperty("gain", p.voices[0].gainDb);
    obj->setProperty("v1", v1.get());

    juce::DynamicObject::Ptr v2 = new juce::DynamicObject();
    v2->setProperty("on", p.voices[1].enabled);
    v2->setProperty("pitch", p.voices[1].fixedSemitones);
    v2->setProperty("gain", p.voices[1].gainDb);
    obj->setProperty("v2", v2.get());

    return obj.get();
}

HarmonizerProcessor::Params PresetManager::varToHarmonizerParams(const juce::var& v)
{
    HarmonizerProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.enabled = (bool)obj->getProperty("enabled");
        p.wetDb = (float)obj->getProperty("wet");
        
        if (auto* v1 = obj->getProperty("v1").getDynamicObject())
        {
            p.voices[0].enabled = (bool)v1->getProperty("on");
            p.voices[0].fixedSemitones = (float)v1->getProperty("pitch");
            p.voices[0].gainDb = (float)v1->getProperty("gain");
        }
        if (auto* v2 = obj->getProperty("v2").getDynamicObject())
        {
            p.voices[1].enabled = (bool)v2->getProperty("on");
            p.voices[1].fixedSemitones = (float)v2->getProperty("pitch");
            p.voices[1].gainDb = (float)v2->getProperty("gain");
        }
    }
    return p;
}

juce::var PresetManager::dynEqParamsToVar(const DynamicEQProcessor::Params& p)
{
    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
    obj->setProperty("freq", p.duckBandHz);
    obj->setProperty("q", p.q);
    obj->setProperty("shape", p.shape);
    obj->setProperty("thresh", p.threshold);
    obj->setProperty("ratio", p.ratio);
    obj->setProperty("att", p.attack);
    obj->setProperty("rel", p.release);
    return obj.get();
}

DynamicEQProcessor::Params PresetManager::varToDynEqParams(const juce::var& v)
{
    DynamicEQProcessor::Params p;
    if (auto* obj = v.getDynamicObject())
    {
        p.duckBandHz = (float)obj->getProperty("freq");
        p.q = (float)obj->getProperty("q");
        p.shape = (float)obj->getProperty("shape");
        p.threshold = (float)obj->getProperty("thresh");
        p.ratio = (float)obj->getProperty("ratio");
        p.attack = (float)obj->getProperty("att");
        p.release = (float)obj->getProperty("rel");
    }
    return p;
}



--------------------------------------------------------------------------------
File: src/PresetManager.h
Size: 1.44 KB
--------------------------------------------------------------------------------

// Ensuring it includes `AudioEngine.h` correctly.

#pragma once

#include <juce_core/juce_core.h>
#include "AudioEngine.h"

class PresetManager
{
public:
    PresetManager(AudioEngine& engine);
    ~PresetManager() = default;

    bool savePreset(const juce::File& file);
    bool loadPreset(const juce::File& file);
    void loadDefaultPreset();
    juce::String getCurrentPresetName() const;

private:
    AudioEngine& audioEngine;
    juce::String currentPresetName;

    juce::var eqParamsToVar(const EQProcessor::Params& params);
    
    juce::var compParamsToVar(const CompressorProcessor::Params& params);
    CompressorProcessor::Params varToCompParams(const juce::var& v);

    juce::var exciterParamsToVar(const ExciterProcessor::Params& params);
    ExciterProcessor::Params varToExciterParams(const juce::var& v);

    juce::var reverbParamsToVar(const ReverbProcessor::Params& params);
    ReverbProcessor::Params varToReverbParams(const juce::var& v);
    
    juce::var delayParamsToVar(const DelayProcessor::Params& params);
    DelayProcessor::Params varToDelayParams(const juce::var& v);

    juce::var harmonizerParamsToVar(const HarmonizerProcessor::Params& params);
    HarmonizerProcessor::Params varToHarmonizerParams(const juce::var& v);
    
    juce::var dynEqParamsToVar(const DynamicEQProcessor::Params& params);
    DynamicEQProcessor::Params varToDynEqParams(const juce::var& v);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PresetManager)
};



--------------------------------------------------------------------------------
File: src/RegistrationManager.cpp
Size: 7.75 KB
--------------------------------------------------------------------------------

#include "RegistrationManager.h"
#include "BinaryData.h" 
#include "AppLogger.h"
#include <string>
#include <vector>
#include <cmath>
#include <fstream> 

#if JUCE_WINDOWS
#include <windows.h>
#endif

void RegistrationManager::checkRegistration()
{
    juce::File licenseFile = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                             .getChildFile("OnStage").getChildFile("license.key");

    if (licenseFile.existsAsFile())
    {
        juce::String savedSerial = licenseFile.loadFileAsString().trim();
        if (savedSerial.isNotEmpty())
        {
            if (tryRegister(savedSerial))
            {
                isRegistered = true;
                return;
            }
        }
    }
    isRegistered = false;
}

bool RegistrationManager::tryRegister(const juce::String& serialInput)
{
    try {
        juce::String cleanInput = serialInput.trim();
        if (cleanInput.isEmpty() || !cleanInput.containsOnly("0123456789")) return false;

        long long inputNum = cleanInput.getLargeIntValue();
        long long expected = calculateExpectedSerial();
        
        LOG_INFO("Input Serial: " + cleanInput);

        if (expected != 0 && inputNum == expected)
        {
            juce::File appData = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory).getChildFile("OnStage");
            if (!appData.exists()) appData.createDirectory();
            
            juce::File licenseFile = appData.getChildFile("license.key");
            licenseFile.replaceWithText(cleanInput);
            
            isRegistered = true;
            return true;
        }
        
        return false;
    }
    catch (...) { 
        LOG_ERROR("Exception in tryRegister");
        return false; 
    }
}

juce::String RegistrationManager::getMachineIDString()
{
    return juce::String(getMachineIDNumber());
}

char RegistrationManager::noteToChar(int note)
{
    if (note >= 0 && note <= 9) return '0' + note;
    switch(note) {
        case 10: return 'a';
        case 11: return '+';
        case 12: return '-';
        case 13: return '*';
        case 14: return '(';
        case 15: return ')';
    }
    return 0; 
}

juce::String RegistrationManager::decodeMidiToString(const void* data, size_t size)
{
    if (size == 0 || data == nullptr) return "";

    try {
        juce::MemoryInputStream inputStream(data, size, false);
        juce::MidiFile midiFile;
        
        if (midiFile.readFrom(inputStream))
        {
            midiFile.convertTimestampTicksToSeconds(); 
            juce::String extractedString = "";
            for (int t = 0; t < midiFile.getNumTracks(); ++t)
            {
                const auto* seq = midiFile.getTrack(t);
                for (int i = 0; i < seq->getNumEvents(); ++i)
                {
                    auto& event = seq->getEventPointer(i)->message;
                    if (event.isNoteOn() && event.getChannel() == 16)
                    {
                        char c = noteToChar(event.getNoteNumber());
                        if (c != 0) extractedString += c;
                    }
                }
            }
            return extractedString;
        }
    }
    catch (...) { 
        LOG_ERROR("MIDI Decode Crashed"); 
    }
    
    return "";
}

long long RegistrationManager::calculateExpectedSerial()
{
    try {
        int machineId = getMachineIDNumber();
        juce::String formula = decodeMidiToString(BinaryData::license_mid, BinaryData::license_midSize);
        
        if (formula.isEmpty()) {
            LOG_ERROR("CRITICAL: Failed to decode formula from MIDI asset.");
            return 0;
        }

        juce::String finalExpr = formula.replace("a", juce::String(machineId));
        long long rawResult = evaluateFormula(finalExpr);
        return rawResult / 10;
    }
    catch (...) { 
        LOG_ERROR("Calculation Exception");
        return 0; 
    }
}

long long RegistrationManager::evaluateFormula(const juce::String& formula)
{
    try {
        std::string expr = formula.removeCharacters(" ").toStdString();
        if (expr.empty()) return 0;

        struct Parser {
            const char* str;
            char peek() { return *str; }
            char next() { return *str ? *str++ : 0; }

            long long parseExpression() {
                long long lhs = parseTerm();
                while (peek() == '+' || peek() == '-') {
                    char op = next();
                    long long rhs = parseTerm();
                    if (op == '+') lhs += rhs; else lhs -= rhs;
                }
                return lhs;
            }
            long long parseTerm() {
                long long lhs = parseFactor();
                while (peek() == '*') {
                    char op = next();
                    long long rhs = parseFactor();
                    if (op == '*') lhs *= rhs;
                }
                return lhs;
            }
            long long parseFactor() {
                if (peek() == '(') {
                    next(); 
                    long long val = parseExpression();
                    if (peek() == ')') next(); 
                    return val;
                }
                std::string numStr;
                while (isdigit(peek())) numStr += next();
                if (numStr.empty()) return 0;
                try { return std::stoll(numStr); } catch (...) { return 0; }
            }
        };
        Parser p { expr.c_str() };
        return p.parseExpression();
    }
    catch (...) { return 0; }
}

int RegistrationManager::getMachineIDNumber()
{
    juce::String hex = getSystemVolumeSerial();
    if (hex.length() < 5) hex = hex.paddedRight('0', 5);
    hex = hex.substring(0, 5);
    
    juce::String numericStr = "";
    for (int i = 0; i < hex.length(); ++i)
    {
        juce::juce_wchar c = hex[i];
        char val = '0';
        switch (c) {
            case 'A': val = '1'; break; case 'B': val = '2'; break; case 'C': val = '3'; break;
            case 'D': val = '4'; break; case 'E': val = '5'; break; case 'F': val = '6'; break;
            case 'G': val = '7'; break; case 'H': val = '8'; break; case 'I': val = '9'; break;
            case 'J': val = '0'; break; case 'K': val = '2'; break; case 'L': val = '3'; break;
            case 'M': val = '4'; break; case 'N': val = '5'; break; case 'O': val = '6'; break;
            case 'P': val = '7'; break; case '1': val = '8'; break; case '2': val = '9'; break; 
            case '3': val = '2'; break; case '4': val = '1'; break; case '5': val = '3'; break; 
            case '6': val = '4'; break; case '7': val = '5'; break; case '8': val = '6'; break; 
            case '9': val = '7'; break; case '0': val = '8'; break;
            case 'Q': val = '8'; break; case 'R': val = '9'; break; case 'S': val = '2'; break;
            case 'T': val = '1'; break; case 'U': val = '2'; break; case 'V': val = '3'; break;
            case 'W': val = '4'; break; case 'X': val = '5'; break; case 'Y': val = '6'; break;
            case 'Z': val = '7'; break; default: val = '0'; break;
        }
        numericStr += val;
    }
    if (numericStr.isEmpty()) return 12345;
    return numericStr.getIntValue();
}

juce::String RegistrationManager::getSystemVolumeSerial()
{
    #if JUCE_WINDOWS
        DWORD serialNum = 0;
        if (GetVolumeInformationW(L"C:\\", nullptr, 0, &serialNum, nullptr, nullptr, nullptr, 0))
        {
            return juce::String::toHexString((int)serialNum).toUpperCase();
        }
        return "00000";
    #elif JUCE_LINUX
        std::ifstream file("/etc/machine-id");
        if (file.is_open()) {
            std::string line;
            if (std::getline(file, line)) {
                return juce::String(line).substring(0, 8).toUpperCase();
            }
        }
        return "LINUX01";
    #else
        return "MAC0001"; 
    #endif
}



--------------------------------------------------------------------------------
File: src/RegistrationManager.h
Size: 1.12 KB
--------------------------------------------------------------------------------

// **Changes:** 1.  Cleaned up unnecessary inclusions. 2.  Added `decodeMidiToString` and `noteToChar` helpers. <!-- end list -->

#pragma once
#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>

class RegistrationManager
{
public:
    static RegistrationManager& getInstance() {
        static RegistrationManager instance;
        return instance;
    }

    // Main Check
    void checkRegistration();
    bool isProMode() const { return isRegistered; }

    // User Action
    bool tryRegister(const juce::String& serialInput);
    juce::String getMachineIDString(); 

private:
    RegistrationManager() = default;
    ~RegistrationManager() = default;
    bool isRegistered = false;
    
    // Core Logic
    long long calculateExpectedSerial();
    long long evaluateFormula(const juce::String& formula);
    
    // MIDI Steganography Helpers
    juce::String decodeMidiToString(const void* data, size_t size);
    char noteToChar(int note);

    // Hardware ID
    int getMachineIDNumber();
    juce::String getSystemVolumeSerial();

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(RegistrationManager)
};



--------------------------------------------------------------------------------
File: src/UI/CompressorPanel.h
Size: 6.02 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"
#include "EffectToggleButton.h"
#include "../AudioEngine.h"

class CompressorPanel : public juce::Component, private juce::Timer {
public:
    CompressorPanel(AudioEngine& engine, int micIndex, const juce::String& micName)
        : audioEngine(engine), micIdx(micIndex)
    {
        goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>();
        auto& c = audioEngine.getCompressorProcessor(micIdx); auto params = c.getParams();

        toggleButton = std::make_unique<EffectToggleButton>();
        int note = (micIdx == 0) ? 19 : 22; toggleButton->setMidiInfo("MIDI: Note " + juce::String(note));
        toggleButton->setToggleState(!c.isBypassed(), juce::dontSendNotification);
        toggleButton->onClick = [this]() { audioEngine.getCompressorProcessor(micIdx).setBypassed(!toggleButton->getToggleState()); };
        addAndMakeVisible(toggleButton.get());
        addAndMakeVisible(titleLabel);
        titleLabel.setText(micName + " - Compressor", juce::dontSendNotification);
        titleLabel.setFont(juce::Font(18.0f, juce::Font::bold));
        titleLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
        titleLabel.setJustificationType(juce::Justification::centredLeft);

        auto cS = [&](std::unique_ptr<VerticalSlider>& s, const juce::String& n, int cc, double min, double max, double val, const juce::String& suf) {
            s = std::make_unique<VerticalSlider>(); s->setLabelText(n); s->setMidiInfo("MIDI: CC " + juce::String(cc));
            s->setRange(min, max, (max-min)/200.0); s->setValue(val); s->setTextValueSuffix(suf);
            s->getSlider().setLookAndFeel(goldenLookAndFeel.get());
            s->getSlider().onValueChange = [this]() { updateCompressor(); };
            addAndMakeVisible(s.get());
        };
        int base = (micIdx == 0) ? 32 : 42;
        cS(thresholdSlider, "Threshold", base, -60.0, 0.0, params.thresholdDb, " dB");
        cS(ratioSlider, "Ratio", base+1, 1.0, 20.0, params.ratio, ":1");
        cS(attackSlider, "Attack", base+2, 0.1, 100.0, params.attackMs, " ms"); attackSlider->setSkewFactor(10.0);
        cS(releaseSlider, "Release", base+3, 10.0, 1000.0, params.releaseMs, " ms"); releaseSlider->setSkewFactor(100.0);
        cS(makeupSlider, "Makeup", base+4, 0.0, 24.0, params.makeupDb, " dB");

        startTimerHz(15);
    }
    ~CompressorPanel() override { stopTimer(); thresholdSlider->getSlider().setLookAndFeel(nullptr); ratioSlider->getSlider().setLookAndFeel(nullptr); attackSlider->getSlider().setLookAndFeel(nullptr); releaseSlider->getSlider().setLookAndFeel(nullptr); makeupSlider->getSlider().setLookAndFeel(nullptr); }
    void paint(juce::Graphics& g) override { g.fillAll(juce::Colour(0xFF1A1A1A)); g.setColour(juce::Colour(0xFF404040)); g.drawRect(getLocalBounds(), 2); g.setColour(juce::Colour(0xFF2A2A2A)); g.fillRect(getLocalBounds().reduced(10)); }
    
    void resized() override {
        auto area = getLocalBounds().reduced(15);
        auto titleRow = area.removeFromTop(40);
        toggleButton->setBounds(titleRow.removeFromRight(40).withSizeKeepingCentre(40, 40));
        titleLabel.setBounds(titleRow);
        area.removeFromTop(10);

        int numSliders = 5; int sliderWidth = 60; int spacing = 20;
        int totalW = (numSliders * sliderWidth) + ((numSliders - 1) * spacing);
        int startX = area.getX() + (area.getWidth() - totalW) / 2;
        auto sArea = area.withX(startX).withWidth(totalW);
        
        thresholdSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        ratioSlider->setBounds(sArea.removeFromLeft(sliderWidth));     sArea.removeFromLeft(spacing);
        attackSlider->setBounds(sArea.removeFromLeft(sliderWidth));    sArea.removeFromLeft(spacing);
        releaseSlider->setBounds(sArea.removeFromLeft(sliderWidth));   sArea.removeFromLeft(spacing);
        makeupSlider->setBounds(sArea.removeFromLeft(sliderWidth));
    }
    void updateFromPreset() { auto& c = audioEngine.getCompressorProcessor(micIdx); auto p = c.getParams(); thresholdSlider->setValue(p.thresholdDb, juce::dontSendNotification); ratioSlider->setValue(p.ratio, juce::dontSendNotification); attackSlider->setValue(p.attackMs, juce::dontSendNotification); releaseSlider->setValue(p.releaseMs, juce::dontSendNotification); makeupSlider->setValue(p.makeupDb, juce::dontSendNotification); toggleButton->setToggleState(!c.isBypassed(), juce::dontSendNotification); repaint(); }
private:
    void timerCallback() override { auto& c = audioEngine.getCompressorProcessor(micIdx); auto p = c.getParams();
        if (!thresholdSlider->getSlider().isMouseOverOrDragging()) thresholdSlider->setValue(p.thresholdDb, juce::dontSendNotification);
        if (!ratioSlider->getSlider().isMouseOverOrDragging()) ratioSlider->setValue(p.ratio, juce::dontSendNotification);
        if (!attackSlider->getSlider().isMouseOverOrDragging()) attackSlider->setValue(p.attackMs, juce::dontSendNotification);
        if (!releaseSlider->getSlider().isMouseOverOrDragging()) releaseSlider->setValue(p.releaseMs, juce::dontSendNotification);
        if (!makeupSlider->getSlider().isMouseOverOrDragging()) makeupSlider->setValue(p.makeupDb, juce::dontSendNotification);
        bool shouldBeOn = !c.isBypassed(); if (toggleButton->getToggleState() != shouldBeOn) toggleButton->setToggleState(shouldBeOn, juce::dontSendNotification);
    }
    AudioEngine& audioEngine; int micIdx;
    std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel; std::unique_ptr<EffectToggleButton> toggleButton; juce::Label titleLabel;
    std::unique_ptr<VerticalSlider> thresholdSlider, ratioSlider, attackSlider, releaseSlider, makeupSlider;
    void updateCompressor() { CompressorProcessor::Params p; p.thresholdDb = thresholdSlider->getValue(); p.ratio = ratioSlider->getValue(); p.attackMs = attackSlider->getValue(); p.releaseMs = releaseSlider->getValue(); p.makeupDb = makeupSlider->getValue(); audioEngine.getCompressorProcessor(micIdx).setParams(p); }
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CompressorPanel)
};



--------------------------------------------------------------------------------
File: src/UI/DebugConsole.h
Size: 3.02 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

class DebugConsole : public juce::Component,
                     public juce::Logger
{
public:
    DebugConsole()
    {
        addAndMakeVisible(clearButton);
        clearButton.setButtonText("Clear");
        clearButton.onClick = [this]() { clearLog(); };
        
        addAndMakeVisible(logText);
        logText.setMultiLine(true);
        logText.setReadOnly(true);
        logText.setCaretVisible(false);
        logText.setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xFF1A1A1A));
        logText.setColour(juce::TextEditor::textColourId, juce::Colours::white);
        logText.setColour(juce::TextEditor::highlightColourId, juce::Colour(0xFFD4AF37));
        logText.setFont(juce::Font(juce::Font::getDefaultMonospacedFontName(), 12.0f, juce::Font::plain));
        
        // Set this as the global logger
        juce::Logger::setCurrentLogger(this);
        
        juce::Logger::writeToLog("=== Debug Console Initialized ===");
    }
    
    ~DebugConsole() override
    {
        // Remove as logger before destruction
        if (juce::Logger::getCurrentLogger() == this)
            juce::Logger::setCurrentLogger(nullptr);
    }
    
    void resized() override
    {
        auto area = getLocalBounds();
        auto buttonArea = area.removeFromTop(30);
        clearButton.setBounds(buttonArea.removeFromRight(80).reduced(5));
        logText.setBounds(area);
    }
    
    void logMessage(const juce::String& message) override
    {
        // THREAD SAFE: Use weak reference to avoid accessing deleted component
        juce::Component::SafePointer<DebugConsole> safeThis(this);
        
        juce::MessageManager::callAsync([safeThis, msg = juce::String(message)]() {
            // Check if component still exists
            if (safeThis == nullptr)
                return;
                
            juce::String timestamp = juce::Time::getCurrentTime().formatted("%H:%M:%S.%ms");
            juce::String formattedMessage = "[" + timestamp + "] " + msg + "\n";
            
            // Append text
            safeThis->logText.moveCaretToEnd();
            safeThis->logText.insertTextAtCaret(formattedMessage);
            
            // Auto-scroll to bottom
            safeThis->logText.moveCaretToEnd();
            
            // Limit log size to prevent memory issues (keep last 10000 chars)
            if (safeThis->logText.getTotalNumChars() > 10000)
            {
                safeThis->logText.setCaretPosition(0);
                safeThis->logText.setHighlightedRegion(juce::Range<int>(0, safeThis->logText.getTotalNumChars() - 8000));
                safeThis->logText.insertTextAtCaret("");
                safeThis->logText.moveCaretToEnd();
            }
        });
    }
    
    void clearLog()
    {
        logText.clear();
        juce::Logger::writeToLog("=== Debug Console Cleared ===");
    }
    
private:
    juce::TextButton clearButton;
    juce::TextEditor logText;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DebugConsole)
};




--------------------------------------------------------------------------------
File: src/UI/DelayPanel.h
Size: 6.40 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"
#include "EffectToggleButton.h"
#include "../dsp/DelayProcessor.h"

class DelayPanel : public juce::Component, private juce::Timer {
public:
    DelayPanel(DelayProcessor& processor) : delayProcessor(processor) {
        goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>(); auto params = delayProcessor.getParams();
        toggleButton = std::make_unique<EffectToggleButton>(); toggleButton->setMidiInfo("MIDI: Note 27");
        toggleButton->setToggleState(!delayProcessor.isBypassed(), juce::dontSendNotification);
        toggleButton->onClick = [this]() { delayProcessor.setBypassed(!toggleButton->getToggleState()); };
        addAndMakeVisible(toggleButton.get());
        addAndMakeVisible(titleLabel); titleLabel.setText("Stereo Delay", juce::dontSendNotification);
        titleLabel.setFont(juce::Font(18.0f, juce::Font::bold)); titleLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37)); titleLabel.setJustificationType(juce::Justification::centredLeft);
        auto cS = [&](std::unique_ptr<VerticalSlider>& s, const juce::String& n, const juce::String& m, double min, double max, double v, const juce::String& suf) {
            s = std::make_unique<VerticalSlider>(); s->setLabelText(n); s->setMidiInfo(m);
            s->setRange(min, max, (max-min)/200.0); s->setValue(v); s->setTextValueSuffix(suf);
            s->getSlider().setLookAndFeel(goldenLookAndFeel.get()); s->getSlider().onValueChange = [this]() { updateDelay(); };
            addAndMakeVisible(s.get());
        };
        cS(delayTimeSlider, "Time", "MIDI: CC 47", 1.0, 2000.0, params.delayMs, " ms");
        cS(ratioSlider, "Ratio", "MIDI: CC 48", 0.0, 1.0, params.ratio, "");
        cS(stageSlider, "Stage", "MIDI: CC 49", 0.0, 1.0, params.stage, "");
        cS(mixSlider, "Mix", "MIDI: CC 29", 0.0, 1.0, params.mix, "");
        cS(widthSlider, "Width", "MIDI: CC 50", 0.0, 2.0, params.stereoWidth, "");
        cS(lowCutSlider, "LowCut", "MIDI: CC 51", 20.0, 2000.0, params.lowCutHz, " Hz");
        cS(highCutSlider, "HighCut", "MIDI: CC 52", 2000.0, 20000.0, params.highCutHz, " Hz");
        startTimerHz(15);
    }
    ~DelayPanel() override { stopTimer(); delayTimeSlider->getSlider().setLookAndFeel(nullptr); ratioSlider->getSlider().setLookAndFeel(nullptr); stageSlider->getSlider().setLookAndFeel(nullptr); mixSlider->getSlider().setLookAndFeel(nullptr); widthSlider->getSlider().setLookAndFeel(nullptr); lowCutSlider->getSlider().setLookAndFeel(nullptr); highCutSlider->getSlider().setLookAndFeel(nullptr); }
    void paint(juce::Graphics& g) override { g.fillAll(juce::Colour(0xFF1A1A1A)); g.setColour(juce::Colour(0xFF404040)); g.drawRect(getLocalBounds(), 2); g.setColour(juce::Colour(0xFF2A2A2A)); g.fillRect(getLocalBounds().reduced(10)); }
    void resized() override {
        auto area = getLocalBounds().reduced(15);
        auto titleRow = area.removeFromTop(40);
        toggleButton->setBounds(titleRow.removeFromRight(40).withSizeKeepingCentre(40, 40));
        titleLabel.setBounds(titleRow);
        area.removeFromTop(10);
        int numSliders = 7; int sliderWidth = 60; int spacing = 20; 
        int totalW = (numSliders * sliderWidth) + ((numSliders - 1) * spacing);
        int startX = area.getX() + (area.getWidth() - totalW) / 2;
        auto sArea = area.withX(startX).withWidth(totalW);
        delayTimeSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        ratioSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        stageSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        mixSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        widthSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        lowCutSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        highCutSlider->setBounds(sArea.removeFromLeft(sliderWidth));
    }
    void updateFromPreset() { auto params = delayProcessor.getParams(); toggleButton->setToggleState(!delayProcessor.isBypassed(), juce::dontSendNotification); delayTimeSlider->setValue(params.delayMs, juce::dontSendNotification); ratioSlider->setValue(params.ratio, juce::dontSendNotification); stageSlider->setValue(params.stage, juce::dontSendNotification); mixSlider->setValue(params.mix, juce::dontSendNotification); widthSlider->setValue(params.stereoWidth, juce::dontSendNotification); lowCutSlider->setValue(params.lowCutHz, juce::dontSendNotification); highCutSlider->setValue(params.highCutHz, juce::dontSendNotification); }
private:
    void timerCallback() override { auto params = delayProcessor.getParams(); if (!delayTimeSlider->getSlider().isMouseOverOrDragging()) delayTimeSlider->setValue(params.delayMs, juce::dontSendNotification); if (!ratioSlider->getSlider().isMouseOverOrDragging()) ratioSlider->setValue(params.ratio, juce::dontSendNotification); if (!stageSlider->getSlider().isMouseOverOrDragging()) stageSlider->setValue(params.stage, juce::dontSendNotification); if (!mixSlider->getSlider().isMouseOverOrDragging()) mixSlider->setValue(params.mix, juce::dontSendNotification); if (!widthSlider->getSlider().isMouseOverOrDragging()) widthSlider->setValue(params.stereoWidth, juce::dontSendNotification); if (!lowCutSlider->getSlider().isMouseOverOrDragging()) lowCutSlider->setValue(params.lowCutHz, juce::dontSendNotification); if (!highCutSlider->getSlider().isMouseOverOrDragging()) highCutSlider->setValue(params.highCutHz, juce::dontSendNotification); bool shouldBeOn = !delayProcessor.isBypassed(); if (toggleButton->getToggleState() != shouldBeOn) toggleButton->setToggleState(shouldBeOn, juce::dontSendNotification); }
    DelayProcessor& delayProcessor; std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel; std::unique_ptr<EffectToggleButton> toggleButton; juce::Label titleLabel; std::unique_ptr<VerticalSlider> delayTimeSlider, ratioSlider, stageSlider, mixSlider, widthSlider, lowCutSlider, highCutSlider;
    void updateDelay() { DelayProcessor::Params p; p.delayMs = delayTimeSlider->getValue(); p.ratio = ratioSlider->getValue(); p.stage = stageSlider->getValue(); p.mix = mixSlider->getValue(); p.stereoWidth = widthSlider->getValue(); p.lowCutHz = lowCutSlider->getValue(); p.highCutHz = highCutSlider->getValue(); delayProcessor.setParams(p); }
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DelayPanel)
};



--------------------------------------------------------------------------------
File: src/UI/DualHandleSlider.h
Size: 4.93 KB
--------------------------------------------------------------------------------

// **Changes:** The text drawing logic was already there, but I've slightly adjusted the Y offset to ensure it doesn't get clipped and uses a distinct font.

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"

class DualHandleSlider : public juce::Component
{
public:
    DualHandleSlider() { setInterceptsMouseClicks(true, false); }
    
    void setRange(double minimum, double maximum) { minValue = minimum; maxValue = maximum; }
    void setLeftValue(double value) { 
        leftValue = juce::jlimit(minValue, maxValue, value);
        if (leftValue > rightValue - 100.0) leftValue = rightValue - 100.0; 
        repaint();
    }
    void setRightValue(double value) { 
        rightValue = juce::jlimit(minValue, maxValue, value);
        if (rightValue < leftValue + 100.0) rightValue = leftValue + 100.0; 
        repaint();
    }
    double getLeftValue() const { return leftValue; }
    double getRightValue() const { return rightValue; }
    
    void setLeftMidiInfo(const juce::String& info) { leftMidiInfo = info; }
    void setRightMidiInfo(const juce::String& info) { rightMidiInfo = info; }
    
    std::function<void()> onLeftValueChange;
    std::function<void()> onRightValueChange;
    bool isUserDragging() const { return isMouseOverOrDragging() && isMouseButtonDown(); }

    void paint(juce::Graphics& g) override
    {
        auto bounds = getLocalBounds().toFloat();
        float trackY = bounds.getCentreY() - 10; // Shift track up slightly to make room for text
        float trackHeight = 6.0f;
        
        g.setColour(juce::Colour(0xFF202020));
        g.fillRoundedRectangle(bounds.getX(), trackY - trackHeight/2, bounds.getWidth(), trackHeight, trackHeight/2);
        
        float leftPos = valueToPosition(leftValue);
        float rightPos = valueToPosition(rightValue);
        
        g.setColour(juce::Colour(0xFF4A90E2));
        g.fillRoundedRectangle(bounds.getX(), trackY - trackHeight/2, leftPos - bounds.getX(), trackHeight, trackHeight/2);
        g.setColour(juce::Colour(0xFF7ED321));
        g.fillRoundedRectangle(leftPos, trackY - trackHeight/2, rightPos - leftPos, trackHeight, trackHeight/2);
        g.setColour(juce::Colour(0xFFD0021B));
        g.fillRoundedRectangle(rightPos, trackY - trackHeight/2, bounds.getRight() - rightPos, trackHeight, trackHeight/2);
        
        drawHandle(g, leftPos, trackY, true);
        drawHandle(g, rightPos, trackY, false);
        
        // FIX: Ensure text is distinct
        g.setColour(juce::Colours::white);
        g.setFont(14.0f);
        // Position text clearly below handles
        g.drawText(formatFrequency(leftValue), (int)(leftPos - 30), (int)(trackY + 20), 60, 20, juce::Justification::centred);
        g.drawText(formatFrequency(rightValue), (int)(rightPos - 30), (int)(trackY + 20), 60, 20, juce::Justification::centred);
    }
    
    void mouseDown(const juce::MouseEvent& e) override
    {
        float clickX = (float)e.getPosition().getX();
        float leftPos = valueToPosition(leftValue);
        float rightPos = valueToPosition(rightValue);
        draggingLeft = (std::abs(clickX - leftPos) < std::abs(clickX - rightPos));
        if (e.mods.isRightButtonDown()) {
            if (draggingLeft && !leftMidiInfo.isEmpty()) showMidiTooltip(this, leftMidiInfo);
            else if (!draggingLeft && !rightMidiInfo.isEmpty()) showMidiTooltip(this, rightMidiInfo);
            return;
        }
        mouseDrag(e);
    }
    
    void mouseDrag(const juce::MouseEvent& e) override
    {
        if (e.mods.isRightButtonDown()) return;
        float val = positionToValue((float)e.getPosition().getX());
        if (draggingLeft) { setLeftValue(val); if (onLeftValueChange) onLeftValueChange(); }
        else { setRightValue(val); if (onRightValueChange) onRightValueChange(); }
    }
    
private:
    double minValue = 20.0, maxValue = 20000.0, leftValue = 300.0, rightValue = 3000.0;
    bool draggingLeft = false;
    juce::String leftMidiInfo, rightMidiInfo;
    
    void drawHandle(juce::Graphics& g, float x, float y, bool isLeft)
    {
        g.setColour(juce::Colours::black);
        g.fillEllipse(x - 18, y - 18, 36, 36);
        g.setColour(juce::Colour(0xFFD4AF37)); g.fillEllipse(x - 10.8f, y - 10.8f, 21.6f, 21.6f);
    }
    
    float valueToPosition(double value) const {
        double p = (value - minValue) / (maxValue - minValue);
        p = std::log(1.0 + p * 9.0) / std::log(10.0);
        return getLocalBounds().getX() + (float)p * getLocalBounds().getWidth();
    }
    double positionToValue(float position) const {
        float p = (position - getLocalBounds().getX()) / getLocalBounds().getWidth();
        return minValue + ((std::pow(10.0, juce::jlimit(0.0f, 1.0f, p)) - 1.0) / 9.0) * (maxValue - minValue);
    }
    juce::String formatFrequency(double f) const { return f >= 1000.0 ?
        juce::String(f/1000.0, 1) + " kHz" : juce::String((int)f) + " Hz"; }
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DualHandleSlider)
};



--------------------------------------------------------------------------------
File: src/UI/DynamicEQPanel.h
Size: 6.45 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"
#include "EffectToggleButton.h"
#include "../AudioEngine.h"

class DynamicEQPanel : public juce::Component, private juce::Timer {
public:
    DynamicEQPanel(AudioEngine& engine) : audioEngine(engine) {
        goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>(); auto& d = audioEngine.getDynamicEQProcessor(); auto params = d.getParams();
        toggleButton = std::make_unique<EffectToggleButton>(); toggleButton->setMidiInfo("MIDI: Note 28");
        toggleButton->setToggleState(!d.isBypassed(), juce::dontSendNotification);
        toggleButton->onClick = [this]() { audioEngine.getDynamicEQProcessor().setBypassed(!toggleButton->getToggleState()); };
        addAndMakeVisible(toggleButton.get());
        addAndMakeVisible(titleLabel); titleLabel.setText("Sidechain Compressor", juce::dontSendNotification);
        titleLabel.setFont(juce::Font(18.0f, juce::Font::bold)); titleLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37)); titleLabel.setJustificationType(juce::Justification::centredLeft);
        auto cS = [&](std::unique_ptr<VerticalSlider>& s, const juce::String& n, const juce::String& m, double min, double max, double v, const juce::String& suf) {
            s = std::make_unique<VerticalSlider>(); s->setLabelText(n); s->setMidiInfo(m);
            s->setRange(min, max, (max-min)/100.0); s->setValue(v); s->setTextValueSuffix(suf);
            s->getSlider().setLookAndFeel(goldenLookAndFeel.get()); s->getSlider().onValueChange = [this]() { updateDynamicEQ(); };
            addAndMakeVisible(s.get());
        };
        cS(duckBandSlider, "Duck Band", "MIDI: CC 59", 100.0, 8000.0, params.duckBandHz, " Hz");
        cS(qSlider, "Q", "MIDI: CC 60", 0.1, 10.0, params.q, "");
        cS(shapeSlider, "Shape", "MIDI: CC 61", 0.0, 1.0, params.shape, "");
        cS(thresholdSlider, "Threshold", "MIDI: CC 62", -60.0, 0.0, params.threshold, " dB");
        cS(ratioSlider, "Ratio", "MIDI: CC 65", 1.0, 20.0, params.ratio, ":1");
        cS(attackSlider, "Attack", "MIDI: CC 66", 0.1, 100.0, params.attack, " ms");
        cS(releaseSlider, "Release", "MIDI: CC 67", 10.0, 1000.0, params.release, " ms");
        startTimerHz(15);
    }
    ~DynamicEQPanel() override { stopTimer(); duckBandSlider->getSlider().setLookAndFeel(nullptr); qSlider->getSlider().setLookAndFeel(nullptr); shapeSlider->getSlider().setLookAndFeel(nullptr); thresholdSlider->getSlider().setLookAndFeel(nullptr); ratioSlider->getSlider().setLookAndFeel(nullptr); attackSlider->getSlider().setLookAndFeel(nullptr); releaseSlider->getSlider().setLookAndFeel(nullptr); }
    void paint(juce::Graphics& g) override { g.fillAll(juce::Colour(0xFF1A1A1A)); g.setColour(juce::Colour(0xFF404040)); g.drawRect(getLocalBounds(), 2); g.setColour(juce::Colour(0xFF2A2A2A)); g.fillRect(getLocalBounds().reduced(10)); }
    void resized() override {
        auto area = getLocalBounds().reduced(15);
        auto topRow = area.removeFromTop(40);
        toggleButton->setBounds(topRow.removeFromRight(40).withSizeKeepingCentre(40, 40));
        titleLabel.setBounds(topRow);
        area.removeFromTop(10);
        int numSliders = 7; int sliderWidth = 60; int spacing = 20; 
        int totalW = (numSliders * sliderWidth) + ((numSliders - 1) * spacing);
        int startX = area.getX() + (area.getWidth() - totalW) / 2;
        auto sArea = area.withX(startX).withWidth(totalW);
        duckBandSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        qSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        shapeSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        thresholdSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        ratioSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        attackSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        releaseSlider->setBounds(sArea.removeFromLeft(sliderWidth));
    }
    void updateFromPreset() { auto& d = audioEngine.getDynamicEQProcessor(); auto p = d.getParams(); toggleButton->setToggleState(!d.isBypassed(), juce::dontSendNotification); duckBandSlider->setValue(p.duckBandHz, juce::dontSendNotification); qSlider->setValue(p.q, juce::dontSendNotification); shapeSlider->setValue(p.shape, juce::dontSendNotification); thresholdSlider->setValue(p.threshold, juce::dontSendNotification); ratioSlider->setValue(p.ratio, juce::dontSendNotification); attackSlider->setValue(p.attack, juce::dontSendNotification); releaseSlider->setValue(p.release, juce::dontSendNotification); }
private:
    void timerCallback() override { auto p = audioEngine.getDynamicEQProcessor().getParams(); if (!duckBandSlider->getSlider().isMouseOverOrDragging()) duckBandSlider->setValue(p.duckBandHz, juce::dontSendNotification); if (!qSlider->getSlider().isMouseOverOrDragging()) qSlider->setValue(p.q, juce::dontSendNotification); if (!shapeSlider->getSlider().isMouseOverOrDragging()) shapeSlider->setValue(p.shape, juce::dontSendNotification); if (!thresholdSlider->getSlider().isMouseOverOrDragging()) thresholdSlider->setValue(p.threshold, juce::dontSendNotification); if (!ratioSlider->getSlider().isMouseOverOrDragging()) ratioSlider->setValue(p.ratio, juce::dontSendNotification); if (!attackSlider->getSlider().isMouseOverOrDragging()) attackSlider->setValue(p.attack, juce::dontSendNotification); if (!releaseSlider->getSlider().isMouseOverOrDragging()) releaseSlider->setValue(p.release, juce::dontSendNotification); bool shouldBeOn = !audioEngine.getDynamicEQProcessor().isBypassed(); if (toggleButton->getToggleState() != shouldBeOn) toggleButton->setToggleState(shouldBeOn, juce::dontSendNotification); }
    AudioEngine& audioEngine; std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel; std::unique_ptr<EffectToggleButton> toggleButton; juce::Label titleLabel; std::unique_ptr<VerticalSlider> duckBandSlider, qSlider, shapeSlider, thresholdSlider, ratioSlider, attackSlider, releaseSlider;
    void updateDynamicEQ() { DynamicEQProcessor::Params p; p.duckBandHz = duckBandSlider->getValue(); p.q = qSlider->getValue(); p.shape = shapeSlider->getValue(); p.threshold = thresholdSlider->getValue(); p.ratio = ratioSlider->getValue(); p.attack = attackSlider->getValue(); p.release = releaseSlider->getValue(); audioEngine.getDynamicEQProcessor().setParams(p); }
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DynamicEQPanel)
};



--------------------------------------------------------------------------------
File: src/UI/EffectToggleButton.h
Size: 2.31 KB
--------------------------------------------------------------------------------

// **Changes:** 1.  **Right-Click:** `mouseDown` checks right-click, shows tooltip, and **returns immediately**. `mouseUp` also blocks right-click to prevent toggle logic. 2.  **Visuals:** `paintButton` now uses `0xFFD4AF37` (Gold) background with **Black** text when ON. <!-- end list -->

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h" 

class EffectToggleButton : public juce::ToggleButton
{
public:
    EffectToggleButton()
    {
        setButtonText("");
        setToggleState(true, juce::dontSendNotification);
    }
    
    void setMidiInfo(const juce::String& info) { midiInfo = info; }

    void mouseDown(const juce::MouseEvent& e) override
    {
        if (e.mods.isRightButtonDown())
        {
            if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo);
            return; // STRICT BLOCK: Do not call base class
        }
        juce::ToggleButton::mouseDown(e);
    }

    void mouseUp(const juce::MouseEvent& e) override
    {
        if (e.mods.isRightButtonDown())
        {
            return; // STRICT BLOCK
        }
        juce::ToggleButton::mouseUp(e);
    }

    void mouseDrag(const juce::MouseEvent& e) override
    {
        if (e.mods.isRightButtonDown()) return;
        juce::ToggleButton::mouseDrag(e);
    }
    
    void paintButton(juce::Graphics& g, bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override
    {
        auto bounds = getLocalBounds().toFloat();
        float size = juce::jmin(bounds.getWidth(), bounds.getHeight());
        auto squareBounds = bounds.withSizeKeepingCentre(size, size);
        
        bool isOn = getToggleState();
        
        // FIX: ON = Gold Background, OFF = Dark Grey
        g.setColour(isOn ? juce::Colour(0xFFD4AF37) : juce::Colour(0xFF404040));
        g.fillRoundedRectangle(squareBounds, 3.0f);
        
        // Border
        g.setColour(juce::Colours::black);
        g.drawRoundedRectangle(squareBounds, 3.0f, 2.0f);
        
        // FIX: ON = Black Text, OFF = White Text
        g.setColour(isOn ? juce::Colours::black : juce::Colours::white);
        g.setFont(juce::Font(size * 0.35f, juce::Font::bold));
        g.drawText("ON", squareBounds, juce::Justification::centred);
    }
    
private:
    juce::String midiInfo;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(EffectToggleButton)
};



--------------------------------------------------------------------------------
File: src/UI/EQPanel.h
Size: 7.84 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"
#include "DualHandleSlider.h"
#include "EffectToggleButton.h"
#include "../dsp/EQProcessor.h"

class EQPanel : public juce::Component, private juce::Timer {
public:
    EQPanel(EQProcessor& processor, int micIdx, const juce::String& micName);
    ~EQPanel() override;
    void paint(juce::Graphics& g) override; void resized() override; void updateFromPreset();
private:
    void timerCallback() override;
    EQProcessor& eqProcessor; int micIndex; std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel;
    std::unique_ptr<EffectToggleButton> toggleButton; std::unique_ptr<VerticalSlider> lowGainSlider, midGainSlider, highGainSlider, lowQSlider, midQSlider, highQSlider;
    std::unique_ptr<DualHandleSlider> frequencySelector; juce::Label titleLabel, lowLabel, midLabel, highLabel;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(EQPanel)
};

inline EQPanel::EQPanel(EQProcessor& processor, int micIdx, const juce::String& micName) : eqProcessor(processor), micIndex(micIdx) {
    goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>();
    toggleButton = std::make_unique<EffectToggleButton>(); int note = (micIndex == 0) ? 18 : 21; toggleButton->setMidiInfo("MIDI: Note " + juce::String(note));
    addAndMakeVisible(toggleButton.get()); toggleButton->setToggleState(!eqProcessor.isBypassed(), juce::dontSendNotification);
    toggleButton->onClick = [this]() { eqProcessor.setBypassed(!toggleButton->getToggleState()); };
    int baseCC = (micIndex == 0) ? 70 : 80;
    auto cS = [&](std::unique_ptr<VerticalSlider>& s, const juce::String& n, int cc, double min, double max, double v, const juce::String& suf) {
        s = std::make_unique<VerticalSlider>(); s->setLabelText(n); s->setMidiInfo("MIDI: CC " + juce::String(cc));
        s->setRange(min, max, (max-min)/200.0); s->setValue(v); s->setTextValueSuffix(suf); s->getSlider().setLookAndFeel(goldenLookAndFeel.get()); addAndMakeVisible(s.get());
    };
    cS(lowGainSlider, "Low Gain", baseCC, -12.0, 12.0, eqProcessor.getLowGain(), " dB"); lowGainSlider->getSlider().onValueChange = [this]() { eqProcessor.setLowGain(lowGainSlider->getValue()); };
    cS(lowQSlider, "Low Q", baseCC+1, 0.1, 10.0, eqProcessor.getLowQ(), ""); lowQSlider->getSlider().onValueChange = [this]() { eqProcessor.setLowQ(lowQSlider->getValue()); };
    cS(midGainSlider, "Mid Gain", baseCC+2, -12.0, 12.0, eqProcessor.getMidGain(), " dB"); midGainSlider->getSlider().onValueChange = [this]() { eqProcessor.setMidGain(midGainSlider->getValue()); };
    cS(midQSlider, "Mid Q", baseCC+3, 0.1, 10.0, eqProcessor.getMidQ(), ""); midQSlider->getSlider().onValueChange = [this]() { eqProcessor.setMidQ(midQSlider->getValue()); };
    cS(highGainSlider, "High Gain", baseCC+4, -12.0, 12.0, eqProcessor.getHighGain(), " dB"); highGainSlider->getSlider().onValueChange = [this]() { eqProcessor.setHighGain(highGainSlider->getValue()); };
    cS(highQSlider, "High Q", baseCC+5, 0.1, 10.0, eqProcessor.getHighQ(), ""); highQSlider->getSlider().onValueChange = [this]() { eqProcessor.setHighQ(highQSlider->getValue()); };
    frequencySelector = std::make_unique<DualHandleSlider>(); frequencySelector->setRange(20.0, 20000.0); frequencySelector->setLeftValue(eqProcessor.getLowFrequency()); frequencySelector->setRightValue(eqProcessor.getHighFrequency());
    addAndMakeVisible(frequencySelector.get()); frequencySelector->onLeftValueChange = [this]() { eqProcessor.setLowFrequency(frequencySelector->getLeftValue()); }; frequencySelector->onRightValueChange = [this]() { eqProcessor.setHighFrequency(frequencySelector->getRightValue()); };
    frequencySelector->setLeftMidiInfo("MIDI: CC " + juce::String((micIndex == 0) ? 68 : 78)); frequencySelector->setRightMidiInfo("MIDI: CC " + juce::String((micIndex == 0) ? 69 : 79));
    titleLabel.setText(micName + " - 3-Band EQ", juce::dontSendNotification); titleLabel.setFont(juce::Font(18.0f, juce::Font::bold)); addAndMakeVisible(titleLabel);
    auto setupL = [&](juce::Label& l, const juce::String& t) { l.setText(t, juce::dontSendNotification); l.setJustificationType(juce::Justification::centred); addAndMakeVisible(l); };
    setupL(lowLabel, "Low"); setupL(midLabel, "Mid"); setupL(highLabel, "High");
    startTimerHz(15);
}
inline EQPanel::~EQPanel() { stopTimer(); lowGainSlider->getSlider().setLookAndFeel(nullptr); lowQSlider->getSlider().setLookAndFeel(nullptr); midGainSlider->getSlider().setLookAndFeel(nullptr); midQSlider->getSlider().setLookAndFeel(nullptr); highGainSlider->getSlider().setLookAndFeel(nullptr); highQSlider->getSlider().setLookAndFeel(nullptr); }
inline void EQPanel::timerCallback() {
    if (!lowGainSlider->getSlider().isMouseOverOrDragging()) lowGainSlider->setValue(eqProcessor.getLowGain(), juce::dontSendNotification);
    if (!lowQSlider->getSlider().isMouseOverOrDragging()) lowQSlider->setValue(eqProcessor.getLowQ(), juce::dontSendNotification);
    if (!midGainSlider->getSlider().isMouseOverOrDragging()) midGainSlider->setValue(eqProcessor.getMidGain(), juce::dontSendNotification);
    if (!midQSlider->getSlider().isMouseOverOrDragging()) midQSlider->setValue(eqProcessor.getMidQ(), juce::dontSendNotification);
    if (!highGainSlider->getSlider().isMouseOverOrDragging()) highGainSlider->setValue(eqProcessor.getHighGain(), juce::dontSendNotification);
    if (!highQSlider->getSlider().isMouseOverOrDragging()) highQSlider->setValue(eqProcessor.getHighQ(), juce::dontSendNotification);
    if (!frequencySelector->isUserDragging()) { frequencySelector->setLeftValue(eqProcessor.getLowFrequency()); frequencySelector->setRightValue(eqProcessor.getHighFrequency()); }
    bool shouldBeOn = !eqProcessor.isBypassed(); if (toggleButton->getToggleState() != shouldBeOn) toggleButton->setToggleState(shouldBeOn, juce::dontSendNotification);
}
inline void EQPanel::updateFromPreset() {
    lowGainSlider->setValue(eqProcessor.getLowGain(), juce::dontSendNotification); lowQSlider->setValue(eqProcessor.getLowQ(), juce::dontSendNotification); midGainSlider->setValue(eqProcessor.getMidGain(), juce::dontSendNotification); midQSlider->setValue(eqProcessor.getMidQ(), juce::dontSendNotification); highGainSlider->setValue(eqProcessor.getHighGain(), juce::dontSendNotification); highQSlider->setValue(eqProcessor.getHighQ(), juce::dontSendNotification); frequencySelector->setLeftValue(eqProcessor.getLowFrequency()); frequencySelector->setRightValue(eqProcessor.getHighFrequency()); toggleButton->setToggleState(!eqProcessor.isBypassed(), juce::dontSendNotification);
}
inline void EQPanel::paint(juce::Graphics& g) { g.fillAll(juce::Colour(0xFF1A1A1A)); g.setColour(juce::Colour(0xFF404040)); g.drawRect(getLocalBounds(), 2); g.setColour(juce::Colour(0xFF2A2A2A)); g.fillRect(getLocalBounds().reduced(10)); }
inline void EQPanel::resized() {
    auto area = getLocalBounds().reduced(15);
    auto topArea = area.removeFromTop(40);
    toggleButton->setBounds(topArea.removeFromRight(40).withSizeKeepingCentre(40, 40));
    titleLabel.setBounds(topArea);
    area.removeFromTop(10);
    auto freqArea = area.removeFromTop(60); int fW = juce::jmin(600, freqArea.getWidth());
    frequencySelector->setBounds(freqArea.withWidth(fW).withX(freqArea.getX() + (freqArea.getWidth() - fW)/2));
    area.removeFromTop(20);
    int groupW = 140; int spacing = 40; int totalW = (groupW * 3) + (spacing * 2);
    int startX = area.getX() + (area.getWidth() - totalW) / 2;
    auto bandArea = area.withX(startX).withWidth(totalW);
    auto layoutGroup = [&](juce::Label& lbl, VerticalSlider& s1, VerticalSlider& s2) {
        auto gArea = bandArea.removeFromLeft(groupW); bandArea.removeFromLeft(spacing);
        lbl.setBounds(gArea.removeFromTop(20)); s1.setBounds(gArea.removeFromLeft(groupW/2).reduced(2)); s2.setBounds(gArea.reduced(2));
    };
    layoutGroup(lowLabel, *lowGainSlider, *lowQSlider); layoutGroup(midLabel, *midGainSlider, *midQSlider); layoutGroup(highLabel, *highGainSlider, *highQSlider);
}



--------------------------------------------------------------------------------
File: src/UI/ExciterPanel.h
Size: 4.96 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"
#include "EffectToggleButton.h"
#include "../AudioEngine.h"

class ExciterPanel : public juce::Component, private juce::Timer {
public:
    ExciterPanel(AudioEngine& engine, int micIndex, const juce::String& micName) : audioEngine(engine), micIdx(micIndex) {
        goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>();
        auto& e = audioEngine.getExciterProcessor(micIdx); auto params = e.getParams();
        toggleButton = std::make_unique<EffectToggleButton>();
        int note = (micIdx == 0) ? 17 : 20; toggleButton->setMidiInfo("MIDI: Note " + juce::String(note));
        toggleButton->setToggleState(!e.isBypassed(), juce::dontSendNotification);
        toggleButton->onClick = [this]() { audioEngine.getExciterProcessor(micIdx).setBypassed(!toggleButton->getToggleState()); };
        addAndMakeVisible(toggleButton.get());
        addAndMakeVisible(titleLabel);
        titleLabel.setText(micName + " - Exciter", juce::dontSendNotification);
        titleLabel.setFont(juce::Font(18.0f, juce::Font::bold));
        titleLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
        titleLabel.setJustificationType(juce::Justification::centredLeft);
        auto cS = [&](std::unique_ptr<VerticalSlider>& s, const juce::String& n, int cc, double min, double max, double v, const juce::String& suf) {
            s = std::make_unique<VerticalSlider>(); s->setLabelText(n); s->setMidiInfo("MIDI: CC " + juce::String(cc));
            s->setRange(min, max, (max-min)/100.0); s->setValue(v); s->setTextValueSuffix(suf);
            s->getSlider().setLookAndFeel(goldenLookAndFeel.get());
            s->getSlider().onValueChange = [this]() { updateExciter(); };
            addAndMakeVisible(s.get());
        };
        int baseFreqCC = (micIdx == 0) ? 53 : 63; int baseDriveCC = (micIdx == 0) ? 54 : 64; int baseMixCC = (micIdx == 0) ? 39 : 40;
        cS(freqSlider, "Freq", baseFreqCC, 1000.0, 10000.0, params.frequency, " Hz");
        cS(amountSlider, "Drive", baseDriveCC, 0.0, 24.0, params.amount, " dB");
        cS(mixSlider, "Mix", baseMixCC, 0.0, 1.0, params.mix, "");
        startTimerHz(15);
    }
    ~ExciterPanel() override { stopTimer(); freqSlider->getSlider().setLookAndFeel(nullptr); amountSlider->getSlider().setLookAndFeel(nullptr); mixSlider->getSlider().setLookAndFeel(nullptr); }
    void paint(juce::Graphics& g) override { g.fillAll(juce::Colour(0xFF1A1A1A)); g.setColour(juce::Colour(0xFF404040)); g.drawRect(getLocalBounds(), 2); g.setColour(juce::Colour(0xFF2A2A2A)); g.fillRect(getLocalBounds().reduced(10)); }
    void resized() override {
        auto area = getLocalBounds().reduced(15);
        auto titleRow = area.removeFromTop(40);
        toggleButton->setBounds(titleRow.removeFromRight(40).withSizeKeepingCentre(40, 40));
        titleLabel.setBounds(titleRow);
        area.removeFromTop(10);
        int numSliders = 3; int sliderWidth = 60; int spacing = 40; // Increased spacing for sparse panel
        int totalW = (numSliders * sliderWidth) + ((numSliders - 1) * spacing);
        int startX = area.getX() + (area.getWidth() - totalW) / 2;
        auto sArea = area.withX(startX).withWidth(totalW);
        freqSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        amountSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        mixSlider->setBounds(sArea.removeFromLeft(sliderWidth));
    }
    void updateFromPreset() { auto& e = audioEngine.getExciterProcessor(micIdx); auto p = e.getParams(); freqSlider->setValue(p.frequency, juce::dontSendNotification); amountSlider->setValue(p.amount, juce::dontSendNotification); mixSlider->setValue(p.mix, juce::dontSendNotification); toggleButton->setToggleState(!e.isBypassed(), juce::dontSendNotification); }
private:
    void timerCallback() override { auto p = audioEngine.getExciterProcessor(micIdx).getParams(); if (!freqSlider->getSlider().isMouseOverOrDragging()) freqSlider->setValue(p.frequency, juce::dontSendNotification); if (!amountSlider->getSlider().isMouseOverOrDragging()) amountSlider->setValue(p.amount, juce::dontSendNotification); if (!mixSlider->getSlider().isMouseOverOrDragging()) mixSlider->setValue(p.mix, juce::dontSendNotification); bool shouldBeOn = !audioEngine.getExciterProcessor(micIdx).isBypassed(); if (toggleButton->getToggleState() != shouldBeOn) toggleButton->setToggleState(shouldBeOn, juce::dontSendNotification); }
    AudioEngine& audioEngine; int micIdx;
    std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel; std::unique_ptr<EffectToggleButton> toggleButton; juce::Label titleLabel; std::unique_ptr<VerticalSlider> freqSlider, amountSlider, mixSlider;
    void updateExciter() { ExciterProcessor::Params p; p.frequency = freqSlider->getValue(); p.amount = amountSlider->getValue(); p.mix = mixSlider->getValue(); audioEngine.getExciterProcessor(micIdx).setParams(p); }
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ExciterPanel)
};



--------------------------------------------------------------------------------
File: src/UI/HarmonizerPanel.h
Size: 8.30 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"
#include "EffectToggleButton.h"
#include "../AudioEngine.h"

class HarmonizerPanel : public juce::Component, private juce::Timer {
public:
    HarmonizerPanel(AudioEngine& engine) : audioEngine(engine) {
        goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>();
        auto& h = audioEngine.getHarmonizerProcessor(); auto params = h.getParams();

        toggleButton = std::make_unique<EffectToggleButton>();
        toggleButton->setMidiInfo("MIDI: Note 23"); 
        toggleButton->setToggleState(!h.isBypassed(), juce::dontSendNotification);
        toggleButton->onClick = [this]() { audioEngine.getHarmonizerProcessor().setBypassed(!toggleButton->getToggleState()); };
        addAndMakeVisible(toggleButton.get());

        addAndMakeVisible(titleLabel);
        titleLabel.setText("Harmonizer (Fixed Mode)", juce::dontSendNotification);
        titleLabel.setFont(juce::Font(20.0f, juce::Font::bold));
        titleLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
        titleLabel.setJustificationType(juce::Justification::centredLeft);

        // UPDATED: Lambda now accepts 'step' to enforce integer semitones
        auto cS = [&](std::unique_ptr<VerticalSlider>& s, const juce::String& n, int cc, double min, double max, double v, double step, const juce::String& suf) {
            s = std::make_unique<VerticalSlider>();
            s->setLabelText(n); s->setMidiInfo("MIDI: CC " + juce::String(cc));
            s->setRange(min, max, step); 
            s->setValue(v); s->setTextValueSuffix(suf);
            s->getSlider().setLookAndFeel(goldenLookAndFeel.get());
            s->getSlider().onValueChange = [this]() { updateHarmonizer(); };
            addAndMakeVisible(s.get());
        };

        // Pitch Sliders: Step 1.0 (Full Semitones)
        cS(voice1PitchSlider, "V1 Pitch", 55, -12.0, 12.0, params.voices[0].fixedSemitones, 1.0, " st");
        
        // Gain Sliders: Step 0.1 (Decibels)
        cS(voice1GainSlider, "V1 Gain", 56, -24.0, 12.0, params.voices[0].gainDb, 0.1, " dB");
        
        // Pitch Sliders: Step 1.0
        cS(voice2PitchSlider, "V2 Pitch", 57, -12.0, 12.0, params.voices[1].fixedSemitones, 1.0, " st");
        
        // Gain Sliders: Step 0.1
        cS(voice2GainSlider, "V2 Gain", 58, -24.0, 12.0, params.voices[1].gainDb, 0.1, " dB");
        cS(wetSlider, "Wet", 30, -24.0, 12.0, params.wetDb, 0.1, " dB");

        voice1EnableToggle = std::make_unique<EffectToggleButton>();
        voice1EnableToggle->setButtonText("V1"); voice1EnableToggle->setMidiInfo("MIDI: Note 24");
        voice1EnableToggle->setToggleState(params.voices[0].enabled, juce::dontSendNotification);
        voice1EnableToggle->onClick = [this]() { updateHarmonizer(); };
        addAndMakeVisible(voice1EnableToggle.get());

        voice2EnableToggle = std::make_unique<EffectToggleButton>();
        voice2EnableToggle->setButtonText("V2"); voice2EnableToggle->setMidiInfo("MIDI: Note 25");
        voice2EnableToggle->setToggleState(params.voices[1].enabled, juce::dontSendNotification);
        voice2EnableToggle->onClick = [this]() { updateHarmonizer(); };
        addAndMakeVisible(voice2EnableToggle.get());

        startTimerHz(15);
    }

    ~HarmonizerPanel() override { stopTimer();
        voice1PitchSlider->getSlider().setLookAndFeel(nullptr); voice1GainSlider->getSlider().setLookAndFeel(nullptr);
        voice2PitchSlider->getSlider().setLookAndFeel(nullptr); voice2GainSlider->getSlider().setLookAndFeel(nullptr);
        wetSlider->getSlider().setLookAndFeel(nullptr);
    }

    void paint(juce::Graphics& g) override {
        g.fillAll(juce::Colour(0xFF1A1A1A));
        g.setColour(juce::Colour(0xFF404040));
        g.drawRect(getLocalBounds(), 2);
        g.setColour(juce::Colour(0xFF2A2A2A)); g.fillRect(getLocalBounds().reduced(10));
    }

    void resized() override {
        auto area = getLocalBounds().reduced(15);
        auto titleRow = area.removeFromTop(40);
        toggleButton->setBounds(titleRow.removeFromRight(40).withSizeKeepingCentre(40, 40));
        titleLabel.setBounds(titleRow);

        area.removeFromTop(10);
        auto toggleRow = area.removeFromTop(40); 
        area.removeFromTop(5);
        int numSliders = 5; int sliderWidth = 60; int spacing = 20;
        int totalW = (numSliders * sliderWidth) + ((numSliders - 1) * spacing);
        int startX = area.getX() + (area.getWidth() - totalW) / 2;
        auto sArea = area.withX(startX).withWidth(totalW);

        voice1EnableToggle->setBounds(startX + sliderWidth/2, toggleRow.getY(), 40, 40);
        voice2EnableToggle->setBounds(startX + (sliderWidth*2) + (spacing*2) + sliderWidth/2, toggleRow.getY(), 40, 40);

        voice1PitchSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        voice1GainSlider->setBounds(sArea.removeFromLeft(sliderWidth));  sArea.removeFromLeft(spacing);
        voice2PitchSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        voice2GainSlider->setBounds(sArea.removeFromLeft(sliderWidth));  sArea.removeFromLeft(spacing);
        wetSlider->setBounds(sArea.removeFromLeft(sliderWidth));
    }

    void updateFromPreset() {
        auto& h = audioEngine.getHarmonizerProcessor();
        auto p = h.getParams();
        voice1PitchSlider->setValue(p.voices[0].fixedSemitones, juce::dontSendNotification);
        voice1GainSlider->setValue(p.voices[0].gainDb, juce::dontSendNotification);
        voice2PitchSlider->setValue(p.voices[1].fixedSemitones, juce::dontSendNotification);
        voice2GainSlider->setValue(p.voices[1].gainDb, juce::dontSendNotification);
        wetSlider->setValue(p.wetDb, juce::dontSendNotification);
        toggleButton->setToggleState(!h.isBypassed(), juce::dontSendNotification);
        voice1EnableToggle->setToggleState(p.voices[0].enabled, juce::dontSendNotification);
        voice2EnableToggle->setToggleState(p.voices[1].enabled, juce::dontSendNotification);
    }

private:
    void timerCallback() override {
        auto p = audioEngine.getHarmonizerProcessor().getParams();
        if (!voice1PitchSlider->getSlider().isMouseOverOrDragging()) voice1PitchSlider->setValue(p.voices[0].fixedSemitones, juce::dontSendNotification);
        if (!voice1GainSlider->getSlider().isMouseOverOrDragging()) voice1GainSlider->setValue(p.voices[0].gainDb, juce::dontSendNotification);
        if (!voice2PitchSlider->getSlider().isMouseOverOrDragging()) voice2PitchSlider->setValue(p.voices[1].fixedSemitones, juce::dontSendNotification);
        if (!voice2GainSlider->getSlider().isMouseOverOrDragging()) voice2GainSlider->setValue(p.voices[1].gainDb, juce::dontSendNotification);
        if (!wetSlider->getSlider().isMouseOverOrDragging()) wetSlider->setValue(p.wetDb, juce::dontSendNotification);
        bool shouldBeOn = !audioEngine.getHarmonizerProcessor().isBypassed();
        if (toggleButton->getToggleState() != shouldBeOn) toggleButton->setToggleState(shouldBeOn, juce::dontSendNotification);
        if (voice1EnableToggle->getToggleState() != p.voices[0].enabled) voice1EnableToggle->setToggleState(p.voices[0].enabled, juce::dontSendNotification);
        if (voice2EnableToggle->getToggleState() != p.voices[1].enabled) voice2EnableToggle->setToggleState(p.voices[1].enabled, juce::dontSendNotification);
    }
    AudioEngine& audioEngine;
    std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel;
    std::unique_ptr<EffectToggleButton> toggleButton; juce::Label titleLabel;
    std::unique_ptr<VerticalSlider> voice1PitchSlider, voice1GainSlider, voice2PitchSlider, voice2GainSlider, wetSlider;
    std::unique_ptr<EffectToggleButton> voice1EnableToggle, voice2EnableToggle;
    void updateHarmonizer() {
        HarmonizerProcessor::Params p;
        p.enabled = true; p.useDiatonicMode = false; p.wetDb = wetSlider->getValue(); p.glideMs = 50.0f;
        p.voices[0].enabled = voice1EnableToggle->getToggleState(); p.voices[0].fixedSemitones = voice1PitchSlider->getValue();
        p.voices[0].gainDb = voice1GainSlider->getValue();
        p.voices[1].enabled = voice2EnableToggle->getToggleState(); p.voices[1].fixedSemitones = voice2PitchSlider->getValue(); p.voices[1].gainDb = voice2GainSlider->getValue();
        audioEngine.getHarmonizerProcessor().setParams(p);
    }
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(HarmonizerPanel)
};



--------------------------------------------------------------------------------
File: src/UI/HeaderBar.cpp
Size: 6.37 KB
--------------------------------------------------------------------------------

// **Changes:** 1.  Implemented `manualButton` initialization and click handler (opens `ManualComponent` in a Dialog). 2.  Updated `resized()` to place the Manual button to the left of the Save button. <!-- end list -->

#include "HeaderBar.h"
#include <juce_graphics/juce_graphics.h>
#include "BinaryData.h"
#include "RegistrationComponent.h"
#include "ManualComponent.h" // NEW

using namespace juce;

HeaderBar::HeaderBar(AudioEngine& engine) : audioEngine(engine)
{
    fananLogo   = ImageFileFormat::loadFrom(BinaryData::logo_png, BinaryData::logo_pngSize);
    onStageLogo = ImageFileFormat::loadFrom(BinaryData::On_stage_logo_png, BinaryData::On_stage_logo_pngSize);
    
    // MANUAL BUTTON
    addAndMakeVisible(manualButton);
    manualButton.setButtonText("Manual");
    manualButton.setColour(TextButton::buttonColourId, Colour(0xFF2A2A2A));
    manualButton.setColour(TextButton::textColourOnId, Colour(0xFFD4AF37));
    manualButton.setColour(TextButton::textColourOffId, Colour(0xFFD4AF37));
    manualButton.onClick = [this]() {
        DialogWindow::LaunchOptions opt;
        opt.content.setOwned(new ManualComponent());
        opt.dialogTitle = "OnStage User Manual";
        opt.componentToCentreAround = this;
        opt.dialogBackgroundColour = Colour(0xFF202020);
        opt.useNativeTitleBar = true;
        opt.resizable = false;
        opt.launchAsync();
    };

    addAndMakeVisible(savePresetButton);
    savePresetButton.setButtonText("Save Preset");
    savePresetButton.setColour(TextButton::buttonColourId, Colour(0xFF2A2A2A));
    savePresetButton.setColour(TextButton::textColourOnId, Colour(0xFFD4AF37));
    savePresetButton.setColour(TextButton::textColourOffId, Colour(0xFFD4AF37));
    savePresetButton.onClick = [this]() { if (onSavePreset) onSavePreset(); };
    
    addAndMakeVisible(loadPresetButton);
    loadPresetButton.setButtonText("Load Preset");
    loadPresetButton.setColour(TextButton::buttonColourId, Colour(0xFF2A2A2A));
    loadPresetButton.setColour(TextButton::textColourOnId, Colour(0xFFD4AF37));
    loadPresetButton.setColour(TextButton::textColourOffId, Colour(0xFFD4AF37));
    loadPresetButton.onClick = [this]() { if (onLoadPreset) onLoadPreset(); };
    
    addAndMakeVisible(presetNameLabel);
    presetNameLabel.setText("No Preset", dontSendNotification);
    presetNameLabel.setJustificationType(Justification::centred);
    presetNameLabel.setColour(Label::textColourId, Colour(0xFFD4AF37));
    presetNameLabel.setColour(Label::backgroundColourId, Colour(0xFF1A1A1A));
    presetNameLabel.setColour(Label::outlineColourId, Colour(0xFF404040));
    presetNameLabel.setFont(Font(14.0f, Font::bold));
    
    // REGISTER BUTTON
    addAndMakeVisible(registerButton);
    registerButton.setButtonText("REGISTER");
    registerButton.setColour(TextButton::buttonColourId, Colour(0xFF8B0000)); // Dark Red
    registerButton.setColour(TextButton::textColourOffId, Colours::white);
    registerButton.onClick = [this]() { 
        DialogWindow::LaunchOptions opt;
        opt.content.setOwned(new RegistrationComponent());
        opt.dialogTitle = "Registration";
        opt.componentToCentreAround = this;
        opt.dialogBackgroundColour = Colour(0xFFE08020);
        opt.useNativeTitleBar = true;
        opt.resizable = false;
        opt.launchAsync();
    };
    
    addAndMakeVisible(modeLabel);
    modeLabel.setFont(Font(14.0f, Font::bold));
    modeLabel.setJustificationType(Justification::centredLeft);
    
    currentPresetName = "No Preset";
    startTimer(1000);
    timerCallback();
}

void HeaderBar::timerCallback()
{
    bool isPro = RegistrationManager::getInstance().isProMode();
    if (isPro) {
        modeLabel.setText("PRO", dontSendNotification);
        modeLabel.setColour(Label::textColourId, Colours::lightgreen);
    } else {
        modeLabel.setText("DEMO", dontSendNotification);
        modeLabel.setColour(Label::textColourId, Colours::red);
    }
}

void HeaderBar::paint(Graphics& g)
{
    g.fillAll(Colour(0xFF202020));

    auto area = getLocalBounds();
    int height = area.getHeight();

    if (fananLogo.isValid())
    {
        int logoHeight = height - 20;
        int logoWidth = (int)(logoHeight * 2.303f);
        Rectangle<int> fananArea(55, (height - logoHeight) / 2, logoWidth, logoHeight);
        g.drawImageWithin(fananLogo, fananArea.getX(), fananArea.getY(), 
                         fananArea.getWidth(), fananArea.getHeight(),
                         RectanglePlacement::centred);
    }

    if (onStageLogo.isValid())
    {
        int logoHeight = (int)((height - 20) * 0.805f);
        int logoWidth = (int)(logoHeight * 6.486f);
        int xPos = getWidth() - logoWidth - 15;
        Rectangle<int> onstageArea(xPos, (height - logoHeight) / 2, logoWidth, logoHeight);
        g.drawImageWithin(onStageLogo, onstageArea.getX(), onstageArea.getY(),
                         onstageArea.getWidth(), onstageArea.getHeight(),
                         RectanglePlacement::centred);
    }
}

void HeaderBar::resized()
{
    auto area = getLocalBounds();
    int height = area.getHeight();
    
    int buttonWidth = 100;
    int buttonHeight = 30;
    int manualWidth = 80; // Slightly smaller for Manual
    int spacing = 10;
    int buttonY = (height - buttonHeight) / 2;

    // Calculate total width of center block
    int totalCenterGroupWidth = manualWidth + (buttonWidth * 2) + 150 + 80 + (spacing * 4);
    int modeLabelWidth = 50;
    
    totalCenterGroupWidth += modeLabelWidth + spacing;
    int startX = (getWidth() - totalCenterGroupWidth) / 2;

    // 1. Manual Button
    manualButton.setBounds(startX, buttonY, manualWidth, buttonHeight);
    
    // 2. Save Preset
    savePresetButton.setBounds(manualButton.getRight() + spacing, buttonY, buttonWidth, buttonHeight);
    
    // 3. Load Preset
    loadPresetButton.setBounds(savePresetButton.getRight() + spacing, buttonY, buttonWidth, buttonHeight);
    
    // 4. Label
    presetNameLabel.setBounds(loadPresetButton.getRight() + spacing, buttonY, 150, buttonHeight);
    
    // 5. Register
    registerButton.setBounds(presetNameLabel.getRight() + spacing, buttonY, 80, buttonHeight);
    
    // 6. Mode Label
    modeLabel.setBounds(registerButton.getRight() + spacing, buttonY, modeLabelWidth, buttonHeight);
}

void HeaderBar::setPresetName(const juce::String& name)
{
    currentPresetName = name.isEmpty() ? "No Preset" : name;
    presetNameLabel.setText(currentPresetName, juce::dontSendNotification);
}



--------------------------------------------------------------------------------
File: src/UI/HeaderBar.h
Size: 1.07 KB
--------------------------------------------------------------------------------

// **Changes:** Added `manualButton`.

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_graphics/juce_graphics.h>
#include <functional>
#include "../AudioEngine.h"

class HeaderBar : public juce::Component, private juce::Timer
{
public:
    HeaderBar(AudioEngine& engine);
    ~HeaderBar() override = default;

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    std::function<void()> onSavePreset;
    std::function<void()> onLoadPreset;

    void setPresetName(const juce::String& name);
    juce::String getPresetName() const { return currentPresetName; }

private:
    void timerCallback() override;

    AudioEngine& audioEngine;

    juce::Image fananLogo;
    juce::Image onStageLogo;
    
    // NEW: Manual Button
    juce::TextButton manualButton;

    juce::TextButton savePresetButton;
    juce::TextButton loadPresetButton;
    juce::Label presetNameLabel;
    juce::TextButton registerButton;
    juce::Label modeLabel;
    
    juce::String currentPresetName;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(HeaderBar)
};



--------------------------------------------------------------------------------
File: src/UI/IOPage.cpp
Size: 26.65 KB
--------------------------------------------------------------------------------

#include "IOPage.h"
#include "../RegistrationManager.h" 
#include "../AppLogger.h"

IOPage::IOPage(AudioEngine& engine, IOSettingsManager& settings)
    : audioEngine(engine), ioSettingsManager(settings)
{
    LOG_INFO("IOPage: Constructor START");
    goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>();
    setLookAndFeel(goldenLookAndFeel.get());

    addAndMakeVisible(leftViewport);
    leftViewport.setViewedComponent(&leftContainer, false);
    leftViewport.setScrollBarsShown(true, false);
    
    addAndMakeVisible(outputViewport);
    outputViewport.setViewedComponent(&outputCheckboxContainer, false);
    outputViewport.setScrollBarsShown(true, false);
    // --- 1. ASIO ---
    leftContainer.addAndMakeVisible(asioDriverSectionLabel);
    asioDriverSectionLabel.setText("ASIO Audio Device", juce::dontSendNotification);
    asioDriverSectionLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
    asioDriverSectionLabel.setFont(juce::Font(18.0f, juce::Font::bold));

    leftContainer.addAndMakeVisible(specificDriverLabel);
    specificDriverLabel.setText("Driver:", juce::dontSendNotification);
    leftContainer.addAndMakeVisible(specificDriverSelector);
    
    auto drivers = audioEngine.getSpecificDrivers("ASIO");
    drivers.insert(0, "OFF"); 
    specificDriverSelector.addItemList(drivers, 1);
    specificDriverSelector.setText("OFF", juce::dontSendNotification);
    
    specificDriverSelector.onChange = [this] { onSpecificDriverChanged(); };

    leftContainer.addAndMakeVisible(controlPanelButton);
    controlPanelButton.setButtonText("Control Panel");
    controlPanelButton.onClick = [this] { audioEngine.openDriverControlPanel(); };

    leftContainer.addAndMakeVisible(deviceInfoLabel);
    deviceInfoLabel.setColour(juce::Label::textColourId, juce::Colours::lightgrey);
    deviceInfoLabel.setFont(juce::Font(14.0f));
    
    // --- 2. Mics ---
    leftContainer.addAndMakeVisible(performersInputsSectionLabel);
    performersInputsSectionLabel.setText("Microphone Inputs", juce::dontSendNotification);
    performersInputsSectionLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
    performersInputsSectionLabel.setFont(juce::Font(18.0f, juce::Font::bold));

    leftContainer.addAndMakeVisible(mic1Label);
    mic1Label.setText("Mic 1:", juce::dontSendNotification);
    leftContainer.addAndMakeVisible(mic1InputSelector);
    mic1InputSelector.onChange = [this] { 
        audioEngine.selectInputDevice(0, mic1InputSelector.getText());
        ioSettingsManager.saveMicInput(0, mic1InputSelector.getText());
    };

    leftContainer.addAndMakeVisible(mic1MuteToggle); mic1MuteToggle.setButtonText("Mute");
    mic1MuteToggle.setMidiInfo("MIDI: Note 10");
    // UPDATED: Save State
    mic1MuteToggle.onClick = [this] { 
        audioEngine.setMicMute(0, mic1MuteToggle.getToggleState());
        ioSettingsManager.saveMicMute(0, mic1MuteToggle.getToggleState());
    };

    leftContainer.addAndMakeVisible(mic1BypassToggle); mic1BypassToggle.setButtonText("FX Bypass");
    mic1BypassToggle.setMidiInfo("MIDI: Note 11");
    // UPDATED: Save State
    mic1BypassToggle.onClick = [this] { 
        audioEngine.setFxBypass(0, mic1BypassToggle.getToggleState());
        ioSettingsManager.saveMicBypass(0, mic1BypassToggle.getToggleState());
    };

    leftContainer.addAndMakeVisible(mic1Led);

    leftContainer.addAndMakeVisible(mic2Label); mic2Label.setText("Mic 2:", juce::dontSendNotification);
    leftContainer.addAndMakeVisible(mic2InputSelector);
    mic2InputSelector.onChange = [this] { 
        audioEngine.selectInputDevice(1, mic2InputSelector.getText());
        ioSettingsManager.saveMicInput(1, mic2InputSelector.getText());
    };

    leftContainer.addAndMakeVisible(mic2MuteToggle); mic2MuteToggle.setButtonText("Mute");
    mic2MuteToggle.setMidiInfo("MIDI: Note 12");
    // UPDATED: Save State
    mic2MuteToggle.onClick = [this] { 
        audioEngine.setMicMute(1, mic2MuteToggle.getToggleState());
        ioSettingsManager.saveMicMute(1, mic2MuteToggle.getToggleState());
    };

    leftContainer.addAndMakeVisible(mic2BypassToggle); mic2BypassToggle.setButtonText("FX Bypass");
    mic2BypassToggle.setMidiInfo("MIDI: Note 13");
    // UPDATED: Save State
    mic2BypassToggle.onClick = [this] { 
        audioEngine.setFxBypass(1, mic2BypassToggle.getToggleState());
        ioSettingsManager.saveMicBypass(1, mic2BypassToggle.getToggleState());
    };

    leftContainer.addAndMakeVisible(mic2Led);

    // --- 3. Backing ---
    leftContainer.addAndMakeVisible(backingTrackSectionLabel);
    backingTrackSectionLabel.setText("Backing Tracks Routing", juce::dontSendNotification);
    backingTrackSectionLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
    backingTrackSectionLabel.setFont(juce::Font(18.0f, juce::Font::bold));

    leftContainer.addAndMakeVisible(mediaPlayerLabel); mediaPlayerLabel.setText("Internal Media Player:", juce::dontSendNotification);
    leftContainer.addAndMakeVisible(mediaPlayerToggle); mediaPlayerToggle.setButtonText("Active");
    mediaPlayerToggle.setToggleState(true, juce::dontSendNotification);
    mediaPlayerToggle.setEnabled(false);
    leftContainer.addAndMakeVisible(mediaPlayerLed);

    leftContainer.addAndMakeVisible(backingGainHeaderLabel);
    backingGainHeaderLabel.setText("Gain", juce::dontSendNotification);
    backingGainHeaderLabel.setFont(juce::Font(14.0f, juce::Font::bold));
    backingGainHeaderLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    backingGainHeaderLabel.setJustificationType(juce::Justification::centred);

    for (int i = 0; i < 4; ++i) {
        auto* pair = new PlaybackInputPair();
        pair->label.setText("Input Pair " + juce::String(i + 1), juce::dontSendNotification);
        pair->leftLabel.setText("L:", juce::dontSendNotification);
        pair->rightLabel.setText("R:", juce::dontSendNotification);
        
        pair->leftSelector.onChange = [this, i] { onPlaybackInputChanged(i, true); };
        pair->rightSelector.onChange = [this, i] { onPlaybackInputChanged(i, false); };

        pair->gainSlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        pair->gainSlider->setRange(0.0, 2.0, 0.01);
        pair->gainSlider->setValue(1.0);
        pair->gainSlider->setMidiInfo("MIDI: CC " + juce::String(20 + i));
        
        pair->gainSlider->onValueChange = [this, i] { 
            float val = (float)playbackInputPairs[i]->gainSlider->getValue();
            audioEngine.setBackingTrackPairGain(i, val);
            
            auto* p = playbackInputPairs[i];
            int inputIdx = 1 + i*2;
            int chIdx = audioEngine.getBackingTrackInputChannel(inputIdx);
            ioSettingsManager.saveBackingTrackInput(inputIdx, chIdx >= 0, chIdx, 
                                                    p->leftSelector.getText(), p->rightSelector.getText(), val);
        };

        inputsContainer.addAndMakeVisible(pair->label);
        inputsContainer.addAndMakeVisible(pair->leftLabel);
        inputsContainer.addAndMakeVisible(pair->leftSelector);
        inputsContainer.addAndMakeVisible(pair->rightLabel);
        inputsContainer.addAndMakeVisible(pair->rightSelector);
        inputsContainer.addAndMakeVisible(pair->gainSlider.get());
        inputsContainer.addAndMakeVisible(pair->leftLed);
        inputsContainer.addAndMakeVisible(pair->rightLed);

        playbackInputPairs.add(pair);
    }
    leftContainer.addAndMakeVisible(inputsContainer);
    // --- 4. Settings ---
    leftContainer.addAndMakeVisible(vocalSettingsSectionLabel);
    vocalSettingsSectionLabel.setText("Vocal Settings", juce::dontSendNotification);
    vocalSettingsSectionLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
    vocalSettingsSectionLabel.setFont(juce::Font(18.0f, juce::Font::bold));

    leftContainer.addAndMakeVisible(latencyLabel);
    latencyLabel.setText("Latency Correction (ms):", juce::dontSendNotification);
    latencySlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
    latencySlider->setRange(0.0, 500.0, 1.0);
    latencySlider->setMidiInfo("MIDI: CC 24");
    latencySlider->onValueChange = [this] { 
        audioEngine.setLatencyCorrectionMs((float)latencySlider->getValue());
        ioSettingsManager.saveVocalSettings((float)latencySlider->getValue(), (float)vocalBoostSlider->getValue());
    };
    leftContainer.addAndMakeVisible(latencySlider.get());

    leftContainer.addAndMakeVisible(vocalBoostLabel);
    vocalBoostLabel.setText("Vocal Boost (dB):", juce::dontSendNotification);
    vocalBoostSlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
    vocalBoostSlider->setRange(0.0, 24.0, 0.1);
    vocalBoostSlider->setMidiInfo("MIDI: CC 25");
    vocalBoostSlider->onValueChange = [this] {
        audioEngine.setVocalBoostDb((float)vocalBoostSlider->getValue());
        ioSettingsManager.saveVocalSettings((float)latencySlider->getValue(), (float)vocalBoostSlider->getValue());
    };
    leftContainer.addAndMakeVisible(vocalBoostSlider.get());
    // --- 5. MIDI ---
    leftContainer.addAndMakeVisible(midiInputLabel); midiInputLabel.setText("MIDI Input:", juce::dontSendNotification);
    leftContainer.addAndMakeVisible(midiInputSelector);
    midiInputSelector.onChange = [this] {
        audioEngine.setMidiInput(midiInputSelector.getText());
        ioSettingsManager.saveMidiDevice(midiInputSelector.getText());
    };
    leftContainer.addAndMakeVisible(midiRefreshButton);
    midiRefreshButton.setButtonText("Refresh");
    midiRefreshButton.onClick = [this] { updateMidiDevices(); };

    // --- 6. Outputs ---
    addAndMakeVisible(outputsSectionLabel);
    outputsSectionLabel.setText("Outputs Routing", juce::dontSendNotification);
    outputsSectionLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
    outputsSectionLabel.setFont(juce::Font(18.0f, juce::Font::bold));

    updateInputDevices();
    updateOutputDevices();
    updateMidiDevices();
    
    startTimerHz(20);
    LOG_INFO("IOPage: Constructor END");
}

IOPage::~IOPage()
{
    stopTimer();
    setLookAndFeel(nullptr);
}

void IOPage::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colour(0xFF202020));
}

void IOPage::resized()
{
    auto area = getLocalBounds().reduced(10);
    auto leftArea = area.removeFromLeft((int)(area.getWidth() * 0.6f)).reduced(5);
    auto rightArea = area.reduced(5);

    // --- RIGHT ---
    outputsSectionLabel.setBounds(rightArea.removeFromTop(30));
    outputViewport.setBounds(rightArea);
    outputCheckboxContainer.setBounds(0, 0, outputViewport.getWidth(), outputItems.size() * 35);
    int outY = 0;
    for (auto* item : outputItems) {
        item->setBounds(0, outY, outputCheckboxContainer.getWidth(), 35);
        outY += 35;
    }

    // --- LEFT ---
    leftViewport.setBounds(leftArea);
    
    int w = leftViewport.getWidth() - 20;
    int y = 10;
    int gap = 40; 
    
    int comboX = 80;
    int comboRightMargin = 280;
    int comboWidth = w - comboX - comboRightMargin;
    if (comboWidth < 150) comboWidth = 150;
    // 1. ASIO
    asioDriverSectionLabel.setBounds(10, y, w, 25);
    y += 30;
    specificDriverLabel.setBounds(10, y, 60, 25);
    specificDriverSelector.setBounds(comboX, y, comboWidth, 25);
    controlPanelButton.setBounds(comboX + comboWidth + 10, y, 120, 25);
    y += gap;
    deviceInfoLabel.setBounds(10, y, w, 20);
    y += gap;

    // 2. Mics
    performersInputsSectionLabel.setBounds(10, y, w, 25);
    y += 30;
    
    mic1Label.setBounds(10, y, 50, 25);
    mic1InputSelector.setBounds(comboX, y, comboWidth, 25);
    int rightControlsX = comboX + comboWidth + 10;
    mic1MuteToggle.setBounds(rightControlsX, y, 60, 25);
    mic1BypassToggle.setBounds(rightControlsX + 70, y, 80, 25);
    mic1Led.setBounds(rightControlsX + 160, y, 20, 20); 
    
    y += 35;

    mic2Label.setBounds(10, y, 50, 25);
    mic2InputSelector.setBounds(comboX, y, comboWidth, 25);
    mic2MuteToggle.setBounds(rightControlsX, y, 60, 25);
    mic2BypassToggle.setBounds(rightControlsX + 70, y, 80, 25);
    mic2Led.setBounds(rightControlsX + 160, y, 20, 20);
    y += gap;

    // 3. Backing
    backingTrackSectionLabel.setBounds(10, y, w, 25);
    y += 30;
    mediaPlayerLabel.setBounds(10, y, 140, 25);
    mediaPlayerToggle.setBounds(160, y, 80, 25);
    mediaPlayerLed.setBounds(250, y, 20, 20);
    y += 35;

    int sliderW_est = (int)(w * 0.3f);
    if (sliderW_est < 100) sliderW_est = 100;
    backingGainHeaderLabel.setBounds(w - sliderW_est, y, sliderW_est, 20);
    y += 20;
    int inputsH = playbackInputPairs.size() * 45;
    inputsContainer.setBounds(10, y, w, inputsH);
    int inY = 0;
    for (auto* pair : playbackInputPairs) {
        int rowW = inputsContainer.getWidth();
        pair->label.setBounds(0, inY, 80, 30);
        
        int sliderW = (int)(rowW * 0.30f);
        if (sliderW < 100) sliderW = 100;
        pair->gainSlider->setBounds(rowW - sliderW, inY, sliderW, 30);
        int startX = 90;
        int endX = rowW - sliderW - 10;
        int comboAreaW = endX - startX;

        if (comboAreaW > 50) 
        {
            int singleBlockW = comboAreaW / 2;
            int labelW = 20;
            int ledW = 20;
            int comboW = singleBlockW - labelW - ledW - 5;
            if (comboW < 30) comboW = 30; 

            // Left Pair
            pair->leftLabel.setBounds(startX, inY, labelW, 30);
            pair->leftSelector.setBounds(startX + labelW, inY, comboW, 30);
            pair->leftLed.setBounds(startX + labelW + comboW + 2, inY + 5, ledW, 20);
            // Right Pair
            int rightBlockX = startX + singleBlockW;
            pair->rightLabel.setBounds(rightBlockX, inY, labelW, 30);
            pair->rightSelector.setBounds(rightBlockX + labelW, inY, comboW, 30);
            pair->rightLed.setBounds(rightBlockX + labelW + comboW + 2, inY + 5, ledW, 20);
        }

        inY += 45;
    }
    y += inputsH + 20;
    // 4. Settings
    vocalSettingsSectionLabel.setBounds(10, y, w, 25);
    y += 30;
    latencyLabel.setBounds(10, y, 160, 25);
    latencySlider->setBounds(180, y, w - 190, 25);
    y += 35;
    vocalBoostLabel.setBounds(10, y, 160, 25);
    vocalBoostSlider->setBounds(180, y, w - 190, 25);
    y += gap;

    // 5. MIDI
    midiInputLabel.setBounds(10, y, 80, 25);
    int refreshBtnWidth = 60;
    int midiComboWidth = w - 110 - refreshBtnWidth - 10;
    midiInputSelector.setBounds(100, y, midiComboWidth, 25);
    midiRefreshButton.setBounds(100 + midiComboWidth + 10, y, refreshBtnWidth, 25);
    
    y += gap;

    leftContainer.setBounds(0, 0, leftViewport.getWidth(), y + 50);
}

void IOPage::timerCallback()
{
    try {
        bool isPro = RegistrationManager::getInstance().isProMode();
        mic2InputSelector.setEnabled(isPro);
        mic2MuteToggle.setEnabled(isPro);
        mic2BypassToggle.setEnabled(isPro);
        
        for (auto* p : playbackInputPairs) {
            p->leftSelector.setEnabled(isPro);
            p->rightSelector.setEnabled(isPro);
            p->gainSlider->setEnabled(isPro);
        }

        const float threshold = 0.001f;
        mic1Led.setOn(audioEngine.getInputLevel(0) > threshold);
        mic2Led.setOn(isPro && (audioEngine.getInputLevel(1) > threshold));
        mediaPlayerLed.setOn(audioEngine.getBackingTrackLevel(0) > threshold);

        for (int i = 0; i < 4; ++i) {
            float engineGain = audioEngine.getBackingTrackPairGain(i);
            if (std::abs(playbackInputPairs[i]->gainSlider->getValue() - engineGain) > 0.01f) {
                if (!playbackInputPairs[i]->gainSlider->isMouseButtonDown()) {
                    playbackInputPairs[i]->gainSlider->setValue(engineGain, juce::dontSendNotification);
                }
            }

            if (isPro) {
                playbackInputPairs[i]->leftLed.setOn(audioEngine.getBackingTrackLevel(1 + i*2) > threshold);
                playbackInputPairs[i]->rightLed.setOn(audioEngine.getBackingTrackLevel(2 + i*2) > threshold);
            }
        }
        
        if (auto* d = audioEngine.getDeviceManager().getCurrentAudioDevice()) {
            deviceInfoLabel.setText(juce::String(d->getCurrentSampleRate()) + " Hz / " + 
                                    juce::String(d->getCurrentBufferSizeSamples()) + " samples", juce::dontSendNotification);
        }
        else {
            deviceInfoLabel.setText("No Audio Device", juce::dontSendNotification);
        }

        float masterL = audioEngine.getOutputLevel(0);
        float masterR = audioEngine.getOutputLevel(1);
        
        // Update Output LEDs based on current Routing
        for (auto* item : outputItems) {
            int mask = audioEngine.getOutputRoute(item->itemIndex);
            bool hasSignal = false;
            if (mask & 1 && masterL > threshold) hasSignal = true;
            if (mask & 2 && masterR > threshold) hasSignal = true;
            item->signalLed.setOn(hasSignal);
        }
    }
    catch (...) { stopTimer();
    }
}

void IOPage::onSpecificDriverChanged() { 
    ioSettingsManager.saveDriverType("ASIO");
    ioSettingsManager.saveSpecificDriver(specificDriverSelector.getText());
    
    audioEngine.setSpecificDriver("ASIO", specificDriverSelector.getText());
    updateInputDevices(); 
    updateOutputDevices();
    // UPDATED: Use new Settings Struct
    auto s0 = ioSettingsManager.getMicSettings(0);
    validateAndSelectMic(0, mic1InputSelector, s0.inputName);
    
    auto s1 = ioSettingsManager.getMicSettings(1);
    validateAndSelectMic(1, mic2InputSelector, s1.inputName);

    for (int i = 0; i < 4; ++i) {
        auto state = ioSettingsManager.getBackingTrackInput(1 + i*2);
        validateAndSelectBacking(i, true, playbackInputPairs[i]->leftSelector, state.leftSelection);
        validateAndSelectBacking(i, false, playbackInputPairs[i]->rightSelector, state.rightSelection);
    }
    
    // RESTORE OUTPUT ROUTING FOR NEW DRIVER
    auto savedMap = ioSettingsManager.getOutputRouting();
    auto outs = audioEngine.getAvailableOutputDevices();
    for (int i = 0; i < outs.size(); ++i) {
        if (savedMap.count(outs[i])) {
            audioEngine.setOutputRoute(i, savedMap[outs[i]]);
        }
    }
    // Refresh UI
    updateOutputDevices();
}

void IOPage::updateInputDevices() {
    auto inputs = audioEngine.getAvailableInputDevices();
    inputs.insert(0, "OFF");
    auto updateCombo = [&](juce::ComboBox& box) {
        auto current = box.getText();
        box.clear();
        box.addItemList(inputs, 1);
        if (inputs.contains(current)) 
        {
            box.setSelectedId(inputs.indexOf(current) + 1, juce::dontSendNotification);
        }
        else 
        {
            if (inputs.size() > 1)
                box.setSelectedId(2, juce::dontSendNotification);
            else
                box.setSelectedId(1, juce::dontSendNotification);
        }
    };
    
    updateCombo(mic1InputSelector);
    updateCombo(mic2InputSelector);
    for (auto* p : playbackInputPairs) {
        updateCombo(p->leftSelector);
        updateCombo(p->rightSelector);
    }
}

void IOPage::updateOutputDevices() {
    outputItems.clear();
    outputCheckboxContainer.removeAllChildren();
    
    auto outputs = audioEngine.getAvailableOutputDevices();
    
    for (int i=0; i < outputs.size(); i++) {
        juce::String name = outputs[i];
        
        auto* item = new OutputItemComponent(name, i);
        int currentMask = audioEngine.getOutputRoute(i);
        
        item->checkL.setToggleState(currentMask & 1, juce::dontSendNotification);
        item->checkR.setToggleState(currentMask & 2, juce::dontSendNotification);
        
        // Define click handler
        auto updateRoute = [this, i, item, name] {
            int newMask = 0;
            if (item->checkL.getToggleState()) newMask |= 1;
            if (item->checkR.getToggleState()) newMask |= 2;
            
            audioEngine.setOutputRoute(i, newMask);
            
            // Save settings
            auto currentMap = ioSettingsManager.getOutputRouting();
            currentMap[name] = newMask;
            ioSettingsManager.saveOutputRouting(currentMap);
        };
        
        item->checkL.onClick = updateRoute;
        item->checkR.onClick = updateRoute;
        
        outputItems.add(item);
        outputCheckboxContainer.addAndMakeVisible(item);
    }
    resized();
}

void IOPage::updateMidiDevices() {
    auto currentSelection = midiInputSelector.getText();
    auto list = audioEngine.getAvailableMidiInputs();
    list.insert(0, "OFF");
    
    midiInputSelector.clear();
    midiInputSelector.addItemList(list, 1);
    
    if (currentSelection.isNotEmpty() && list.contains(currentSelection))
    {
        midiInputSelector.setText(currentSelection, juce::dontSendNotification);
    }
    else
    {
        midiInputSelector.setText("OFF", juce::sendNotification);
    }
}

void IOPage::validateAndSelectMic(int micIndex, juce::ComboBox& selector, const juce::String& savedName)
{
    auto available = audioEngine.getAvailableInputDevices();
    juce::String nameToSelect = savedName;
    if (savedName != "OFF" && !available.contains(savedName))
    {
        if (available.size() > 0)
            nameToSelect = available[0];
        else
            nameToSelect = "OFF";
    }

    selector.setText(nameToSelect, juce::dontSendNotification);
    audioEngine.selectInputDevice(micIndex, nameToSelect);
    
    if (nameToSelect != savedName)
        ioSettingsManager.saveMicInput(micIndex, nameToSelect);
}

void IOPage::validateAndSelectBacking(int pairIndex, bool isLeft, juce::ComboBox& selector, const juce::String& savedName)
{
    auto available = audioEngine.getAvailableInputDevices();
    juce::String nameToSelect = savedName;

    if (savedName != "OFF" && !available.contains(savedName))
    {
        nameToSelect = "OFF";
    }

    selector.setText(nameToSelect, juce::dontSendNotification);
    
    int inputIdx = isLeft ? (1 + pairIndex*2) : (2 + pairIndex*2);
    int channelIndex = -1;
    if (nameToSelect != "OFF") channelIndex = available.indexOf(nameToSelect);
    
    audioEngine.setBackingTrackInputMapping(inputIdx, channelIndex);
    audioEngine.setBackingTrackInputEnabled(inputIdx, channelIndex >= 0);
    ioSettingsManager.saveBackingTrackInput(inputIdx, channelIndex >= 0, channelIndex, 
                                            isLeft ? nameToSelect : playbackInputPairs[pairIndex]->leftSelector.getText(),
                                            isLeft ? playbackInputPairs[pairIndex]->rightSelector.getText() 
                                            : nameToSelect,
                                            (float)playbackInputPairs[pairIndex]->gainSlider->getValue());
}

void IOPage::restoreSavedSettings() {
    LOG_INFO("IOPage: Restoring Saved Settings...");
    
    juce::String savedDriver = ioSettingsManager.getLastSpecificDriver();
    auto availableDrivers = audioEngine.getSpecificDrivers("ASIO");
    bool shouldLoad = false;
    if (savedDriver.isNotEmpty() && savedDriver != "OFF")
    {
        if (availableDrivers.contains(savedDriver))
        {
            shouldLoad = true;
        }
        else
        {
            LOG_WARNING("Saved ASIO driver '" + savedDriver + "' not found on system. Defaulting to OFF.");
        }
    }
    
    if (shouldLoad)
    {
        LOG_INFO("Restoring saved ASIO driver: " + savedDriver);
        specificDriverSelector.setText(savedDriver, juce::dontSendNotification);
        
        // Trigger driver load. This sets up AudioEngine defaults (0=L, 1=R) if nothing else set.
        onSpecificDriverChanged(); 
        
        // NOW, apply saved routing ON TOP
        auto savedMap = ioSettingsManager.getOutputRouting();
        if (!savedMap.empty()) {
            auto outs = audioEngine.getAvailableOutputDevices();
            for (int i = 0; i < outs.size(); ++i) {
                if (savedMap.count(outs[i])) {
                    audioEngine.setOutputRoute(i, savedMap[outs[i]]);
                } else {
                    // If new device has more channels than saved, default to OFF
                    audioEngine.setOutputRoute(i, 0); 
                }
            }
        }
        // If map empty, we keep AudioEngine defaults (0=L, 1=R) which is good.
        
        updateOutputDevices(); // Refresh UI
    }
    else
    {
        LOG_INFO("No valid saved driver found. Staying OFF.");
        specificDriverSelector.setText("OFF", juce::dontSendNotification);
        audioEngine.setSpecificDriver("ASIO", "OFF");
    }

    // UPDATED: Restore Mic Mute/Bypass States
    auto s0 = ioSettingsManager.getMicSettings(0);
    audioEngine.setMicMute(0, s0.isMuted);
    audioEngine.setFxBypass(0, s0.isBypassed);
    mic1MuteToggle.setToggleState(s0.isMuted, juce::dontSendNotification);
    mic1BypassToggle.setToggleState(s0.isBypassed, juce::dontSendNotification);

    auto s1 = ioSettingsManager.getMicSettings(1);
    audioEngine.setMicMute(1, s1.isMuted);
    audioEngine.setFxBypass(1, s1.isBypassed);
    mic2MuteToggle.setToggleState(s1.isMuted, juce::dontSendNotification);
    mic2BypassToggle.setToggleState(s1.isBypassed, juce::dontSendNotification);
    
    updateInputDevices();
    // Output Devices are updated via onSpecificDriverChanged -> restore from map

    latencySlider->setValue(ioSettingsManager.getLastLatencyMs(), juce::sendNotification);
    vocalBoostSlider->setValue(ioSettingsManager.getLastVocalBoostDb(), juce::sendNotification);
    
    juce::String savedMidi = ioSettingsManager.getLastMidiDevice();
    auto midiList = audioEngine.getAvailableMidiInputs();
    updateMidiDevices();
    if (savedMidi.isNotEmpty() && savedMidi != "OFF" && midiList.contains(savedMidi))
    {
        LOG_INFO("Restoring MIDI Device: " + savedMidi);
        midiInputSelector.setText(savedMidi, juce::sendNotification);
    }
    else
    {
        LOG_INFO("Saved MIDI device not available or OFF. Defaulting to OFF.");
        midiInputSelector.setText("OFF", juce::sendNotification);
        audioEngine.setMidiInput("OFF"); 
    }
}

void IOPage::onPlaybackInputChanged(int pairIndex, bool isLeft) {
    auto* pair = playbackInputPairs[pairIndex];
    juce::String selection = isLeft ?
                             pair->leftSelector.getText() : pair->rightSelector.getText();
    int inputIdx = isLeft ? (1 + pairIndex*2) : (2 + pairIndex*2);
    int channelIndex = -1;
    if (selection != "OFF") {
        auto inputs = audioEngine.getAvailableInputDevices();
        channelIndex = inputs.indexOf(selection);
    }
    
    audioEngine.setBackingTrackInputMapping(inputIdx, channelIndex);
    audioEngine.setBackingTrackInputEnabled(inputIdx, channelIndex >= 0);
    ioSettingsManager.saveBackingTrackInput(inputIdx, channelIndex >= 0, channelIndex, 
                                            pair->leftSelector.getText(), pair->rightSelector.getText(),
                                            (float)pair->gainSlider->getValue());
}



--------------------------------------------------------------------------------
File: src/UI/IOPage.h
Size: 4.59 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "../AudioEngine.h"
#include "../IOSettingsManager.h"
#include "SignalLed.h"
#include "StyledSlider.h"

// 1. Solid Background Container
class SimpleContainer : public juce::Component
{
public:
    SimpleContainer() { setOpaque(true);
    }
    void paint(juce::Graphics& g) override { g.fillAll(juce::Colour(0xFF202020)); }
};

// 2. Output Item Component with L/R Matrix Routing
class OutputItemComponent : public juce::Component
{
public:
    OutputItemComponent(const juce::String& name, int index) : itemIndex(index)
    {
        nameLabel.setText(name, juce::dontSendNotification);
        nameLabel.setColour(juce::Label::textColourId, juce::Colours::white);
        addAndMakeVisible(nameLabel);

        checkL.setButtonText("L");
        checkL.setColour(juce::ToggleButton::textColourId, juce::Colours::white);
        checkL.setColour(juce::ToggleButton::tickColourId, juce::Colour(0xFFD4AF37));
        addAndMakeVisible(checkL);

        checkR.setButtonText("R");
        checkR.setColour(juce::ToggleButton::textColourId, juce::Colours::white);
        checkR.setColour(juce::ToggleButton::tickColourId, juce::Colour(0xFFD4AF37));
        addAndMakeVisible(checkR);

        addAndMakeVisible(signalLed);
    }

    void resized() override
    {
        auto area = getLocalBounds();
        
        // Right Side: LED (15) | Check R (40) | Check L (40)
        auto rightSide = area.removeFromRight(100);
        
        signalLed.setBounds(rightSide.removeFromRight(20).reduced(3));
        checkR.setBounds(rightSide.removeFromRight(40));
        checkL.setBounds(rightSide.removeFromRight(40));
        
        // Left Side: Name
        nameLabel.setBounds(area.reduced(5, 0));
    }
    
    void paint(juce::Graphics& g) override {
        // Separator line
        g.setColour(juce::Colours::black);
        g.fillRect(0, getHeight() - 1, getWidth(), 1);
    }
    
    juce::Label nameLabel;
    juce::ToggleButton checkL;
    juce::ToggleButton checkR;
    SignalLed signalLed;
    int itemIndex;
};

// --- MAIN CLASS ---
class IOPage : public juce::Component, private juce::Timer {
public: 
    IOPage(AudioEngine& engine, IOSettingsManager& ioSettings);
    ~IOPage() override;
    void paint(juce::Graphics& g) override; 
    void resized() override; 
    void restoreSavedSettings();

private: 
    void timerCallback() override;
    AudioEngine& audioEngine; 
    IOSettingsManager& ioSettingsManager;

    std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel;
    
    juce::Viewport leftViewport; 
    SimpleContainer leftContainer; 
    
    juce::Viewport outputViewport; 
    SimpleContainer outputCheckboxContainer;
    // ASIO
    juce::Label asioDriverSectionLabel; 
    juce::Label specificDriverLabel; 
    juce::ComboBox specificDriverSelector;
    juce::TextButton controlPanelButton; 
    juce::Label deviceInfoLabel;
    // Mics
    juce::Label performersInputsSectionLabel; 
    juce::Label mic1Label, mic2Label;
    juce::ComboBox mic1InputSelector, mic2InputSelector;
    MidiTooltipToggleButton mic1MuteToggle, mic2MuteToggle; 
    MidiTooltipToggleButton mic1BypassToggle, mic2BypassToggle;
    SignalLed mic1Led, mic2Led;
    
    // Backing
    juce::Label backingTrackSectionLabel; 
    juce::Label mediaPlayerLabel;
    MidiTooltipToggleButton mediaPlayerToggle; 
    SignalLed mediaPlayerLed;
    juce::Label backingGainHeaderLabel;
    struct PlaybackInputPair { 
        juce::Label label, leftLabel, rightLabel; 
        juce::ComboBox leftSelector, rightSelector;
        SignalLed leftLed, rightLed; 
        std::unique_ptr<StyledSlider> gainSlider; 
    };
    juce::OwnedArray<PlaybackInputPair> playbackInputPairs; 
    SimpleContainer inputsContainer; 
    
    // Settings
    juce::Label vocalSettingsSectionLabel; 
    MidiTooltipLabel latencyLabel, vocalBoostLabel;
    std::unique_ptr<StyledSlider> latencySlider, vocalBoostSlider;
    
    // MIDI
    juce::Label midiInputLabel; 
    juce::ComboBox midiInputSelector;
    juce::TextButton midiRefreshButton;
    
    // Outputs
    juce::Label outputsSectionLabel; 
    juce::OwnedArray<OutputItemComponent> outputItems;
    void onSpecificDriverChanged(); 
    void updateInputDevices(); 
    void updateOutputDevices(); 
    void updateMidiDevices();
    void onPlaybackInputChanged(int pairIndex, bool isLeft);
    void validateAndSelectMic(int micIndex, juce::ComboBox& selector, const juce::String& savedName);
    void validateAndSelectBacking(int pairIndex, bool isLeft, juce::ComboBox& selector, const juce::String& savedName);
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(IOPage)
};



--------------------------------------------------------------------------------
File: src/UI/LevelMeter.h
Size: 1.24 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "../AudioEngine.h"

class LevelMeter : public juce::Component, private juce::Timer
{
public:
    enum class Source { Input, Output };
    LevelMeter (AudioEngine& eng, Source src) : engine (eng), source (src)
    {
        startTimerHz (60);
    }

    void paint (juce::Graphics& g) override
    {
        g.fillAll (juce::Colours::darkgrey);
        auto r = getLocalBounds().reduced (2);
        g.setColour (juce::Colours::black);
        g.drawRect (r);

        const auto h = (int) juce::jmap (smoothedLevel, 0.0f, 1.0f, 0.0f, (float) r.getHeight());
        juce::Rectangle<int> bar (r.withY (r.getBottom() - h).withHeight (h));
        
        // CHANGED: Use Gold color for the signal
        g.setColour (juce::Colour(0xFFD4AF37));
        g.fillRect (bar);
    }

private:
    void timerCallback() override
    {
        float targetLevel = (source == Source::Input) ? engine.getInputLevel() : engine.getOutputLevel();
        if (targetLevel > smoothedLevel) smoothedLevel += (targetLevel - smoothedLevel) * 0.7f;
        else smoothedLevel += (targetLevel - smoothedLevel) * 0.3f;
        repaint();
    }

    AudioEngine& engine;
    Source source;
    float smoothedLevel { 0.0f };
};



--------------------------------------------------------------------------------
File: src/UI/LongPressDetector.h
Size: 1.38 KB
--------------------------------------------------------------------------------

// This is the helper class that handles the timer and distance logic.

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

// A Mix-in class to add Long Press detection to any Component
class LongPressDetector : private juce::Timer
{
public:
    virtual ~LongPressDetector() { stopTimer(); }

    // Call this from your component's mouseDown
    void handleMouseDown(const juce::MouseEvent& e)
    {
        mouseDownTime = e.eventTime;
        mouseDownPos = e.getPosition();
        isLongPressTriggered = false;
        // 800ms is a standard "Long Press" duration
        startTimer(800); 
    }

    // Call this from mouseDrag
    void handleMouseDrag(const juce::MouseEvent& e)
    {
        // If user moves finger/mouse more than 10 pixels, cancel the long press
        if (e.getPosition().getDistanceFrom(mouseDownPos) > 10)
            stopTimer(); 
    }

    // Call this from mouseUp
    void handleMouseUp(const juce::MouseEvent& e)
    {
        stopTimer();
    }

    // Override this in your component to react!
    virtual void onLongPress() = 0;

private:
    void timerCallback() override
    {
        stopTimer();
        isLongPressTriggered = true;
        onLongPress();
    }

    juce::Point<int> mouseDownPos;
    juce::Time mouseDownTime;
protected:
    // Use this flag in mouseUp/mouseDrag to ignore events if long press happened
    bool isLongPressTriggered = false;
};



--------------------------------------------------------------------------------
File: src/UI/MainComponent.cpp
Size: 12.75 KB
--------------------------------------------------------------------------------

#include "MainComponent.h"
#include "IOPage.h"
#include "VocalsPage.h"
#include "MediaPage.h"
#include "../AppLogger.h"
#include "../RegistrationManager.h"

MainComponent::MainComponent()
    : presetManager(audioEngine),
      header(audioEngine),
      masterVolumeSlider(juce::Slider::LinearVertical, juce::Slider::TextBoxBelow),
      masterMeter(audioEngine) 
{
    LOG_INFO("=== MainComponent Constructor START ===");
    try {
        // FIX: CHECK REGISTRATION ON STARTUP
        // This loads the license.key file (if it exists) and restores PRO mode immediately.
        LOG_INFO("Step 0a: Checking License...");
        RegistrationManager::getInstance().checkRegistration();
        if (RegistrationManager::getInstance().isProMode()) {
            LOG_INFO("License Status: REGISTERED (PRO MODE)");
        } else {
            LOG_INFO("License Status: DEMO MODE");
        }

        LOG_INFO("Step 0b: Allocating GoldenSliderLookAndFeel...");
        goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>();
        LOG_INFO("Step 0c: Setting LookAndFeel for Tabs...");
        if (goldenLookAndFeel) {
            mainTabs.setLookAndFeel(goldenLookAndFeel.get());
        } else {
            LOG_ERROR("CRITICAL: Failed to allocate GoldenSliderLookAndFeel!");
        }

        LOG_INFO("Step 0d: Loading IO Settings from file...");
        if (ioSettingsManager.loadSettings()) {
            LOG_INFO("Settings loaded successfully.");
        } else {
            LOG_INFO("No settings file found or failed to load.");
        }

        LOG_INFO("Step 1: Adding header");
        addAndMakeVisible(header);
        
        LOG_INFO("Step 2: Adding mainTabs");
        addAndMakeVisible(mainTabs);
        // FIX: Force removal of all separator lines
        mainTabs.setTabBarDepth(60);
        mainTabs.setOutline(0);
        mainTabs.setIndent(0);
        mainTabs.setColour(juce::TabbedComponent::outlineColourId, juce::Colours::transparentBlack);
        LOG_INFO("Step 3: Creating IOPage");
        ioPage = std::make_unique<IOPage>(audioEngine, ioSettingsManager);
        
        LOG_INFO("Step 4: Creating VocalsPage");
        vocalsPage = std::make_unique<VocalsPage>(audioEngine, presetManager);
        
        LOG_INFO("Step 5: Creating MediaPage");
        mediaPage = std::make_unique<MediaPage>(audioEngine, ioSettingsManager);

        LOG_INFO("Step 6: Adding tabs");
        juce::Colour bgColour(0xFF202020);
        if (ioPage)     mainTabs.addTab("      I/O      ",    bgColour, ioPage.get(),     true);
        if (vocalsPage) mainTabs.addTab("      Vocals      ", bgColour, vocalsPage.get(), true);
        if (mediaPage)  mainTabs.addTab("      Media      ",  bgColour, mediaPage.get(),  true);
        LOG_INFO("Step 7: Setting up record button");
        addAndMakeVisible(recordButton);
        recordButton.setButtonText("RECORD");
        recordButton.setMidiInfo("MIDI: CC 26 (Future)"); 
        recordButton.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF8B0000));
        recordButton.setColour(juce::TextButton::textColourOffId, juce::Colours::white);
        recordButton.setColour(juce::TextButton::textColourOnId, juce::Colours::white);
        recordButton.onClick = [this] { handleRecordClick(); };

        LOG_INFO("Step 8: Setting up download button");
        addAndMakeVisible(downloadWavButton);
        downloadWavButton.setButtonText("Download WAV");
        downloadWavButton.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF2A2A2A));
        downloadWavButton.setColour(juce::TextButton::textColourOffId, juce::Colour(0xFF00FF00));
        downloadWavButton.setVisible(false);
        downloadWavButton.onClick = [this] { downloadRecording(); };

        LOG_INFO("Step 9: Adding master meter");
        addAndMakeVisible(masterMeter);

        LOG_INFO("Step 10: Setting up master volume slider");
        addAndMakeVisible(masterVolumeSlider);
        masterVolumeSlider.setRange(0.0, 1.0, 0.01);
        masterVolumeSlider.setValue(0.5, juce::dontSendNotification);
        masterVolumeSlider.setMidiInfo("MIDI: CC 7"); 
        masterVolumeSlider.setColour(juce::Slider::thumbColourId, juce::Colour(0xFFD4AF37));
        masterVolumeSlider.setColour(juce::Slider::trackColourId, juce::Colour(0xFF404040));
        masterVolumeSlider.setColour(juce::Slider::backgroundColourId, juce::Colour(0xFF202020));
        masterVolumeSlider.onValueChange = [this]() { 
            audioEngine.setMasterVolume(sliderValueToDb(masterVolumeSlider.getValue())); 
        };
        LOG_INFO("Step 11: Adding master volume label");
        addAndMakeVisible(masterVolumeLabel);
        masterVolumeLabel.setText("MASTER", juce::dontSendNotification);
        masterVolumeLabel.setFont(juce::Font(12.0f, juce::Font::bold));
        masterVolumeLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37));
        masterVolumeLabel.setJustificationType(juce::Justification::centred);
        masterVolumeLabel.setMidiInfo("MIDI: CC 7");
        LOG_INFO("Step 12: Setting up header callbacks");
        header.onSavePreset = [this]() { savePreset(); };
        header.onLoadPreset = [this]() { loadPreset(); };
        LOG_INFO("Step 13: Setting window size");
        setSize(1280, 720);
        
        LOG_INFO("=== MainComponent Constructor COMPLETE ===");
    }
    catch (const std::exception& e) {
        LOG_ERROR("EXCEPTION in MainComponent constructor: " + juce::String(e.what()));
        juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::WarningIcon,
            "Startup Error", 
            "Error in MainComponent: " + juce::String(e.what()));
    }
    catch (...) {
        LOG_ERROR("UNKNOWN EXCEPTION in MainComponent constructor");
        juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::WarningIcon,
            "Startup Error", 
            "Unknown error in MainComponent constructor");
    }
}

MainComponent::~MainComponent() 
{ 
    LOG_INFO("MainComponent destructor called");
    stopTimer();
    mainTabs.setLookAndFeel(nullptr);
}

void MainComponent::restoreIOSettings() 
{ 
    LOG_INFO("=== MainComponent::restoreIOSettings START ===");
    try {
        if (ioPage) {
            ioPage->restoreSavedSettings();
            LOG_INFO("=== MainComponent::restoreIOSettings COMPLETE ===");
        } else {
            LOG_ERROR("IOPage is null in restoreIOSettings");
        }
    }
    catch (const std::exception& e) {
        LOG_ERROR("EXCEPTION in restoreIOSettings: " + juce::String(e.what()));
    }
    catch (...) {
        LOG_ERROR("UNKNOWN EXCEPTION in restoreIOSettings");
    }
}

void MainComponent::paint(juce::Graphics& g) 
{ 
    g.fillAll(juce::Colour(0xFF202020)); 
}

void MainComponent::resized()
{
    auto bounds = getLocalBounds();
    auto rightColumn = bounds.removeFromRight(60);
    auto headerHeight = 60;
    header.setBounds(bounds.removeFromTop(headerHeight));
    mainTabs.setBounds(bounds);

    int stripY = headerHeight + (60 - 24) / 2;
    int rightEdge = bounds.getWidth() - 10;
    recordButton.setBounds(rightEdge - 80, stripY, 80, 24);
    downloadWavButton.setBounds(rightEdge - 80 - 120 - 5, stripY, 120, 24);
    recordButton.toFront(true); 
    downloadWavButton.toFront(true);

    rightColumn.removeFromTop(headerHeight);
    masterVolumeLabel.setBounds(rightColumn.removeFromTop(20).reduced(2));
    masterMeter.setBounds(rightColumn.removeFromTop(160).reduced(8, 0));
    rightColumn.removeFromTop(10);
    masterVolumeSlider.setBounds(rightColumn.removeFromTop(250).withSizeKeepingCentre(40, 250));
}

void MainComponent::handleRecordClick()
{
    if (!RegistrationManager::getInstance().isProMode())
    {
        juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::InfoIcon, 
            "Demo Mode", "Recording is disabled in Demo Mode.\nPlease register to unlock.");
        return;
    }

    if (isRecording) {
        juce::NativeMessageBox::showYesNoBox(juce::AlertWindow::QuestionIcon, "Stop Recording", "Stop recording?", this,
            juce::ModalCallbackFunction::create([this](int result) { if (result == 1) stopRecording(); }));
    } else {
        if (showDownloads) { showDownloads = false; downloadWavButton.setVisible(false);
        }
        juce::NativeMessageBox::showYesNoBox(juce::AlertWindow::QuestionIcon, "Start Recording", "Start recording?", this,
            juce::ModalCallbackFunction::create([this](int result) { if (result == 1) startRecording(); }));
    }
}

void MainComponent::startRecording() 
{ 
    if (audioEngine.startRecording()) { 
        isRecording = true;
        recordButton.setColour(juce::TextButton::buttonColourId, juce::Colours::white); 
        recordButton.setColour(juce::TextButton::textColourOffId, juce::Colour(0xFF8B0000)); 
        startTimer(500); 
    } else { 
        juce::AlertWindow::showMessageBoxAsync(juce::AlertWindow::WarningIcon, "Error", "Could not start recording.");
    } 
}

void MainComponent::stopRecording() 
{ 
    audioEngine.stopRecording(); 
    isRecording = false; 
    stopTimer(); 
    recordButton.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF8B0000)); 
    recordButton.setColour(juce::TextButton::textColourOffId, juce::Colours::white); 
    showDownloads = true;
    downloadWavButton.setVisible(true); 
}

void MainComponent::timerCallback() 
{ 
    recordFlickerState = !recordFlickerState;
    if (recordFlickerState) 
        recordButton.setColour(juce::TextButton::textColourOffId, juce::Colour(0xFF8B0000));
    else 
        recordButton.setColour(juce::TextButton::textColourOffId, juce::Colours::lightgrey);
}

void MainComponent::downloadRecording() 
{ 
    juce::File r = audioEngine.getLastRecordingFile(); 
    if (!r.existsAsFile()) return; 
    
    auto c = std::make_shared<juce::FileChooser>("Save", juce::File::getSpecialLocation(juce::File::userMusicDirectory), "*.wav");
    c->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles, 
        [this, r, c](const juce::FileChooser& fc) { 
            juce::File d = fc.getResult(); 
            if (d != juce::File{}) 
                exportAudioFile(r, d); 
        }
    );
}

void MainComponent::exportAudioFile(const juce::File& s, const juce::File& d) 
{ 
    auto& formats = audioEngine.getFormatManager(); 
    std::unique_ptr<juce::AudioFormatReader> reader(formats.createReaderFor(s));
    if (!reader) return; 
    
    juce::WavAudioFormat df; 
    std::unique_ptr<juce::FileOutputStream> os(new juce::FileOutputStream(d)); 
    if(os->failedToOpen()) return; 
    
    // UPDATED: Writer now configured for 44.1kHz and 24-bit
    std::unique_ptr<juce::AudioFormatWriter> w(df.createWriterFor(os.get(), 44100.0, 2, 24, {}, 0)); 
    if(!w) return; 
    os.release();
    
    juce::AudioFormatReaderSource rs(reader.get(), false); 
    // Resample from Source Rate to 44100Hz
    juce::ResamplingAudioSource res(&rs, false, 2); 
    res.setResamplingRatio(reader->sampleRate / 44100.0); 
    res.prepareToPlay(512, 44100.0); 
    
    juce::AudioBuffer<float> b(2, 2048); 
    juce::AudioSourceChannelInfo i(&b, 0, 2048);
    juce::int64 total = (juce::int64)((double)reader->lengthInSamples / (reader->sampleRate/44100.0)); 
    juce::int64 done=0; 
    
    while(done<total){ 
        int n=juce::jmin((juce::int64)2048, total-done);
        i.numSamples=n; 
        b.clear(); 
        res.getNextAudioBlock(i); 
        if(!w->writeFromAudioSampleBuffer(b,0,n)) break; 
        done+=n; 
    } 
    
    juce::AlertWindow::showMessageBoxAsync(juce::AlertWindow::InfoIcon, "Success", "Saved!");
}

float MainComponent::sliderValueToDb(double v) 
{ 
    return v <= 0.0 ? -100.0f : static_cast<float>((v - 0.5) * 44.0);
}

void MainComponent::savePreset() 
{ 
    auto c = std::make_shared<juce::FileChooser>("Save", juce::File::getSpecialLocation(juce::File::userDocumentsDirectory), "*.onspreset", true);
    c->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles, 
        [this, c](const juce::FileChooser& fc) { 
            auto f = fc.getResult(); 
            if (f != juce::File{}) 
                if (presetManager.savePreset(f)) 
                    header.setPresetName(presetManager.getCurrentPresetName()); 
        }
    );
}

void MainComponent::loadPreset() 
{ 
    auto c = std::make_shared<juce::FileChooser>("Load", juce::File::getSpecialLocation(juce::File::userDocumentsDirectory), "*.onspreset", true);
    c->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles, 
        [this, c](const juce::FileChooser& fc) { 
            auto f = fc.getResult(); 
            if (f != juce::File{}) 
                if (presetManager.loadPreset(f)) { 
                    header.setPresetName(presetManager.getCurrentPresetName()); 
            
                    if (vocalsPage) 
                        vocalsPage->updateAllControlsFromEngine(); 
                } 
        }
    );
}



--------------------------------------------------------------------------------
File: src/UI/MainComponent.h
Size: 1.66 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include "../AudioEngine.h"
#include "../PresetManager.h"
#include "../IOSettingsManager.h"
#include "HeaderBar.h"
#include "StyledSlider.h" 
#include "MasterMeter.h" 

class IOPage;
class VocalsPage;
class MediaPage;

class MainComponent : public juce::Component, private juce::Timer
{
public:
    MainComponent();
    ~MainComponent() override;

    void paint(juce::Graphics& g) override;
    void resized() override;
    void restoreIOSettings();

private:
    void timerCallback() override; 

    AudioEngine audioEngine;
    PresetManager presetManager { audioEngine };
    IOSettingsManager ioSettingsManager;
    
    // Task 1: L&F for Tabs
    std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel;

    HeaderBar header;
    juce::TabbedComponent mainTabs { juce::TabbedButtonBar::TabsAtTop };

    std::unique_ptr<IOPage> ioPage;
    std::unique_ptr<VocalsPage> vocalsPage;
    std::unique_ptr<MediaPage> mediaPage;
    
    StyledSlider masterVolumeSlider;
    MidiTooltipLabel masterVolumeLabel;
    MasterMeter masterMeter;

    // Recorder
    MidiTooltipTextButton recordButton;
    juce::TextButton downloadWavButton;
    bool isRecording = false;
    bool recordFlickerState = false;
    bool showDownloads = false;

    void handleRecordClick();
    void startRecording();
    void stopRecording();
    void downloadRecording();
    void exportAudioFile(const juce::File& source, const juce::File& dest);
    float sliderValueToDb(double sliderValue);
    void savePreset();
    void loadPreset();

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainComponent)
};



--------------------------------------------------------------------------------
File: src/UI/ManualComponent.h
Size: 9.88 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

class ManualComponent : public juce::Component
{
public:
    ManualComponent()
    {
        // Define Pages
        pageTitles = { 
            "1. What is OnStage?", "2. I/O Tab", "3. Vocals Tab", 
            "4. Media Tab", "5. MIDI Support", "6. Tooltips", 
            "7. Recording", "8. Registration" 
        };

        pageContents = {
            // 1. Intro
            "WHAT IS ONSTAGE?\n\n"
            "Welcome to OnStage! This application is a professional live performance environment designed specifically for singers, "
            "karaoke hosts, and live streamers. Unlike standard media players or DAWs, OnStage combines a low-latency audio engine "
            "with a dedicated media player and a powerful vocal effects chain in one seamless interface.\n\n"
            "Who is it for?\n"
            "- Performers who need real-time vocal effects without lag.\n"
            "- Karaoke hosts running complex routing setups.\n"
            "- Singers who want to record high-quality demos over backing tracks.\n\n"
            "What makes it special?\n"
            "OnStage runs exclusively on ASIO drivers, ensuring your voice is processed instantly. It integrates backing tracks, "
            "microphones, and effects (Reverb, Delay, Harmonizer, Exciter) into a single, stability-focused workspace.",

            // 2. I/O Tab
            "THE I/O TAB\n\n"
            "This is your control center for audio connections. OnStage is built for ASIO to ensure professional low-latency performance.\n\n"
            "1. ASIO Driver:\n"
            "   Select your audio interface's ASIO driver here. If your hardware is not connected, the system defaults to 'OFF' to prevent crashes. "
            "   Click 'Control Panel' to adjust buffer sizes directly in your driver's settings.\n\n"
            "2. Microphone Inputs:\n"
            "   Route your physical inputs to Mic 1 and Mic 2. You can Mute or Bypass FX for each mic instantly using the toggle buttons.\n\n"
            "3. Backing Tracks Routing:\n"
            "   This section lets you route audio from external software (like virtual cables) or inputs into the OnStage mixer. "
            "   The 'Internal Media Player' is always active on Input 1.\n\n"
            "4. Vocal Settings:\n"
            "   - Latency Correction: If your recordings sound out of sync with the music, adjust this slider to shift the vocals in time.\n"
            "   - Vocal Boost: Adds gain to your vocals specifically in the recording file, ensuring you are heard clearly over loud backing tracks.",

            // 3. Vocals Tab
            "THE VOCALS TAB\n\n"
            "This is the heart of your sound. Each microphone has its own dedicated chain:\n\n"
            "- Preamp: Controls the initial input gain.\n"
            "- Exciter (Air): Adds high-end sparkle and clarity to dull vocals.\n"
            "- EQ: A 3-band equalizer to shape your tone.\n"
            "- Compressor: Evens out your volume, making quiet parts audible and loud parts controlled.\n\n"
            "Global Effects (Applied to both mics):\n"
            "- Harmonizer: Adds synthesized backing vocals (pitch-shifted copies of your voice).\n"
            "- Reverb: Simulates room acoustics to give your voice space.\n"
            "- Delay: Adds echoes for dramatic effect.\n"
            "- Sidechain (Dynamic EQ): Automatically lowers specific frequencies in the music when you sing, making your voice 'pop' out of the mix.",

            // 4. Media Tab
            "THE MEDIA TAB\n\n"
            "Your built-in DJ booth. This tab handles video and audio playback.\n\n"
            "The Playlist:\n"
            "- Add Files: Supports MP3, WAV, MP4, AVI, and more.\n"
            "- Track Banners: Each track in the list has its own controls. Click the '+' button on a track to reveal Volume, Speed, and Wait Time sliders.\n"
            "- Crossfade (F): Toggle the 'F' button on a track banner. When ON, the 'Wait' slider becomes a Crossfade duration, smoothly blending into the next track.\n\n"
            "Controls:\n"
            "- Play/Pause/Stop: Standard transport controls.\n"
            "- Progress Slider: Scrub through the track.\n"
            "- Video Screen: Displays video content for karaoke files.",

            // 5. MIDI Support
            "MIDI SUPPORT\n\n"
            "OnStage allows you to control almost every knob and button using an external MIDI controller.\n\n"
            "How it works:\n"
            "1. Connect your MIDI device.\n"
            "2. Go to the I/O Tab and select your device in the 'MIDI Input' dropdown.\n"
            "3. Click 'Refresh' if you connected the device after opening the app.\n\n"
            "Mappings are fixed to standard CC numbers to ensure stability. You can see exactly which CC number controls which knob by right-clicking any control (see 'Tooltips').",

            // 6. Tooltips
            "TOOLTIPS & HELP\n\n"
            "Don't remember the MIDI map? No problem!\n\n"
            "Simply RIGHT-CLICK on any knob, slider, or toggle button in the application.\n"
            "A popup bubble will appear telling you exactly what that control does and which MIDI CC number or Note is assigned to it.\n\n"
            "This feature is available everywhere—even on the playlist tracks!",

            // 7. Recording
            "RECORDING\n\n"
            "Capture your performance instantly.\n\n"
            "1. Click the red 'RECORD' button at the top right.\n"
            "2. Sing! The app records the full mix (Vocals + Music + Effects).\n"
            "3. Click 'Stop' when finished.\n"
            "4. A 'Download WAV' button will appear. Click it to save your masterpiece to your computer.\n\n"
            "Tech Note:\n"
            "Recordings are saved as high-quality WAV files. If you find your vocals are slightly delayed in the recording compared to the music (due to system processing time), "
            "go to the I/O Tab and increase the 'Latency Correction' slider until they line up perfectly.",

            // 8. Registration
            "REGISTRATION\n\n"
            "Unlock the full power of OnStage (Pro Mode).\n\n"
            "1. Click the 'REGISTER' button in the top header.\n"
            "2. Copy the 'User ID' shown in the window.\n"
            "3. Go to our website and paste this ID into the box above the 'Buy Now' link.\n"
            "4. Complete the purchase. You will receive a Serial Number on-screen and via email.\n"
            "5. Paste that Serial Number back into the OnStage registration window.\n"
            "6. Click 'Save License File'.\n\n"
            "That's it! You are now a Pro user."
        };

        // Create Navigation Buttons
        for (int i = 0; i < pageTitles.size(); ++i)
        {
            auto* btn = new juce::TextButton();
            btn->setButtonText(juce::String(i + 1));
            btn->setTooltip(pageTitles[i]); // Hover to see page name
            btn->setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF2A2A2A));
            btn->setColour(juce::TextButton::textColourOffId, juce::Colours::white);
            btn->onClick = [this, i] { setPage(i); };
            addAndMakeVisible(btn);
            navButtons.add(btn);
        }

        // Title Header
        addAndMakeVisible(pageHeaderLabel);
        pageHeaderLabel.setFont(juce::Font(22.0f, juce::Font::bold));
        pageHeaderLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37)); // Gold
        pageHeaderLabel.setJustificationType(juce::Justification::centred);

        // Content Area
        addAndMakeVisible(contentView);
        contentView.setMultiLine(true);
        contentView.setReadOnly(true);
        contentView.setCaretVisible(false);
        contentView.setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xFF151515));
        contentView.setColour(juce::TextEditor::textColourId, juce::Colours::white);
        contentView.setColour(juce::TextEditor::outlineColourId, juce::Colours::transparentBlack);
        contentView.setFont(juce::Font(16.0f));

        setSize(600, 500);
        setPage(0); // Load Page 1
    }

    void paint(juce::Graphics& g) override
    {
        g.fillAll(juce::Colour(0xFF202020)); // Background
    }

    void resized() override
    {
        auto area = getLocalBounds().reduced(15);
        
        // Navigation Bar
        auto navArea = area.removeFromTop(30);
        int btnWidth = navArea.getWidth() / navButtons.size();
        for (auto* btn : navButtons)
        {
            btn->setBounds(navArea.removeFromLeft(btnWidth).reduced(2, 0));
        }

        area.removeFromTop(10);
        
        // Page Title
        pageHeaderLabel.setBounds(area.removeFromTop(30));
        
        // Content
        area.removeFromTop(10);
        contentView.setBounds(area);
    }

private:
    void setPage(int index)
    {
        if (index < 0 || index >= pageTitles.size()) return;

        // Update Buttons Visuals
        for (int i = 0; i < navButtons.size(); ++i)
        {
            if (i == index) {
                navButtons[i]->setColour(juce::TextButton::buttonColourId, juce::Colour(0xFFD4AF37)); // Gold
                navButtons[i]->setColour(juce::TextButton::textColourOffId, juce::Colours::black);
            } else {
                navButtons[i]->setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF2A2A2A)); // Dark
                navButtons[i]->setColour(juce::TextButton::textColourOffId, juce::Colours::white);
            }
        }

        // Update Text
        pageHeaderLabel.setText(pageTitles[index], juce::dontSendNotification);
        contentView.setText(pageContents[index]);
        
        // FIX: Pass 'false' to indicate "do not select text" when moving caret
        contentView.moveCaretToTop(false);
    }

    juce::StringArray pageTitles;
    juce::StringArray pageContents;
    juce::OwnedArray<juce::TextButton> navButtons;
    juce::Label pageHeaderLabel;
    juce::TextEditor contentView;
};



--------------------------------------------------------------------------------
File: src/UI/MasterMeter.cpp
Size: 2.25 KB
--------------------------------------------------------------------------------

#include "MasterMeter.h"
#include "../AudioEngine.h"

MasterMeter::MasterMeter(AudioEngine& engine)
    : audioEngine(engine), smoothedLeftLevel(0.0f), smoothedRightLevel(0.0f), leftLevel(0.0f), rightLevel(0.0f)
{
    startTimerHz(30);
}

MasterMeter::~MasterMeter() { stopTimer(); }

void MasterMeter::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    if (bounds.getWidth() <= 0 || bounds.getHeight() <= 0) return;

    float separatorWidth = 2.0f;
    float singleMeterWidth = (bounds.getWidth() - separatorWidth) / 2.0f;
    
    auto leftBounds = bounds.removeFromLeft(singleMeterWidth);
    auto separatorBounds = bounds.removeFromLeft(separatorWidth);
    auto rightBounds = bounds;

    auto drawBar = [&](juce::Rectangle<float> area, float level, const juce::String& label) {
        // Background
        g.setColour(juce::Colour(0xff1a1a1a));
        g.fillRoundedRectangle(area, 3.0f);

        // Gold Bar
        float clampedLevel = juce::jlimit(0.0f, 1.0f, level);
        auto meterHeight = area.getHeight() * clampedLevel;
        auto meterBounds = area.removeFromBottom(meterHeight);

        g.setColour(juce::Colour(0xFFD4AF37)); // Gold
        g.fillRoundedRectangle(meterBounds, 3.0f);

        // Frame
        g.setColour(juce::Colour(0xff333333));
        g.drawRoundedRectangle(area.withHeight(area.getHeight()), 3.0f, 1.0f);

        // Label
        g.setColour(juce::Colours::white);
        g.setFont(10.0f);
        auto labelArea = area.removeFromBottom(15);
        g.drawText(label, labelArea, juce::Justification::centred);
    };

    drawBar(leftBounds, smoothedLeftLevel, "L");
    
    // Separator
    g.setColour(juce::Colour(0xff404040));
    g.fillRect(separatorBounds);
    
    drawBar(rightBounds, smoothedRightLevel, "R");
}

void MasterMeter::resized() {}

void MasterMeter::timerCallback()
{
    leftLevel = audioEngine.getOutputLevel(0);
    rightLevel = audioEngine.getOutputLevel(1);

    auto smooth = [](float current, float target) {
        if (target > current) return current + (target - current) * 0.7f;
        else return current + (target - current) * 0.3f;
    };

    smoothedLeftLevel = smooth(smoothedLeftLevel, leftLevel);
    smoothedRightLevel = smooth(smoothedRightLevel, rightLevel);
    repaint();
}



--------------------------------------------------------------------------------
File: src/UI/MasterMeter.h
Size: 0.67 KB
--------------------------------------------------------------------------------

#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../AudioEngine.h"

class MasterMeter : public juce::Component, public juce::Timer
{
public:
    MasterMeter(AudioEngine& engine);
    ~MasterMeter() override;

    void paint(juce::Graphics& g) override;
    void resized() override;
    void timerCallback() override;

private:
    AudioEngine& audioEngine;
    float leftLevel = 0.0f;
    float rightLevel = 0.0f;
    float smoothedLeftLevel = 0.0f;   // Smoothed left channel
    float smoothedRightLevel = 0.0f;  // Smoothed right channel
    
    juce::Colour getLevelColour(float level) const;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MasterMeter)
};



--------------------------------------------------------------------------------
File: src/UI/MediaPage.cpp
Size: 5.57 KB
--------------------------------------------------------------------------------

// **Changes:** Implemented time formatting and label updates.

#include "MediaPage.h"

MediaPage::MediaPage(AudioEngine& engine, IOSettingsManager& settings) : audioEngine(engine),
    progressSlider(juce::Slider::LinearBar, juce::Slider::NoTextBox) 
{
    videoSurface = std::make_unique<VideoSurfaceComponent>(engine);
    addAndMakeVisible(videoSurface.get());
    
    playlistComponent = std::make_unique<PlaylistComponent>(engine, settings);
    addAndMakeVisible(playlistComponent.get());

    // Transport Controls
    addAndMakeVisible(playPauseBtn);
    playPauseBtn.setButtonText("PLAY");
    playPauseBtn.setMidiInfo("MIDI: Note 15");
    playPauseBtn.onClick = [this] { 
        auto& player = audioEngine.getMediaPlayer();
        if (player.isPlaying()) player.pause();
        else player.play();
    };

    addAndMakeVisible(stopBtn);
    stopBtn.setButtonText("STOP");
    stopBtn.setMidiInfo("MIDI: Note 16");
    stopBtn.onClick = [this] { 
        audioEngine.stopAllPlayback();
        playPauseBtn.setButtonText("PLAY");
        progressSlider.setValue(0.0, juce::dontSendNotification);
    };

    // Sliders & Labels
    addAndMakeVisible(progressSlider);
    progressSlider.setRange(0.0, 1.0, 0.001);
    progressSlider.setColour(juce::Slider::trackColourId, juce::Colour(0xFFD4AF37));
    progressSlider.setColour(juce::Slider::backgroundColourId, juce::Colour(0xFF404040));
    progressSlider.onDragStart = [this] { isUserDraggingSlider = true; };
    progressSlider.onDragEnd = [this] { 
        isUserDraggingSlider = false;
        audioEngine.getMediaPlayer().setPosition((float)progressSlider.getValue());
    };
    progressSlider.onValueChange = [this] {
        if (isUserDraggingSlider) audioEngine.getMediaPlayer().setPosition((float)progressSlider.getValue());
    };

    // Clocks
    addAndMakeVisible(currentTimeLabel);
    currentTimeLabel.setText("00:00", juce::dontSendNotification);
    currentTimeLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    currentTimeLabel.setJustificationType(juce::Justification::centredLeft);
    currentTimeLabel.setFont(juce::Font(14.0f, juce::Font::bold));

    addAndMakeVisible(totalTimeLabel);
    totalTimeLabel.setText("00:00", juce::dontSendNotification);
    totalTimeLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    totalTimeLabel.setJustificationType(juce::Justification::centredRight);
    totalTimeLabel.setFont(juce::Font(14.0f, juce::Font::bold));

    startTimerHz(30);
}

MediaPage::~MediaPage() { stopTimer(); }

juce::String MediaPage::formatTime(double seconds) const
{
    if (seconds < 0) seconds = 0;
    int totalSeconds = (int)seconds;
    int m = totalSeconds / 60;
    int s = totalSeconds % 60;
    return juce::String::formatted("%02d:%02d", m, s);
}

void MediaPage::timerCallback()
{
    auto& player = audioEngine.getMediaPlayer();
    bool isPlaying = player.isPlaying();
    playPauseBtn.setButtonText(isPlaying ? "PAUSE" : "PLAY");
    
    if (!isUserDraggingSlider && isPlaying)
    {
        progressSlider.setValue(player.getPosition(), juce::dontSendNotification);
    }

    // Update Clocks
    // VLC Length is in MS
    double lenMs = (double)player.getLengthMs(); 
    double posRatio = player.getPosition();
    double currentMs = lenMs * posRatio;

    totalTimeLabel.setText(formatTime(lenMs / 1000.0), juce::dontSendNotification);
    currentTimeLabel.setText(formatTime(currentMs / 1000.0), juce::dontSendNotification);
}

void MediaPage::paint(juce::Graphics& g) { g.fillAll(juce::Colour(0xFF000000)); }

void MediaPage::resized()
{
    auto area = getLocalBounds();
    int totalWidth = area.getWidth();
    int playerAreaWidth = (int)(totalWidth * 0.65f);
    auto playerArea = area.removeFromLeft(playerAreaWidth);
    playlistComponent->setBounds(area);
    
    int transportHeight = 30;
    auto transportArea = playerArea.removeFromBottom(transportHeight);
    
    // Bottom Row: Buttons
    playPauseBtn.setBounds(transportArea.removeFromLeft(60).reduced(2));
    stopBtn.setBounds(transportArea.removeFromLeft(60).reduced(2));
    
    // Time & Slider Area (Above Buttons)
    // Actually, design request: Clock Left (Total) and Clock Right (Progress)? 
    // Request: "Clock that shows tracks total length in the left... and another... in the right"
    // Usually Total is on the right, but I will follow instructions: Total Left, Progress Right?
    // "total length in the left... progress in the right" -> Okay.
    
    // Let's create a small strip ABOVE the slider for text? Or beside the slider?
    // "above the time slider"
    
    int sliderHeight = 20;
    int labelHeight = 15;
    
    auto sliderStrip = playerArea.removeFromBottom(sliderHeight + labelHeight + 5); 
    // Strip contains Labels (Top) + Slider (Bottom)
    
    auto labelRow = sliderStrip.removeFromTop(labelHeight);
    totalTimeLabel.setBounds(labelRow.removeFromLeft(60));
    currentTimeLabel.setBounds(labelRow.removeFromRight(60));
    
    progressSlider.setBounds(sliderStrip.reduced(2));

    // Video Area
    int availableWidth = playerArea.getWidth();
    int availableHeight = playerArea.getHeight();
    int targetVideoWidth = availableWidth;
    int targetVideoHeight = (int)(targetVideoWidth * (9.0f / 16.0f));
    if (targetVideoHeight > availableHeight) {
        targetVideoHeight = availableHeight;
        targetVideoWidth = (int)(targetVideoHeight * (16.0f / 9.0f));
    }
    int xOffset = (availableWidth - targetVideoWidth) / 2;
    int yOffset = (availableHeight - targetVideoHeight) / 2;

    videoSurface->setBounds(playerArea.getX() + xOffset, playerArea.getY() + yOffset, targetVideoWidth, targetVideoHeight);
}



--------------------------------------------------------------------------------
File: src/UI/MediaPage.h
Size: 1.10 KB
--------------------------------------------------------------------------------

// **Changes:** Added `currentTimeLabel` and `totalTimeLabel`.

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include "../AudioEngine.h"
#include "../IOSettingsManager.h"
#include "../engine/VideoSurfaceComponent.h"
#include "PlaylistComponent.h"
#include "StyledSlider.h" 

class MediaPage : public juce::Component, private juce::Timer
{
public:
    MediaPage(AudioEngine& engine, IOSettingsManager& settings);
    ~MediaPage() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    void timerCallback() override;
    juce::String formatTime(double seconds) const;

    AudioEngine& audioEngine;
    
    std::unique_ptr<VideoSurfaceComponent> videoSurface;
    std::unique_ptr<PlaylistComponent> playlistComponent;
    
    MidiTooltipTextButton playPauseBtn; 
    MidiTooltipTextButton stopBtn;
    
    StyledSlider progressSlider;
    juce::Label currentTimeLabel; // NEW
    juce::Label totalTimeLabel;   // NEW
    
    bool isUserDraggingSlider = false;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MediaPage)
};



--------------------------------------------------------------------------------
File: src/UI/PlaylistComponent.cpp
Size: 15.02 KB
--------------------------------------------------------------------------------

#include "PlaylistComponent.h"
#include "../RegistrationManager.h"

using namespace juce;

PlaylistComponent::PlaylistComponent(AudioEngine& engine, IOSettingsManager& settings)
    : audioEngine(engine), ioSettings(settings)
{
    addAndMakeVisible(headerLabel);
    headerLabel.setText("PLAYLIST", dontSendNotification);
    headerLabel.setFont(Font(18.0f, Font::bold));
    headerLabel.setColour(Label::textColourId, Colour(0xFFD4AF37)); 
    headerLabel.setJustificationType(Justification::centredLeft);

    addAndMakeVisible(autoPlayToggle);
    autoPlayToggle.setButtonText("Auto-Play");
    autoPlayToggle.setToggleState(true, dontSendNotification);
    autoPlayToggle.setColour(ToggleButton::textColourId, Colours::white);
    autoPlayToggle.setColour(ToggleButton::tickColourId, Colour(0xFFD4AF37));
    autoPlayToggle.onClick = [this] { autoPlayEnabled = autoPlayToggle.getToggleState(); };

    addAndMakeVisible(defaultFolderButton);
    defaultFolderButton.setButtonText("Set Default Folder");
    defaultFolderButton.setColour(TextButton::buttonColourId, Colour(0xFF404040));
    defaultFolderButton.onClick = [this] { setDefaultFolder(); };

    addAndMakeVisible(addTrackButton);
    addTrackButton.setButtonText("Add Files");
    addTrackButton.setColour(TextButton::buttonColourId, Colour(0xFF404040));
    addTrackButton.onClick = [this] {
        File startDir = File::getSpecialLocation(File::userMusicDirectory);
        String savedPath = ioSettings.getMediaFolder();
        if (savedPath.isNotEmpty()) {
            File f(savedPath);
            if (f.isDirectory()) startDir = f;
        }

        auto fc = std::make_shared<FileChooser>("Select Media Files",
            startDir,
            "*.mp3;*.wav;*.aiff;*.flac;*.ogg;*.m4a;*.mp4;*.avi;*.mov;*.mkv;*.webm;*.mpg;*.mpeg", true);
        fc->launchAsync(FileBrowserComponent::openMode | FileBrowserComponent::canSelectMultipleItems,
            [this, fc](const FileChooser& chooser) {
                auto results = chooser.getResults();
                for (auto& file : results)
                    addTrack(file);
            });
    };

    addAndMakeVisible(clearButton);
    clearButton.setButtonText("Clear");
    clearButton.setColour(TextButton::buttonColourId, Colour(0xFF8B0000)); 
    clearButton.onClick = [this] { clearPlaylist(); };

    addAndMakeVisible(saveButton);
    saveButton.setButtonText("Save List");
    saveButton.setColour(TextButton::buttonColourId, Colour(0xFF2A2A2A));
    saveButton.onClick = [this] { savePlaylist(); };

    addAndMakeVisible(loadButton);
    loadButton.setButtonText("Load List");
    loadButton.setColour(TextButton::buttonColourId, Colour(0xFF2A2A2A));
    loadButton.onClick = [this] { loadPlaylist(); };

    addAndMakeVisible(viewport);
    viewport.setScrollBarsShown(true, false);
    
    viewport.setViewedComponent(&listContainer, false);

    startTimerHz(30);
}

PlaylistComponent::~PlaylistComponent()
{
    stopTimer();
    banners.clear();
}

void PlaylistComponent::paint(Graphics& g)
{
    g.fillAll(Colour(0xFF222222));
}

void PlaylistComponent::resized()
{
    auto area = getLocalBounds().reduced(12);
    auto row1 = area.removeFromTop(35);
    headerLabel.setBounds(row1.removeFromLeft(120).reduced(5, 0));
    autoPlayToggle.setBounds(row1.removeFromRight(100).reduced(5, 0));
    auto rowFolder = area.removeFromTop(35);
    defaultFolderButton.setBounds(rowFolder.reduced(2));
    auto row3 = area.removeFromTop(40);
    int numButtons = 4;
    int btnWidth = row3.getWidth() / numButtons;
    
    addTrackButton.setBounds(row3.removeFromLeft(btnWidth).reduced(2));
    clearButton.setBounds(row3.removeFromLeft(btnWidth).reduced(2));
    saveButton.setBounds(row3.removeFromLeft(btnWidth).reduced(2));
    loadButton.setBounds(row3.removeFromLeft(btnWidth).reduced(2));
    
    viewport.setBounds(area);
    rebuildList();
}

void PlaylistComponent::setDefaultFolder()
{
    auto fc = std::make_shared<FileChooser>("Choose Default Media Folder",
        File::getSpecialLocation(File::userMusicDirectory));
    fc->launchAsync(FileBrowserComponent::openMode | FileBrowserComponent::canSelectDirectories,
        [this, fc](const FileChooser& chooser) {
            auto result = chooser.getResult();
            if (result.isDirectory()) {
                ioSettings.saveMediaFolder(result.getFullPathName());
                NativeMessageBox::showMessageBoxAsync(AlertWindow::InfoIcon, "Success", 
                    "Default media folder set to:\n" + result.getFileName());
            }
        });
}

void PlaylistComponent::addTrack(const File& file)
{
    if (!RegistrationManager::getInstance().isProMode() && playlist.size() >= 3)
    {
        NativeMessageBox::showMessageBoxAsync(AlertWindow::InfoIcon, 
            "Demo Mode", "Playlist is limited to 3 tracks in Demo Mode.\nPlease register to unlock.");
        return;
    }

    PlaylistItem item;
    item.filePath = file.getFullPathName();
    item.title = file.getFileNameWithoutExtension();
    item.volume = 1.0f;
    item.playbackSpeed = 1.0f;
    item.transitionDelaySec = 0;
    item.isCrossfade = false; 
    item.pitch = 0.0f; // Default pitch
    
    playlist.push_back(item);
    if (currentTrackIndex == -1 && playlist.size() == 1)
    {
        selectTrack(0);
    }
    
    rebuildList();
}

void PlaylistComponent::clearPlaylist()
{
    playlist.clear();
    banners.clear();
    currentTrackIndex = -1;
    audioEngine.stopAllPlayback();
    rebuildList();
}

void PlaylistComponent::removeTrack(int index)
{
    if (index >= 0 && index < (int)playlist.size())
    {
        playlist.erase(playlist.begin() + index);
        if (currentTrackIndex == index) 
        {
            currentTrackIndex = -1;
            audioEngine.stopAllPlayback();
        }
        else if (currentTrackIndex > index)
        {
            currentTrackIndex--;
        }
        
        rebuildList();
    }
}

void PlaylistComponent::selectTrack(int index)
{
    if (index < 0 || index >= (int)playlist.size()) return;

    currentTrackIndex = index;
    hasTriggeredCrossfade = false; 
    
    auto& item = playlist[index];
    audioEngine.stopAllPlayback();
    
    auto& player = audioEngine.getMediaPlayer();
    if (player.loadFile(item.filePath))
    {
        player.setVolume(item.volume);
        player.setRate(item.playbackSpeed);
        audioEngine.setBackingTrackPitch(item.pitch);
    }
    
    updateBannerVisuals();
}

void PlaylistComponent::playTrack(int index)
{
    selectTrack(index);
    audioEngine.getMediaPlayer().play();
}

void PlaylistComponent::rebuildList()
{
    banners.clear();
    listContainer.removeAllChildren();
    
    int y = 0;
    for (size_t i = 0; i < playlist.size(); ++i)
    {
        auto& item = playlist[i];
        // Height increased for extra row
        int currentH = item.isExpanded ? 170 : 44;
        
        auto* banner = new TrackBannerComponent((int)i, item, 
            [this, i] { removeTrack((int)i); }, 
            [this, i] { 
                playlist[i].isExpanded = !playlist[i].isExpanded; 
                rebuildList(); 
            }, 
            [this, i] { playTrack((int)i); }, 
            [this, i](float vol) { 
                if (currentTrackIndex == (int)i) audioEngine.getMediaPlayer().setVolume(vol);
            },
            [this, i](float speed) {
                if (currentTrackIndex == (int)i) audioEngine.getMediaPlayer().setRate(speed);
            },
            [this, i](float pitch) {
                if (currentTrackIndex == (int)i) audioEngine.setBackingTrackPitch(pitch);
            }
        );
        
        banner->setBounds(0, y, viewport.getWidth(), currentH);
        listContainer.addAndMakeVisible(banner);
        banners.add(banner);
        
        y += currentH + 2;
    }
    
    listContainer.setSize(viewport.getWidth(), y + 50);
    updateBannerVisuals();
}

void PlaylistComponent::updateBannerVisuals()
{
    for (int i = 0; i < banners.size(); ++i)
    {
        bool isCurrent = (i == currentTrackIndex);
        bool isPlaying = isCurrent && audioEngine.getMediaPlayer().isPlaying();
        banners[i]->setPlaybackState(isCurrent, isPlaying);
    }
}

void PlaylistComponent::timerCallback()
{
    audioEngine.updateCrossfadeState();
    if (autoPlayEnabled && currentTrackIndex >= 0 && currentTrackIndex < (int)playlist.size())
    {
        auto& player = audioEngine.getMediaPlayer();
        if (player.isPlaying() && !hasTriggeredCrossfade)
        {
            auto& currentItem = playlist[currentTrackIndex];
            int nextIndex = currentTrackIndex + 1;
            
            if (nextIndex < (int)playlist.size())
            {
                auto& nextItem = playlist[nextIndex];
                if (currentItem.isCrossfade)
                {
                    int64_t lenMs = player.getLengthMs();
                    float pos = player.getPosition(); 
                    
                    if (lenMs > 0)
                    {
                        int64_t currentMs = (int64_t)(pos * lenMs);
                        int64_t remainingMs = lenMs - currentMs;
                        int64_t overlapMs = currentItem.transitionDelaySec * 1000;
                        if (overlapMs < 100) overlapMs = 100;
                        if (remainingMs <= overlapMs)
                        {
                            hasTriggeredCrossfade = true;
                            double fadeDuration = (double)currentItem.transitionDelaySec;
                            // Trigger crossfade logic (TODO: update AudioEngine triggerCrossfade to accept pitch)
                            // We set it for next track implicitly via load, but crossfade might need explicit support
                            // For now, next track loads with its settings.
                            audioEngine.triggerCrossfade(nextItem.filePath, fadeDuration, nextItem.volume, nextItem.playbackSpeed);
                            // Set pitch for next track immediately
                            audioEngine.setBackingTrackPitch(nextItem.pitch);
                            
                            currentTrackIndex = nextIndex;
                            hasTriggeredCrossfade = false;
                        }
                    }
                }
                else
                {
                    if (player.hasFinished())
                    {
                        if (!waitingForTransition)
                        {
                            waitingForTransition = true;
                            transitionCountdown = currentItem.transitionDelaySec * 30; 
                        }
                    }
                }
            }
        }
        
        if (waitingForTransition)
        {
            if (transitionCountdown-- <= 0)
            {
                waitingForTransition = false;
                int next = currentTrackIndex + 1;
                if (next < (int)playlist.size())
                {
                    playTrack(next);
                }
            }
        }
    }
    updateBannerVisuals();
}

void PlaylistComponent::savePlaylist()
{
    auto fc = std::make_shared<FileChooser>("Save Playlist",
        File::getSpecialLocation(File::userDocumentsDirectory), "*.json");
    fc->launchAsync(FileBrowserComponent::saveMode | FileBrowserComponent::canSelectFiles,
        [this, fc](const FileChooser& chooser) {
            auto file = chooser.getResult();
            if (file == File{}) return; 

            if (!file.hasFileExtension("json"))
                file = file.withFileExtension("json");

            DynamicObject::Ptr root = new DynamicObject();
            Array<var> tracks;
            
            for (const auto& item : playlist)
            {
                DynamicObject::Ptr obj = new DynamicObject();
                obj->setProperty("path", item.filePath);
                obj->setProperty("title", item.title);
                obj->setProperty("vol", item.volume);
                obj->setProperty("speed", item.playbackSpeed);
                obj->setProperty("pitch", item.pitch); // Save Pitch
                obj->setProperty("delay", item.transitionDelaySec);
                obj->setProperty("xfade", item.isCrossfade);
                tracks.add(obj.get());
            }
            
            root->setProperty("tracks", tracks);
            if (file.replaceWithText(JSON::toString(var(root.get()))))
            {
                NativeMessageBox::showMessageBoxAsync(AlertWindow::InfoIcon, "Success", 
                    "Playlist saved successfully!");
            }
            else
            {
                NativeMessageBox::showMessageBoxAsync(AlertWindow::WarningIcon, "Error", 
                    "Could not write to file.");
            }
        });
}

void PlaylistComponent::loadPlaylist()
{
    auto fc = std::make_shared<FileChooser>("Load Playlist",
        File::getSpecialLocation(File::userDocumentsDirectory), "*.json");
    fc->launchAsync(FileBrowserComponent::openMode | FileBrowserComponent::canSelectFiles,
        [this, fc](const FileChooser& chooser) {
            auto file = chooser.getResult();
            if (!file.existsAsFile()) return;
            
            var json = JSON::parse(file);
            if (auto* root = json.getDynamicObject())
            {
                if (auto* tracks = root->getProperty("tracks").getArray())
                {
                    clearPlaylist();
                    
                    bool isPro = RegistrationManager::getInstance().isProMode();
                    int max = isPro ? 9999 : 3;
                    int count = 0;
                    
                    for (auto& t : *tracks)
                    {
                        if (count >= max) break;
                        
                        if (auto* obj = t.getDynamicObject())
                        {
                            PlaylistItem item;
                            item.filePath = obj->getProperty("path").toString();
                            if (obj->hasProperty("title"))
                                item.title = obj->getProperty("title").toString();
                            else
                                item.ensureTitle();
                            if (File(item.filePath).existsAsFile())
                            {
                                item.volume = (float)obj->getProperty("vol");
                                item.playbackSpeed = (float)obj->getProperty("speed");
                                if (obj->hasProperty("pitch")) item.pitch = (float)obj->getProperty("pitch");
                                item.transitionDelaySec = (int)obj->getProperty("delay");
                                item.isCrossfade = (bool)obj->getProperty("xfade");
                                playlist.push_back(item);
                                count++;
                            }
                        }
                    }
                    
                    rebuildList();
                    if (!playlist.empty()) selectTrack(0);
                }
            }
            else
            {
                NativeMessageBox::showMessageBoxAsync(AlertWindow::WarningIcon, "Error", 
                    "Failed to parse playlist file.");
            }
        });
}



--------------------------------------------------------------------------------
File: src/UI/PlaylistComponent.h
Size: 2.67 KB
--------------------------------------------------------------------------------

// * **Fix:** Updated constructor to take `IOSettingsManager`. * **Fix:** Added `defaultFolderButton`. <!-- end list -->

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include "PlaylistDataStructures.h"
#include "TrackBannerComponent.h"
#include "../AudioEngine.h"
#include "../IOSettingsManager.h"

// ==============================================================================
// Helper: Solid Background Container
// Fixes graphical artifacts (smearing) behind scrolling banners
// ==============================================================================
class PlaylistListContainer : public juce::Component
{
public:
    PlaylistListContainer() { setOpaque(true); }
    
    void paint(juce::Graphics& g) override 
    { 
        // Match the background color of the PlaylistComponent (Task 5 color)
        g.fillAll(juce::Colour(0xFF222222)); 
    }
};

// ==============================================================================
// Playlist Component
// ==============================================================================
class PlaylistComponent : public juce::Component, private juce::Timer
{
public:
    // FIX: Require IOSettingsManager
    PlaylistComponent(AudioEngine& engine, IOSettingsManager& settings);
    ~PlaylistComponent() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

    // Logic
    void addTrack(const juce::File& file);
    void playTrack(int index);
    void removeTrack(int index);
    void selectTrack(int index);
    void clearPlaylist();

private:
    void timerCallback() override;
    void rebuildList();
    void updateBannerVisuals();

    // Save/Load Playlist to specific files
    void savePlaylist();
    void loadPlaylist();
    
    // NEW: Set Default Folder
    void setDefaultFolder();

    AudioEngine& audioEngine;
    IOSettingsManager& ioSettings;
    
    std::vector<PlaylistItem> playlist;
    int currentTrackIndex = -1;
    bool autoPlayEnabled = true;
    
    bool waitingForTransition = false;
    int transitionCountdown = 0;
    
    // Prevents double-triggering crossfade
    bool hasTriggeredCrossfade = false;

    // UI
    juce::Label headerLabel;
    juce::ToggleButton autoPlayToggle;
    
    // NEW BUTTON
    juce::TextButton defaultFolderButton; 
    
    juce::TextButton addTrackButton;
    juce::TextButton clearButton;
    juce::TextButton saveButton;
    juce::TextButton loadButton;

    juce::Viewport viewport;
    
    PlaylistListContainer listContainer; 
    
    juce::OwnedArray<TrackBannerComponent> banners;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PlaylistComponent)
};



--------------------------------------------------------------------------------
File: src/UI/PlaylistDataStructures.h
Size: 0.50 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_core/juce_core.h>

struct PlaylistItem
{
    juce::String filePath;
    juce::String title;
    float volume = 1.0f; // 0.0 - 1.0
    float playbackSpeed = 1.0f; // 0.5 - 2.0
    int transitionDelaySec = 0;
    bool isCrossfade = false; 
    
    // NEW: Pitch (-12 to +12 semitones)
    float pitch = 0.0f; 
    
    bool isExpanded = false;
    
    void ensureTitle()
    {
        if (title.isEmpty())
            title = juce::File(filePath).getFileNameWithoutExtension();
    }
};



--------------------------------------------------------------------------------
File: src/UI/RegistrationComponent.h
Size: 9.47 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "../RegistrationManager.h"

// ==============================================================================
// Info Button & Tooltip Helper
// ==============================================================================
class InfoButton : public juce::Button
{
public:
    InfoButton() : juce::Button("Info")
    {
        setTooltip("Click for registration instructions");
    }

    void paintButton(juce::Graphics& g, bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override
    {
        auto area = getLocalBounds().toFloat();
        g.setColour(juce::Colours::black);
        g.fillEllipse(area);
        
        g.setColour(juce::Colours::white);
        g.setFont(juce::Font(area.getHeight() * 0.7f, juce::Font::bold));
        g.drawText("i", area, juce::Justification::centred, false);
    }
};

class RegistrationComponent : public juce::Component
{
public:
    RegistrationComponent()
    {
        // --- 1. Header Title ---
        addAndMakeVisible(titleLabel);
        titleLabel.setFont(juce::Font(22.0f, juce::Font::bold));
        titleLabel.setColour(juce::Label::textColourId, juce::Colours::white);
        titleLabel.setJustificationType(juce::Justification::centred);

        // --- 2. User ID Section ---
        addAndMakeVisible(userIdLabel);
        userIdLabel.setText("USER ID", juce::dontSendNotification);
        userIdLabel.setFont(juce::Font(20.0f, juce::Font::bold));
        userIdLabel.setColour(juce::Label::textColourId, juce::Colours::black);
        userIdLabel.setJustificationType(juce::Justification::centred);

        addAndMakeVisible(userIdValue);
        userIdValue.setText(RegistrationManager::getInstance().getMachineIDString(), juce::dontSendNotification);
        userIdValue.setFont(juce::Font(18.0f, juce::Font::bold));
        userIdValue.setColour(juce::Label::textColourId, juce::Colours::black);
        userIdValue.setJustificationType(juce::Justification::centred);

        // --- 3. Info Button ---
        addAndMakeVisible(infoButton);
        infoButton.onClick = [this] { showInstructions(); };

        // --- 4. Instructions / Status ---
        addAndMakeVisible(instructionLabel);
        instructionLabel.setFont(juce::Font(13.0f, juce::Font::bold));
        instructionLabel.setColour(juce::Label::textColourId, juce::Colours::white);
        instructionLabel.setJustificationType(juce::Justification::centred);

        // --- 5. Serial Input (Yellow Box) ---
        addAndMakeVisible(serialEditor);
        serialEditor.setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xFFFFFF00)); // Yellow
        serialEditor.setColour(juce::TextEditor::textColourId, juce::Colours::black);
        serialEditor.setColour(juce::TextEditor::outlineColourId, juce::Colours::black);
        serialEditor.setColour(juce::TextEditor::focusedOutlineColourId, juce::Colours::black);
        serialEditor.setFont(juce::Font(20.0f));
        serialEditor.setJustification(juce::Justification::centred);

        // --- 6. Save Button (Dark Grey) ---
        addAndMakeVisible(saveButton);
        saveButton.setButtonText("SAVE LICENSE FILE");
        saveButton.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF333333)); // Dark Grey gradient base
        saveButton.setColour(juce::TextButton::textColourOffId, juce::Colours::white);
        saveButton.onClick = [this] { checkSerial(); };

        // --- 7. Bottom Status ---
        addAndMakeVisible(bottomStatusLabel);
        bottomStatusLabel.setFont(juce::Font(15.0f, juce::Font::bold));
        bottomStatusLabel.setJustificationType(juce::Justification::centred);

        // --- 8. Registered Serial Display (Hidden by default) ---
        addAndMakeVisible(registeredSerialValue);
        registeredSerialValue.setFont(juce::Font(18.0f, juce::Font::plain));
        registeredSerialValue.setColour(juce::Label::textColourId, juce::Colours::black);
        registeredSerialValue.setJustificationType(juce::Justification::centred);
        registeredSerialValue.setVisible(false);

        updateState();
        setSize(320, 300);
    }

    void paint(juce::Graphics& g) override
    {
        // Orange Background (matching screenshot)
        g.fillAll(juce::Colour(0xFFE08020));
        
        // Black border
        g.setColour(juce::Colours::black);
        g.drawRect(getLocalBounds(), 2);
    }

    void resized() override
    {
        auto area = getLocalBounds().reduced(15);
        
        // Title
        titleLabel.setBounds(area.removeFromTop(30));
        area.removeFromTop(5);

        // User ID Label
        userIdLabel.setBounds(area.removeFromTop(20));
        
        // User ID Value + Info Button
        auto idRow = area.removeFromTop(25);
        int idWidth = 100; 
        int infoSize = 20;
        // Center the ID, place button to its right
        userIdValue.setBounds(idRow.withWidth(idWidth).withX((getWidth() - idWidth)/2));
        infoButton.setBounds(userIdValue.getRight() + 5, idRow.getY() + 2, infoSize, infoSize);

        area.removeFromTop(15);

        // Instruction Text
        instructionLabel.setBounds(area.removeFromTop(40));
        area.removeFromTop(5);

        if (RegistrationManager::getInstance().isProMode())
        {
            // REGISTERED LAYOUT
            serialEditor.setVisible(false);
            saveButton.setVisible(false);
            
            registeredSerialValue.setVisible(true);
            registeredSerialValue.setBounds(area.removeFromTop(30));
        }
        else
        {
            // UNREGISTERED LAYOUT
            registeredSerialValue.setVisible(false);
            serialEditor.setVisible(true);
            saveButton.setVisible(true);

            serialEditor.setBounds(area.removeFromTop(35).reduced(20, 0));
            area.removeFromTop(15);
            saveButton.setBounds(area.removeFromTop(45).reduced(5, 0));
        }

        // Bottom Status
        // Push to bottom
        bottomStatusLabel.setBounds(0, getHeight() - 30, getWidth(), 25);
    }

private:
    juce::Label titleLabel;
    juce::Label userIdLabel;
    juce::Label userIdValue;
    InfoButton infoButton;
    juce::Label instructionLabel;
    juce::TextEditor serialEditor;
    juce::TextButton saveButton;
    juce::Label bottomStatusLabel;
    juce::Label registeredSerialValue;

    void updateState()
    {
        bool isRegistered = RegistrationManager::getInstance().isProMode();

        if (isRegistered)
        {
            titleLabel.setText("REGISTRATION COMPLETE", juce::dontSendNotification);
            
            instructionLabel.setText("SERIAL NUMBER:", juce::dontSendNotification);
            
            // Try to load the serial from file to display it
            juce::File licenseFile = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                     .getChildFile("OnStage").getChildFile("user_license.wav");
            // Since we can't easily decode it back to string without the logic here, 
            // we will just show "Active" or if you have the plain text serial stored somewhere.
            // For now, we'll show a placeholder or "LICENSE ACTIVE".
            registeredSerialValue.setText("LICENSE ACTIVE", juce::dontSendNotification);

            bottomStatusLabel.setText("REGISTERED", juce::dontSendNotification);
            bottomStatusLabel.setColour(juce::Label::textColourId, juce::Colours::lightgreen); // Green text
        }
        else
        {
            titleLabel.setText("PLEASE REGISTER", juce::dontSendNotification);
            
            instructionLabel.setText("ENTER YOUR SERIAL HERE, AND\nTHEN SAVE AS LICENSE FILE", juce::dontSendNotification);
            
            bottomStatusLabel.setText("NOT REGISTERED", juce::dontSendNotification);
            bottomStatusLabel.setColour(juce::Label::textColourId, juce::Colours::white);
        }
        
        resized(); // Re-layout based on state
    }

    void checkSerial()
    {
        juce::String input = serialEditor.getText().trim();
        bool success = RegistrationManager::getInstance().tryRegister(input);
        
        if (success)
        {
            updateState();
            juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::InfoIcon, 
                "Success", "Registration Successful!\nThank you for supporting us.");
        }
        else
        {
            juce::NativeMessageBox::showMessageBoxAsync(juce::AlertWindow::WarningIcon, 
                "Registration Failed", "Invalid Serial Number.\nPlease check your ID and Serial.");
        }
    }

    void showInstructions()
    {
        juce::String text = 
            "Upgrading to PRO version:\n\n"
            "1. Copy Your Machine ID\n"
            "2. Complete Your Purchase: Return to purchase page and enter\n"
            "   your Machine ID into the text box above your chosen bundle.\n"
            "3. Click \"BUY NOW\" to complete the payment.\n\n"
            "Receive Your Serial Number:\n"
            "After a successful purchase, your serial number will instantly\n"
            "appear in the box above. It will also be sent to your email.\n\n"
            "Register Your Plugin:\n"
            "Copy the serial number, paste it into the registration window\n"
            "back in your DAW, and click \"Save license file\".\n"
            "4. Done";

        // Show a simple alert window as the tooltip (easiest way to show multiline text modally)
        juce::AlertWindow::showMessageBoxAsync(juce::AlertWindow::InfoIcon, "Registration Instructions", text);
    }
};



--------------------------------------------------------------------------------
File: src/UI/ReverbPanel.h
Size: 6.38 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"
#include "EffectToggleButton.h"
#include "../AudioEngine.h"

class ReverbPanel : public juce::Component, private juce::Timer {
public:
    ReverbPanel(AudioEngine& engine) : audioEngine(engine) {
        lastIrDirectory = juce::File::getSpecialLocation(juce::File::userMusicDirectory);
        goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>(); auto& r = audioEngine.getReverbProcessor(); auto params = r.getParams();
        toggleButton = std::make_unique<EffectToggleButton>(); toggleButton->setMidiInfo("MIDI: Note 26"); 
        toggleButton->setToggleState(!r.isBypassed(), juce::dontSendNotification);
        toggleButton->onClick = [this]() { audioEngine.getReverbProcessor().setBypassed(!toggleButton->getToggleState()); };
        addAndMakeVisible(toggleButton.get());
        addAndMakeVisible(titleLabel); titleLabel.setText("Convolution Reverb", juce::dontSendNotification);
        titleLabel.setFont(juce::Font(18.0f, juce::Font::bold)); titleLabel.setColour(juce::Label::textColourId, juce::Colour(0xFFD4AF37)); titleLabel.setJustificationType(juce::Justification::centredLeft);
        addAndMakeVisible(loadButton); loadButton.setButtonText("Load IR File"); loadButton.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF404040)); loadButton.setColour(juce::TextButton::textColourOffId, juce::Colour(0xFFD4AF37)); loadButton.onClick = [this]() { openIrFile(); };
        addAndMakeVisible(irNameLabel); irNameLabel.setText(r.getCurrentIrName(), juce::dontSendNotification); irNameLabel.setJustificationType(juce::Justification::centred); irNameLabel.setColour(juce::Label::textColourId, juce::Colours::lightgrey); irNameLabel.setColour(juce::Label::backgroundColourId, juce::Colour(0xFF202020)); irNameLabel.setColour(juce::Label::outlineColourId, juce::Colour(0xFF404040));
        auto cS = [&](std::unique_ptr<VerticalSlider>& s, const juce::String& n, int cc, double min, double max, double v, const juce::String& suf) {
            s = std::make_unique<VerticalSlider>(); s->setLabelText(n); s->setMidiInfo("MIDI: CC " + juce::String(cc));
            s->setRange(min, max, (max-min)/100.0); s->setValue(v); s->setTextValueSuffix(suf);
            s->getSlider().setLookAndFeel(goldenLookAndFeel.get()); s->getSlider().onValueChange = [this]() { updateReverb(); };
            addAndMakeVisible(s.get());
        };
        cS(wetSlider, "Wet Level", 28, 0.0, 10.0, params.wetGain, "");
        cS(lowCutSlider, "Low Cut", 37, 20.0, 1000.0, params.lowCutHz, " Hz");
        cS(highCutSlider, "High Cut", 38, 1000.0, 20000.0, params.highCutHz, " Hz");
        startTimerHz(15);
    }
    ~ReverbPanel() override { stopTimer(); wetSlider->getSlider().setLookAndFeel(nullptr); lowCutSlider->getSlider().setLookAndFeel(nullptr); highCutSlider->getSlider().setLookAndFeel(nullptr); }
    void paint(juce::Graphics& g) override { g.fillAll(juce::Colour(0xFF1A1A1A)); g.setColour(juce::Colour(0xFF404040)); g.drawRect(getLocalBounds(), 2); g.setColour(juce::Colour(0xFF2A2A2A)); g.fillRect(getLocalBounds().reduced(10)); }
    void resized() override {
        auto area = getLocalBounds().reduced(15);
        auto topRow = area.removeFromTop(40);
        toggleButton->setBounds(topRow.removeFromRight(40).withSizeKeepingCentre(40, 40));
        titleLabel.setBounds(topRow);
        area.removeFromTop(10);
        auto irArea = area.removeFromLeft(140);
        loadButton.setBounds(irArea.removeFromTop(30).reduced(5)); irArea.removeFromTop(5); irNameLabel.setBounds(irArea.removeFromTop(30).reduced(5));
        int numSliders = 3; int sliderWidth = 60; int spacing = 40;
        int totalW = (numSliders * sliderWidth) + ((numSliders - 1) * spacing);
        int startX = area.getX() + (area.getWidth() - totalW) / 2;
        auto sArea = area.withX(startX).withWidth(totalW);
        wetSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        lowCutSlider->setBounds(sArea.removeFromLeft(sliderWidth)); sArea.removeFromLeft(spacing);
        highCutSlider->setBounds(sArea.removeFromLeft(sliderWidth));
    }
    void updateFromPreset() { auto& r = audioEngine.getReverbProcessor(); auto p = r.getParams(); toggleButton->setToggleState(!r.isBypassed(), juce::dontSendNotification); wetSlider->setValue(p.wetGain, juce::dontSendNotification); lowCutSlider->setValue(p.lowCutHz, juce::dontSendNotification); highCutSlider->setValue(p.highCutHz, juce::dontSendNotification); irNameLabel.setText(r.getCurrentIrName(), juce::dontSendNotification); }
private:
    void timerCallback() override { auto p = audioEngine.getReverbProcessor().getParams(); if (!wetSlider->getSlider().isMouseOverOrDragging()) wetSlider->setValue(p.wetGain, juce::dontSendNotification); if (!lowCutSlider->getSlider().isMouseOverOrDragging()) lowCutSlider->setValue(p.lowCutHz, juce::dontSendNotification); if (!highCutSlider->getSlider().isMouseOverOrDragging()) highCutSlider->setValue(p.highCutHz, juce::dontSendNotification); bool shouldBeOn = !audioEngine.getReverbProcessor().isBypassed(); if (toggleButton->getToggleState() != shouldBeOn) toggleButton->setToggleState(shouldBeOn, juce::dontSendNotification); }
    void updateReverb() { ReverbProcessor::Params p = audioEngine.getReverbProcessor().getParams(); p.wetGain = wetSlider->getValue(); p.lowCutHz = lowCutSlider->getValue(); p.highCutHz = highCutSlider->getValue(); audioEngine.getReverbProcessor().setParams(p); }
    void openIrFile() { auto chooser = std::make_shared<juce::FileChooser>("Load Impulse Response", lastIrDirectory, "*.wav;*.aiff;*.flac"); chooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles, [this, chooser](const juce::FileChooser& fc) { auto file = fc.getResult(); if (file.existsAsFile()) { lastIrDirectory = file.getParentDirectory(); auto p = audioEngine.getReverbProcessor().getParams(); p.irFilePath = file.getFullPathName(); audioEngine.getReverbProcessor().setParams(p); irNameLabel.setText(file.getFileNameWithoutExtension(), juce::dontSendNotification); } }); }
    AudioEngine& audioEngine; std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel; std::unique_ptr<EffectToggleButton> toggleButton; juce::Label titleLabel; juce::TextButton loadButton; juce::Label irNameLabel; juce::File lastIrDirectory; std::unique_ptr<VerticalSlider> wetSlider, lowCutSlider, highCutSlider;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ReverbPanel)
};



--------------------------------------------------------------------------------
File: src/UI/SignalLed.h
Size: 1.19 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

class SignalLed : public juce::Component
{
public:
    SignalLed() { setOpaque(false); }

    void setOn(bool shouldBeOn)
    {
        if (isOn != shouldBeOn)
        {
            isOn = shouldBeOn;
            repaint();
        }
    }

    void paint(juce::Graphics& g) override
    {
        // Draw centered
        auto bounds = getLocalBounds().toFloat().reduced(3.0f);
        float size = juce::jmin(bounds.getWidth(), bounds.getHeight());
        auto r = bounds.withSizeKeepingCentre(size, size);
        
        // Base color (Bright Green if ON, Dark Green if OFF)
        g.setColour(isOn ? juce::Colour(0xFF00FF00) : juce::Colour(0xFF002200));
        g.fillEllipse(r);
        
        // Glow effect when ON
        if (isOn)
        {
            g.setGradientFill(juce::ColourGradient(
                juce::Colours::white.withAlpha(0.8f), r.getCentre(),
                juce::Colour(0xFF00FF00).withAlpha(0.0f), r.getTopLeft(),
                true));
            g.fillEllipse(r);
        }
        
        // Border
        g.setColour(juce::Colours::black);
        g.drawEllipse(r, 1.0f);
    }

private:
    bool isOn = false;
};



--------------------------------------------------------------------------------
File: src/UI/StyledSlider.h
Size: 14.31 KB
--------------------------------------------------------------------------------

// **Changes:** 1.  Included `LongPressDetector.h`. 2.  Updated `StyledSlider`, `MidiTooltipToggleButton`, `MidiTooltipTextButton`, and `MidiTooltipLabel` to inherit `LongPressDetector`. 3.  Implemented `onLongPress()` to show the tooltip. 4.  Updated mouse handlers to call `handleMouseDown`, `handleMouseDrag`, etc. <!-- end list -->

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include "LongPressDetector.h"

class GoldenSliderLookAndFeel : public juce::LookAndFeel_V4
{
public:
    GoldenSliderLookAndFeel()
    {
        setColour(juce::Slider::thumbColourId, juce::Colour(0xffd4af37));
        setColour(juce::Slider::trackColourId, juce::Colour(0xff202020)); 
        setColour(juce::Slider::backgroundColourId, juce::Colour(0xff202020));
        setColour(juce::ScrollBar::thumbColourId, juce::Colour(0xffd4af37)); 
        setColour(juce::ScrollBar::trackColourId, juce::Colour(0xff1a1a1a));
        setColour(juce::ScrollBar::backgroundColourId, juce::Colour(0xff1a1a1a));
        setColour(juce::ComboBox::backgroundColourId, juce::Colour(0xFFD4AF37)); 
        setColour(juce::ComboBox::textColourId, juce::Colours::black); 
        setColour(juce::ComboBox::arrowColourId, juce::Colours::black);
        setColour(juce::ComboBox::outlineColourId, juce::Colours::black);
        setColour(juce::PopupMenu::backgroundColourId, juce::Colour(0xFFD4AF37));
        setColour(juce::PopupMenu::textColourId, juce::Colours::black);
        setColour(juce::PopupMenu::highlightedBackgroundColourId, juce::Colours::black);
        setColour(juce::PopupMenu::highlightedTextColourId, juce::Colour(0xFFD4AF37));
        setColour(juce::TabbedButtonBar::frontOutlineColourId, juce::Colours::transparentBlack);
    }

    int getTabButtonOverlap (int) override { return 0; }
    int getTabButtonSpaceAroundImage () override { return 0; }

    void drawTabButton (juce::TabBarButton& button, juce::Graphics& g, bool isMouseOver, bool isMouseDown) override
    {
        auto activeArea = button.getActiveArea();
        const auto isFrontTab = button.isFrontTab();
        
        juce::Colour bgColour = isFrontTab ? juce::Colour(0xFF202020) : juce::Colour(0xFFD4AF37);
        juce::Colour textColour = isFrontTab ? juce::Colour(0xFFD4AF37) : juce::Colours::black;

        g.setColour(bgColour);
        g.fillRect(activeArea);
        
        if (!isFrontTab)
        {
            g.setColour(juce::Colour(0xFF202020)); 
            g.fillRect(activeArea.removeFromRight(1));
        }
        
        g.setColour(textColour);
        g.setFont(juce::Font(16.0f, juce::Font::bold));
        g.drawText(button.getButtonText(), activeArea, juce::Justification::centred, true);
    }

    void drawTabbedButtonBarBackground (juce::TabbedButtonBar& bar, juce::Graphics& g) override {
        g.fillAll(juce::Colour(0xFF202020));
    }
    
    void drawComboBox (juce::Graphics& g, int width, int height, bool, int, int, int, int, juce::ComboBox& box) override {
        auto cornerSize = box.findParentComponentOfClass<juce::GroupComponent>() != nullptr ? 0.0f : 3.0f;
        juce::Rectangle<int> boxBounds (0, 0, width, height);
        g.setColour (findColour(juce::ComboBox::backgroundColourId));
        g.fillRoundedRectangle (boxBounds.toFloat(), cornerSize);
        g.setColour (findColour(juce::ComboBox::outlineColourId));
        g.drawRoundedRectangle (boxBounds.toFloat().reduced (0.5f, 0.5f), cornerSize, 1.0f);
        juce::Path triangle;
        float arrowSize = 10.0f;
        float arrowX = width - 15.0f;
        float arrowY = height * 0.5f;
        triangle.addTriangle(arrowX - arrowSize * 0.5f, arrowY - arrowSize * 0.25f,
                             arrowX + arrowSize * 0.5f, arrowY - arrowSize * 0.25f,
                             arrowX, arrowY + arrowSize * 0.25f);
        g.setColour(findColour(juce::ComboBox::arrowColourId)); 
        g.fillPath(triangle);
    }

    void drawLinearSlider(juce::Graphics& g, int x, int y, int width, int height,
        float sliderPos, float minSliderPos, float maxSliderPos,
        const juce::Slider::SliderStyle style, juce::Slider& slider) override
    {
        bool isVertical = (style == juce::Slider::LinearVertical);
        float trackWidth = isVertical ? (float)width * 0.2f : (float)height * 0.25f;
        trackWidth = juce::jlimit(4.0f, 8.0f, trackWidth);
        juce::Rectangle<float> trackBounds;
        if (isVertical) {
            float centerX = x + width * 0.5f;
            trackBounds = juce::Rectangle<float>(centerX - trackWidth * 0.5f, (float)y + 5, trackWidth, (float)height - 10);
        } else {
            float centerY = y + height * 0.5f;
            trackBounds = juce::Rectangle<float>((float)x + 5, centerY - trackWidth * 0.5f, (float)width - 10, trackWidth);
        }
        g.setColour(juce::Colour(0xFF151515));
        g.fillRoundedRectangle(trackBounds, trackWidth * 0.5f);
        g.setColour(juce::Colour(0xFF333333));
        g.drawRoundedRectangle(trackBounds, trackWidth * 0.5f, 1.0f);
        juce::Rectangle<float> fillBounds = trackBounds;
        if (isVertical) {
            fillBounds.setTop(sliderPos);
            fillBounds.setBottom(trackBounds.getBottom());
        } else {
            fillBounds.setRight(sliderPos);
            fillBounds.setWidth(sliderPos - trackBounds.getX());
        }
        if (!fillBounds.isEmpty()) {
            g.setColour(juce::Colour(0xFFD4AF37));
            g.fillRoundedRectangle(fillBounds, trackWidth * 0.5f);
        }
        float thumbSize = isVertical ? (float)width * 0.7f : (float)height * 0.7f;
        thumbSize = juce::jlimit(14.0f, 20.0f, thumbSize);
        float thumbX = isVertical ? x + width * 0.5f - thumbSize * 0.5f : sliderPos - thumbSize * 0.5f;
        float thumbY = isVertical ? sliderPos - thumbSize * 0.5f : y + height * 0.5f - thumbSize * 0.5f;
        juce::Rectangle<float> thumbBounds(thumbX, thumbY, thumbSize, thumbSize);
        g.setColour(juce::Colour(0xFFD4AF37));
        g.fillEllipse(thumbBounds);
        g.setColour(juce::Colours::black);
        g.fillEllipse(thumbBounds.reduced(3.0f)); 
    }

    void drawScrollbar (juce::Graphics& g, juce::ScrollBar& scrollbar, int x, int y, int width, int height,
                        bool isScrollbarVertical, int thumbStartPosition, int thumbSize,
                        bool, bool) override
    {
        g.fillAll (findColour (juce::ScrollBar::backgroundColourId));
        juce::Rectangle<int> thumbBounds;
        if (isScrollbarVertical) thumbBounds = { x + 2, thumbStartPosition, width - 4, thumbSize };
        else thumbBounds = { thumbStartPosition, y + 2, thumbSize, height - 4 };
        g.setColour(findColour(juce::ScrollBar::thumbColourId)); 
        g.fillRoundedRectangle(thumbBounds.toFloat(), 4.0f);
    }
};

// --- TOOLTIP HELPERS ---
class TooltipAutoHideTimer : public juce::Timer {
public: TooltipAutoHideTimer(juce::Component* t) : tooltip(t) {}
    void timerCallback() override { stopTimer(); if (tooltip) tooltip->setVisible(false); }
private: juce::Component* tooltip;
};
class MidiTooltipHelper : public juce::BubbleMessageComponent {
public: MidiTooltipHelper() : hideTimer(this) { setAlwaysOnTop(true); addToDesktop(0); }
    void show(juce::Component* owner, const juce::String& text) {
        juce::AttributedString attString;
        attString.append(text, juce::Font(15.0f, juce::Font::bold), juce::Colours::white);
        showAt(owner->getScreenBounds(), attString, 2000, true, false);
        hideTimer.startTimer(2500);
    }
private: TooltipAutoHideTimer hideTimer;
};
inline void showMidiTooltip(juce::Component* c, const juce::String& m) {
    if (m.isEmpty()) return; static std::unique_ptr<MidiTooltipHelper> t;
    if (!t) t = std::make_unique<MidiTooltipHelper>(); t->show(c, m);
}

// --- WIDGET WRAPPERS ---

class StyledSlider : public juce::Slider, public LongPressDetector {
public:
    StyledSlider(juce::Slider::SliderStyle style = juce::Slider::RotaryVerticalDrag, juce::Slider::TextEntryBoxPosition textBox = juce::Slider::TextBoxBelow)
        : juce::Slider(style, textBox) { setLookAndFeel(&goldenLookAndFeel); setTextBoxStyle(textBox, false, 60, 18); }
    ~StyledSlider() override { setLookAndFeel(nullptr); }
    void setMidiInfo(const juce::String& info) { midiInfo = info; }
    
    // Long Press: Show Tooltip
    void onLongPress() override {
        if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo);
    }

    void mouseDown(const juce::MouseEvent& e) override {
        if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; }
        handleMouseDown(e); // Touch Support
        juce::Slider::mouseDown(e);
    }
    void mouseUp(const juce::MouseEvent& e) override { 
        handleMouseUp(e); // Stop timer
        if (e.mods.isRightButtonDown() || isLongPressTriggered) return; // Block if long press occurred
        juce::Slider::mouseUp(e); 
    }
    void mouseDrag(const juce::MouseEvent& e) override { 
        handleMouseDrag(e); // Stop timer if moved
        if (e.mods.isRightButtonDown() || isLongPressTriggered) return; 
        juce::Slider::mouseDrag(e); 
    }
private:
    GoldenSliderLookAndFeel goldenLookAndFeel;
    juce::String midiInfo;
};

class VerticalSlider : public juce::Component {
public:
    VerticalSlider() {
        slider.setSliderStyle(juce::Slider::LinearVertical);
        slider.setTextBoxStyle(juce::Slider::TextBoxBelow, false, 70, 20);
        addAndMakeVisible(slider);
        label.setJustificationType(juce::Justification::centred);
        label.setColour(juce::Label::textColourId, juce::Colours::white);
        addAndMakeVisible(label);
    }
    StyledSlider& getSlider() { return slider; }
    void setLabelText(const juce::String& text) { label.setText(text, juce::dontSendNotification); }
    void setRange(double min, double max, double interval = 0) { slider.setRange(min, max, interval); }
    void setValue(double value, juce::NotificationType notification = juce::dontSendNotification) { slider.setValue(value, notification); }
    double getValue() const { return slider.getValue(); }
    void setTextValueSuffix(const juce::String& suffix) { slider.setTextValueSuffix(suffix); }
    void setNumDecimalPlacesToDisplay(int places) { slider.setNumDecimalPlacesToDisplay(places); }
    void setSkewFactor(double factor) { slider.setSkewFactorFromMidPoint(factor); }
    void setMidiInfo(const juce::String& info) { midiInfo = info; slider.setMidiInfo(info); label.setMidiInfo(info); }
    void resized() override { auto area = getLocalBounds(); label.setBounds(area.removeFromTop(20)); slider.setBounds(area); }
private:
    StyledSlider slider;
    // Label also needs long press support for tooltip
    class InternalLabel : public juce::Label, public LongPressDetector {
    public: 
        void setMidiInfo(const juce::String& info) { midiInfo = info; }
        void onLongPress() override { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); }
        void mouseDown(const juce::MouseEvent& e) override { 
            if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; } 
            handleMouseDown(e);
            juce::Label::mouseDown(e); 
        }
        void mouseUp(const juce::MouseEvent& e) override { 
            handleMouseUp(e); 
            if (e.mods.isRightButtonDown() || isLongPressTriggered) return;
            juce::Label::mouseUp(e); 
        }
        void mouseDrag(const juce::MouseEvent& e) override {
            handleMouseDrag(e);
            if (!isLongPressTriggered) juce::Label::mouseDrag(e);
        }
        juce::String midiInfo;
    };
    InternalLabel label;
    juce::String midiInfo;
};

class MidiTooltipToggleButton : public juce::ToggleButton, public LongPressDetector {
public: MidiTooltipToggleButton(const juce::String& text = "") : juce::ToggleButton(text) {}
    void setMidiInfo(const juce::String& info) { midiInfo = info; }
    void onLongPress() override { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); }
    void mouseDown(const juce::MouseEvent& e) override { 
        if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; } 
        handleMouseDown(e);
        juce::ToggleButton::mouseDown(e);
    }
    void mouseUp(const juce::MouseEvent& e) override { 
        handleMouseUp(e);
        if (e.mods.isRightButtonDown() || isLongPressTriggered) return; 
        juce::ToggleButton::mouseUp(e); 
    }
    void mouseDrag(const juce::MouseEvent& e) override { handleMouseDrag(e); if (!isLongPressTriggered) juce::ToggleButton::mouseDrag(e); }
private: juce::String midiInfo;
};

class MidiTooltipTextButton : public juce::TextButton, public LongPressDetector {
public: MidiTooltipTextButton(const juce::String& text = "") : juce::TextButton(text) {}
    void setMidiInfo(const juce::String& info) { midiInfo = info; }
    void onLongPress() override { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); }
    void mouseDown(const juce::MouseEvent& e) override { 
        if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; } 
        handleMouseDown(e);
        juce::TextButton::mouseDown(e);
    }
    void mouseUp(const juce::MouseEvent& e) override { 
        handleMouseUp(e);
        if (e.mods.isRightButtonDown() || isLongPressTriggered) return; 
        juce::TextButton::mouseUp(e); 
    }
    void mouseDrag(const juce::MouseEvent& e) override { handleMouseDrag(e); if (!isLongPressTriggered) juce::TextButton::mouseDrag(e); }
private: juce::String midiInfo;
};

class MidiTooltipLabel : public juce::Label, public LongPressDetector {
public: MidiTooltipLabel(const juce::String& name = "", const juce::String& text = "") : juce::Label(name, text) {}
    void setMidiInfo(const juce::String& info) { midiInfo = info; }
    void onLongPress() override { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); }
    void mouseDown(const juce::MouseEvent& e) override { 
        if (e.mods.isRightButtonDown()) { if (midiInfo.isNotEmpty()) showMidiTooltip(this, midiInfo); return; } 
        handleMouseDown(e);
        juce::Label::mouseDown(e);
    }
    void mouseUp(const juce::MouseEvent& e) override { handleMouseUp(e); if (e.mods.isRightButtonDown() || isLongPressTriggered) return; juce::Label::mouseUp(e); }
    void mouseDrag(const juce::MouseEvent& e) override { handleMouseDrag(e); if (!isLongPressTriggered) juce::Label::mouseDrag(e); }
private: juce::String midiInfo;
};



--------------------------------------------------------------------------------
File: src/UI/TrackBannerComponent.cpp
Size: 9.19 KB
--------------------------------------------------------------------------------

#include "TrackBannerComponent.h"

TrackBannerComponent::TrackBannerComponent(int index, PlaylistItem& item, 
                                           std::function<void()> onRemove,
                                           std::function<void()> onExpandToggle,
                                           std::function<void()> onSelect,
                                           std::function<void(float)> onVolChange,
                                           std::function<void(float)> onSpeedChange,
                                           std::function<void(float)> onPitchChange)
    : trackIndex(index), itemData(item), 
      onRemoveCallback(onRemove), 
      onExpandToggleCallback(onExpandToggle), onSelectCallback(onSelect),
      onVolChangeCallback(onVolChange), onSpeedChangeCallback(onSpeedChange),
      onPitchChangeCallback(onPitchChange)
{
    addAndMakeVisible(indexLabel);
    indexLabel.setText(juce::String(index + 1), juce::dontSendNotification);
    indexLabel.setJustificationType(juce::Justification::centred);
    indexLabel.setColour(juce::Label::textColourId, juce::Colours::black);
    indexLabel.setInterceptsMouseClicks(false, false); 
    
    addAndMakeVisible(removeButton);
    removeButton.setButtonText("X");
    removeButton.setMidiInfo("Remove Track from Playlist");
    removeButton.setColour(juce::TextButton::buttonColourId, juce::Colours::transparentBlack);
    removeButton.setColour(juce::TextButton::textColourOffId, juce::Colours::red);
    removeButton.onClick = onRemoveCallback;

    addAndMakeVisible(crossfadeButton);
    crossfadeButton.setButtonText("F");
    crossfadeButton.setMidiInfo("Crossfade Mode: When ON, 'Wait' becomes the fade overlap duration.");
    crossfadeButton.setClickingTogglesState(true);
    crossfadeButton.setColour(juce::TextButton::buttonColourId, juce::Colour(0xFF2A2A2A));
    crossfadeButton.setColour(juce::TextButton::textColourOffId, juce::Colours::grey);
    crossfadeButton.setColour(juce::TextButton::buttonOnColourId, juce::Colour(0xFFD4AF37));
    crossfadeButton.setColour(juce::TextButton::textColourOnId, juce::Colours::black);
    crossfadeButton.setToggleState(itemData.isCrossfade, juce::dontSendNotification);
    
    crossfadeButton.onClick = [this] { 
        itemData.isCrossfade = crossfadeButton.getToggleState();
        if (delaySlider) {
            delaySlider->setTextValueSuffix(itemData.isCrossfade ? " s (Fade)" : " s (Wait)");
            delaySlider->setValue(delaySlider->getValue(), juce::dontSendNotification);
        }
    };

    addAndMakeVisible(expandButton);
    expandButton.setButtonText(itemData.isExpanded ? "-" : "+");
    expandButton.setMidiInfo("Show/Hide Controls (Volume, Speed, Wait)");
    expandButton.setColour(juce::TextButton::buttonColourId, juce::Colours::transparentBlack);
    expandButton.onClick = onExpandToggleCallback;

    if (itemData.isExpanded)
    {
        // 1. Volume
        volSlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        volSlider->setMidiInfo("Track Gain (0dB to +22dB)"); 
        volSlider->setRange(0.0, 2.0, 0.01);
        float initSliderVal = 0.0f;
        if (itemData.volume > 0.0001f) {
            float db = juce::Decibels::gainToDecibels(itemData.volume);
            float norm = (db / 44.0f) + 0.5f;
            initSliderVal = juce::jlimit(0.0f, 2.0f, norm * 2.0f);
        }
        volSlider->setValue(initSliderVal, juce::dontSendNotification);
        volSlider->onValueChange = [this] { 
            float sliderVal = (float)volSlider->getValue();
            float linear = 0.0f;
            if (sliderVal > 0.0f) {
                float norm = sliderVal / 2.0f;
                float db = (norm - 0.5f) * 44.0f;
                linear = juce::Decibels::decibelsToGain(db);
            }
            itemData.volume = linear;
            if (onVolChangeCallback) onVolChangeCallback(itemData.volume);
        };
        addAndMakeVisible(volSlider.get());

        // 2. Pitch (NEW)
        pitchSlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        pitchSlider->setMidiInfo("Pitch Shift (-12 to +12 semitones)");
        pitchSlider->setRange(-12.0, 12.0, 1.0); // 25 steps: -12..0..+12
        pitchSlider->setValue(itemData.pitch, juce::dontSendNotification);
        pitchSlider->setTextValueSuffix(" st");
        pitchSlider->onValueChange = [this] {
            itemData.pitch = (float)pitchSlider->getValue();
            if (onPitchChangeCallback) onPitchChangeCallback(itemData.pitch);
        };
        addAndMakeVisible(pitchSlider.get());

        // 3. Speed
        speedSlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        speedSlider->setMidiInfo("Playback Speed (0.1x - 2.1x)");
        speedSlider->setRange(0.1, 2.1, 0.01);
        speedSlider->setValue(itemData.playbackSpeed, juce::dontSendNotification);
        speedSlider->onValueChange = [this] { 
            itemData.playbackSpeed = (float)speedSlider->getValue();
            if (onSpeedChangeCallback) onSpeedChangeCallback(itemData.playbackSpeed);
        };
        addAndMakeVisible(speedSlider.get());

        // 4. Wait/Crossfade
        delaySlider = std::make_unique<StyledSlider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
        delaySlider->setMidiInfo("Transition Wait Time (or Crossfade Length if F is on)");
        delaySlider->setRange(0.0, 30.0, 1.0);
        delaySlider->setValue(itemData.transitionDelaySec, juce::dontSendNotification);
        delaySlider->setTextValueSuffix(itemData.isCrossfade ? " s (Fade)" : " s (Wait)");
        delaySlider->textFromValueFunction = [this](double value) {
            if (itemData.isCrossfade && value > 0) 
                return "-" + juce::String(value, 0) + " s";
            return juce::String(value, 0) + " s";
        };

        delaySlider->onValueChange = [this] { 
            itemData.transitionDelaySec = (int)delaySlider->getValue();
        };
        addAndMakeVisible(delaySlider.get());

        addAndMakeVisible(volLabel); volLabel.setText("Vol", juce::dontSendNotification);
        addAndMakeVisible(pitchLabel); pitchLabel.setText("Pitch", juce::dontSendNotification);
        addAndMakeVisible(speedLabel); speedLabel.setText("Speed", juce::dontSendNotification);
        addAndMakeVisible(delayLabel); delayLabel.setText("Wait", juce::dontSendNotification);
    }
}

void TrackBannerComponent::onLongPress()
{
    showMidiTooltip(this, "Track: " + itemData.title + "\nLeft-Click to Select/Load");
}

void TrackBannerComponent::mouseDown(const juce::MouseEvent& e)
{
    if (e.mods.isRightButtonDown())
    {
        onLongPress();
        return; 
    }
    handleMouseDown(e); 
}

void TrackBannerComponent::mouseUp(const juce::MouseEvent& e)
{
    handleMouseUp(e);
    if (e.mods.isRightButtonDown() || isLongPressTriggered) return;
    if (onSelectCallback) onSelectCallback();
}

void TrackBannerComponent::mouseDrag(const juce::MouseEvent& e)
{
    handleMouseDrag(e);
}

void TrackBannerComponent::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    if (isCurrentTrack) g.setColour(juce::Colour(0xFF152215)); 
    else g.setColour(juce::Colour(0xFF1A1A1A)); 
    g.fillRoundedRectangle(bounds, 5.0f);
    if (isCurrentTrack) {
        g.setColour(juce::Colour(0xFF00FF00));
        g.drawRoundedRectangle(bounds, 5.0f, 2.0f);
    } else {
        g.setColour(juce::Colour(0xFF404040)); 
        g.drawRoundedRectangle(bounds, 5.0f, 1.0f);
    }

    g.setColour(isCurrentTrack ? juce::Colour(0xFF00FF00) : juce::Colour(0xFFD4AF37));
    g.fillEllipse(10, 10, 24, 24);
    
    g.setColour(juce::Colour(0xFFD4AF37)); 
    g.setFont(juce::Font(15.0f, juce::Font::bold));
    auto textArea = getLocalBounds().reduced(5).withTrimmedLeft(40).withTrimmedRight(110).withHeight(34);
    g.drawFittedText(itemData.title, textArea, juce::Justification::centredLeft, 1);
}

void TrackBannerComponent::resized()
{
    auto bounds = getLocalBounds();
    
    indexLabel.setBounds(10, 10, 24, 24);
    expandButton.setBounds(bounds.getWidth() - 30, 10, 20, 20);
    removeButton.setBounds(bounds.getWidth() - 60, 10, 20, 20);
    crossfadeButton.setBounds(bounds.getWidth() - 90, 10, 25, 20);
    
    if (itemData.isExpanded)
    {
        int startY = 44;
        int rowH = 30;
        int labelW = 40;
        
        // 1. Volume
        volLabel.setBounds(10, startY, labelW, rowH);
        volSlider->setBounds(10 + labelW, startY, bounds.getWidth() - 20 - labelW, rowH);
        
        // 2. Pitch
        pitchLabel.setBounds(10, startY + rowH, labelW, rowH);
        pitchSlider->setBounds(10 + labelW, startY + rowH, bounds.getWidth() - 20 - labelW, rowH);

        // 3. Speed
        speedLabel.setBounds(10, startY + rowH * 2, labelW, rowH);
        speedSlider->setBounds(10 + labelW, startY + rowH * 2, bounds.getWidth() - 20 - labelW, rowH);
        
        // 4. Wait
        delayLabel.setBounds(10, startY + rowH * 3, labelW, rowH);
        delaySlider->setBounds(10 + labelW, startY + rowH * 3, bounds.getWidth() - 20 - labelW, rowH);
    }
}

void TrackBannerComponent::setPlaybackState(bool isCurrent, bool isAudioActive)
{
    isCurrentTrack = isCurrent;
    isAudioPlaying = isAudioActive;
    repaint();
}



--------------------------------------------------------------------------------
File: src/UI/TrackBannerComponent.h
Size: 2.02 KB
--------------------------------------------------------------------------------

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include "PlaylistDataStructures.h"
#include "StyledSlider.h"
#include "LongPressDetector.h"

class TrackBannerComponent : public juce::Component, public LongPressDetector
{
public:
    TrackBannerComponent(int index, PlaylistItem& item, 
                         std::function<void()> onRemove,
                         std::function<void()> onExpandToggle,
                         std::function<void()> onSelect,
                         std::function<void(float)> onVolChange,
                         std::function<void(float)> onSpeedChange,
                         std::function<void(float)> onPitchChange); // NEW

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void mouseDown(const juce::MouseEvent& e) override;
    void mouseUp(const juce::MouseEvent& e) override;
    void mouseDrag(const juce::MouseEvent& e) override;
    void onLongPress() override;

    void setPlaybackState(bool isCurrent, bool isAudioActive);
    bool isExpanded() const { return itemData.isExpanded; }

private:
    int trackIndex;
    PlaylistItem& itemData;
    
    bool isCurrentTrack = false;
    bool isAudioPlaying = false;

    std::function<void()> onRemoveCallback;
    std::function<void()> onExpandToggleCallback;
    std::function<void()> onSelectCallback;
    std::function<void(float)> onVolChangeCallback;
    std::function<void(float)> onSpeedChangeCallback;
    std::function<void(float)> onPitchChangeCallback; // NEW

    juce::Label indexLabel;
    MidiTooltipTextButton removeButton;
    MidiTooltipTextButton expandButton;
    MidiTooltipTextButton crossfadeButton;

    juce::Label volLabel, speedLabel, delayLabel, pitchLabel; // NEW pitchLabel
    std::unique_ptr<StyledSlider> volSlider;
    std::unique_ptr<StyledSlider> speedSlider;
    std::unique_ptr<StyledSlider> delaySlider;
    std::unique_ptr<StyledSlider> pitchSlider; // NEW
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(TrackBannerComponent)
};



--------------------------------------------------------------------------------
File: src/UI/VocalsPage.cpp
Size: 5.50 KB
--------------------------------------------------------------------------------

// * **Fix:** Increased height of preamp section (`removeFromTop(80)` instead of 60) to provide reasonable distance for text boxes. <!-- end list -->

#include "VocalsPage.h"
#include "../RegistrationManager.h"

using namespace juce;

VocalsPage::VocalsPage(AudioEngine& engineRef, PresetManager& presetMgr)
    : audioEngine(engineRef), presetManager(presetMgr)
{
    goldenLookAndFeel = std::make_unique<GoldenSliderLookAndFeel>();
    setupPreampGains();
    setupTabbedComponent();
    
    updateAllControlsFromEngine();
    
    startTimer(200); 
}

VocalsPage::~VocalsPage()
{
    stopTimer();
    if (tabbedComponent) tabbedComponent->setLookAndFeel(nullptr);
    if (mic1GainSlider) mic1GainSlider->setLookAndFeel(nullptr);
    if (mic2GainSlider) mic2GainSlider->setLookAndFeel(nullptr);
    eqPanel1 = nullptr; eqPanel2 = nullptr;
    compPanel1 = nullptr; compPanel2 = nullptr;
    excPanel1 = nullptr; excPanel2 = nullptr;
    harmonizerPanel = nullptr; reverbPanel = nullptr;
    delayPanel = nullptr; dynEqPanel = nullptr;
}

void VocalsPage::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colour(0xFF202020));
}

void VocalsPage::resized()
{
    auto area = getLocalBounds().reduced(20);

    // Preamp Section at top
    // FIX: Increased height to 80 to prevent text box clipping at bottom
    auto preampArea = area.removeFromTop(80);
    
    // Mic 1
    auto m1Area = preampArea.removeFromLeft(300);
    mic1GainLabel.setBounds(m1Area.removeFromTop(20));
    mic1GainSlider->setBounds(m1Area);

    preampArea.removeFromLeft(40);
    // Gap

    // Mic 2
    auto m2Area = preampArea.removeFromLeft(300);
    mic2GainLabel.setBounds(m2Area.removeFromTop(20));
    mic2GainSlider->setBounds(m2Area);
    
    area.removeFromTop(10);
    // Tabs
    if (tabbedComponent)
        tabbedComponent->setBounds(area);
}

void VocalsPage::setupPreampGains()
{
    addAndMakeVisible(mic1GainLabel);
    mic1GainLabel.setText("Mic 1 Preamp", dontSendNotification);
    mic1GainLabel.setColour(Label::textColourId, Colours::white);
    mic1GainSlider = std::make_unique<StyledSlider>(Slider::LinearHorizontal, Slider::TextBoxRight);
    mic1GainSlider->setRange(-60.0, 24.0, 0.1);
    mic1GainSlider->setValue(0.0);
    mic1GainSlider->setTextValueSuffix(" dB");
    mic1GainSlider->onValueChange = [this] {
        audioEngine.setMicPreampGain(0, (float)mic1GainSlider->getValue());
    };
    addAndMakeVisible(mic1GainSlider.get());
    addAndMakeVisible(mic2GainLabel);
    mic2GainLabel.setText("Mic 2 Preamp", dontSendNotification);
    mic2GainLabel.setColour(Label::textColourId, Colours::white);
    mic2GainSlider = std::make_unique<StyledSlider>(Slider::LinearHorizontal, Slider::TextBoxRight);
    mic2GainSlider->setRange(-60.0, 24.0, 0.1);
    mic2GainSlider->setValue(0.0);
    mic2GainSlider->setTextValueSuffix(" dB");
    mic2GainSlider->onValueChange = [this] {
        audioEngine.setMicPreampGain(1, (float)mic2GainSlider->getValue());
    };
    addAndMakeVisible(mic2GainSlider.get());
}

void VocalsPage::setupTabbedComponent()
{
    tabbedComponent = std::make_unique<TabbedComponent>(TabbedButtonBar::TabsAtTop);
    tabbedComponent->setTabBarDepth(40);
    tabbedComponent->setLookAndFeel(goldenLookAndFeel.get());
    tabbedComponent->setColour(juce::TabbedComponent::outlineColourId, juce::Colours::transparentBlack);
    juce::Colour tabBg = juce::Colour(0xFF202020);

    eqPanel1 = new EQPanel(audioEngine.getEQProcessor(0), 0, "Mic 1");
    tabbedComponent->addTab("Mic 1 EQ", tabBg, eqPanel1, true);
    compPanel1 = new CompressorPanel(audioEngine, 0, "Mic 1");
    tabbedComponent->addTab("Mic 1 Comp", tabBg, compPanel1, true);
    excPanel1 = new ExciterPanel(audioEngine, 0, "Mic 1");
    tabbedComponent->addTab("Mic 1 Air", tabBg, excPanel1, true);
    eqPanel2 = new EQPanel(audioEngine.getEQProcessor(1), 1, "Mic 2");
    tabbedComponent->addTab("Mic 2 EQ", tabBg, eqPanel2, true);
    compPanel2 = new CompressorPanel(audioEngine, 1, "Mic 2");
    tabbedComponent->addTab("Mic 2 Comp", tabBg, compPanel2, true);
    excPanel2 = new ExciterPanel(audioEngine, 1, "Mic 2");
    tabbedComponent->addTab("Mic 2 Air", tabBg, excPanel2, true);
    harmonizerPanel = new HarmonizerPanel(audioEngine);
    tabbedComponent->addTab("Harmonizer", tabBg, harmonizerPanel, true);
    reverbPanel = new ReverbPanel(audioEngine);
    tabbedComponent->addTab("Reverb", tabBg, reverbPanel, true);
    delayPanel = new DelayPanel(audioEngine.getDelayProcessor());
    tabbedComponent->addTab("Delay", tabBg, delayPanel, true);
    dynEqPanel = new DynamicEQPanel(audioEngine);
    tabbedComponent->addTab("Sidechain", tabBg, dynEqPanel, true);
    addAndMakeVisible(tabbedComponent.get());
}

void VocalsPage::timerCallback()
{
    bool isPro = RegistrationManager::getInstance().isProMode();
    if (mic2GainSlider) mic2GainSlider->setEnabled(isPro);
}

void VocalsPage::updateAllControlsFromEngine()
{
    mic1GainSlider->setValue(audioEngine.getMicPreampGain(0), dontSendNotification);
    mic2GainSlider->setValue(audioEngine.getMicPreampGain(1), dontSendNotification);
    if (eqPanel1) eqPanel1->updateFromPreset();
    if (eqPanel2) eqPanel2->updateFromPreset();
    if (compPanel1) compPanel1->updateFromPreset();
    if (compPanel2) compPanel2->updateFromPreset();
    if (excPanel1) excPanel1->updateFromPreset();
    if (excPanel2) excPanel2->updateFromPreset();
    if (harmonizerPanel) harmonizerPanel->updateFromPreset();
    if (reverbPanel) reverbPanel->updateFromPreset();
    if (delayPanel) delayPanel->updateFromPreset();
    if (dynEqPanel) dynEqPanel->updateFromPreset();
}



--------------------------------------------------------------------------------
File: src/UI/VocalsPage.h
Size: 1.71 KB
--------------------------------------------------------------------------------

// **Changes:** Changed `mic1GainSlider` / `mic2GainSlider` type from `VerticalSlider` to `StyledSlider` (Task 3).

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "StyledSlider.h"
#include "EQPanel.h"
#include "DynamicEQPanel.h"
#include "ExciterPanel.h"
#include "CompressorPanel.h"
#include "ReverbPanel.h"
#include "HarmonizerPanel.h"
#include "DelayPanel.h"
#include "../AudioEngine.h"
#include "../PresetManager.h"

class VocalsPage : public juce::Component, private juce::Timer
{
public:
    explicit VocalsPage(AudioEngine& engineRef, PresetManager& presetMgr);
    ~VocalsPage() override;

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void updateAllControlsFromEngine();

private:
    void timerCallback() override;

    AudioEngine& audioEngine;
    PresetManager& presetManager;

    std::unique_ptr<GoldenSliderLookAndFeel> goldenLookAndFeel;

    juce::Label mic1GainLabel;
    // CHANGED: Use StyledSlider for Horizontal support
    std::unique_ptr<StyledSlider> mic1GainSlider;
    
    juce::Label mic2GainLabel;
    std::unique_ptr<StyledSlider> mic2GainSlider;

    std::unique_ptr<juce::TabbedComponent> tabbedComponent;

    // Tab Contents
    EQPanel* eqPanel1 = nullptr;
    EQPanel* eqPanel2 = nullptr;
    CompressorPanel* compPanel1 = nullptr;
    CompressorPanel* compPanel2 = nullptr;
    ExciterPanel* excPanel1 = nullptr;
    ExciterPanel* excPanel2 = nullptr;
    
    HarmonizerPanel* harmonizerPanel = nullptr;
    ReverbPanel* reverbPanel = nullptr;
    DelayPanel* delayPanel = nullptr;
    DynamicEQPanel* dynEqPanel = nullptr;

    void setupPreampGains();
    void setupTabbedComponent();

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VocalsPage)
};



--------------------------------------------------------------------------------
File: CMakeLists.txt
Size: 9.75 KB
--------------------------------------------------------------------------------

cmake_minimum_required(VERSION 3.22)

project(OnStage VERSION 1.0.0)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set_property(GLOBAL PROPERTY USE_FOLDERS YES)

set(PROJECT_ROOT "${CMAKE_CURRENT_SOURCE_DIR}")
set(JUCE_DIR     "${PROJECT_ROOT}/JUCE")
set(ASSETS_DIR   "${PROJECT_ROOT}/assets")
set(SRC_DIR      "${PROJECT_ROOT}/src")

message(STATUS "Project Root: ${PROJECT_ROOT}")
message(STATUS "JUCE Dir:     ${JUCE_DIR}")

if(EXISTS "${JUCE_DIR}/CMakeLists.txt")
    add_subdirectory("${JUCE_DIR}")
else()
    message(FATAL_ERROR "JUCE directory not found at ${JUCE_DIR}! Build cannot continue.")
endif()

if (MSVC)
    add_compile_options(/MP)
endif()

set(ONSTAGE_SOURCES
    ${SRC_DIR}/App.cpp
    ${SRC_DIR}/App.h
    ${SRC_DIR}/AudioEngine.cpp
    ${SRC_DIR}/AudioEngine.h
    ${SRC_DIR}/Main.cpp
    ${SRC_DIR}/IOSettingsManager.cpp
    ${SRC_DIR}/IOSettingsManager.h
    ${SRC_DIR}/PresetManager.cpp
    ${SRC_DIR}/PresetManager.h
    ${SRC_DIR}/AppLogger.h
    ${SRC_DIR}/RegistrationManager.cpp
    ${SRC_DIR}/RegistrationManager.h
    ${SRC_DIR}/engine/VideoSurfaceComponent.cpp
    ${SRC_DIR}/engine/VideoSurfaceComponent.h
    ${SRC_DIR}/engine/VLCMediaPlayer.h 
    ${SRC_DIR}/dsp/EQProcessor.cpp
    ${SRC_DIR}/dsp/EQProcessor.h
    ${SRC_DIR}/dsp/ExciterProcessor.cpp
    ${SRC_DIR}/dsp/ExciterProcessor.h
    ${SRC_DIR}/dsp/ReverbProcessor.cpp
    ${SRC_DIR}/dsp/ReverbProcessor.h
    ${SRC_DIR}/dsp/CompressorProcessor.h
    ${SRC_DIR}/dsp/DelayProcessor.h
    ${SRC_DIR}/dsp/DynamicEQProcessor.h
    ${SRC_DIR}/dsp/HarmonizerProcessor.h
    ${SRC_DIR}/dsp/SimplePitchShifter.h
    ${SRC_DIR}/UI/MainComponent.cpp
    ${SRC_DIR}/UI/MainComponent.h
    ${SRC_DIR}/UI/HeaderBar.cpp
    ${SRC_DIR}/UI/HeaderBar.h
    ${SRC_DIR}/UI/RegistrationComponent.h
    ${SRC_DIR}/UI/IOPage.cpp
    ${SRC_DIR}/UI/IOPage.h
    ${SRC_DIR}/UI/VocalsPage.cpp
    ${SRC_DIR}/UI/VocalsPage.h
    ${SRC_DIR}/UI/MediaPage.cpp
    ${SRC_DIR}/UI/MediaPage.h
    ${SRC_DIR}/UI/PlaylistComponent.cpp
    ${SRC_DIR}/UI/PlaylistComponent.h
    ${SRC_DIR}/UI/TrackBannerComponent.cpp
    ${SRC_DIR}/UI/TrackBannerComponent.h
    ${SRC_DIR}/UI/PlaylistDataStructures.h
    ${SRC_DIR}/UI/DebugConsole.h
    ${SRC_DIR}/UI/ManualComponent.h
    ${SRC_DIR}/UI/LongPressDetector.h
    ${SRC_DIR}/UI/CompressorPanel.h
    ${SRC_DIR}/UI/DelayPanel.h
    ${SRC_DIR}/UI/DualHandleSlider.h
    ${SRC_DIR}/UI/DynamicEQPanel.h
    ${SRC_DIR}/UI/EffectToggleButton.h
    ${SRC_DIR}/UI/EQPanel.h
    ${SRC_DIR}/UI/ExciterPanel.h
    ${SRC_DIR}/UI/HarmonizerPanel.h
    ${SRC_DIR}/UI/ReverbPanel.h
    ${SRC_DIR}/UI/StyledSlider.h
    ${SRC_DIR}/UI/SignalLed.h
    ${SRC_DIR}/UI/LevelMeter.h
    ${SRC_DIR}/UI/MasterMeter.cpp
    ${SRC_DIR}/UI/MasterMeter.h
)

if (CMAKE_SYSTEM_NAME STREQUAL "iOS")
    message(STATUS "Detected OS: iOS")
    add_definitions(-DJUCE_IOS=1)
    list(APPEND ONSTAGE_SOURCES 
        ${SRC_DIR}/engine/NativeMediaPlayer_Apple.h
        ${SRC_DIR}/engine/NativeMediaPlayer_Apple.mm
    )
    add_executable(OnStage MACOSX_BUNDLE ${ONSTAGE_SOURCES} "${PROJECT_ROOT}/icon.ico")
    set_target_properties(OnStage PROPERTIES
        MACOSX_BUNDLE_BUNDLE_NAME "OnStage"
        MACOSX_BUNDLE_GUI_IDENTIFIER "com.fanan.onstage"
        XCODE_ATTRIBUTE_PRODUCT_BUNDLE_IDENTIFIER "com.fanan.onstage"
        XCODE_ATTRIBUTE_TARGETED_DEVICE_FAMILY "1,2"
        XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY ""
        XCODE_ATTRIBUTE_CODE_SIGNING_REQUIRED "NO"
        XCODE_ATTRIBUTE_CODE_SIGNING_ALLOWED "NO"
    )
    target_compile_definitions(OnStage PRIVATE JUCE_STANDALONE_APPLICATION=1 JUCE_WEB_BROWSER=0 JUCE_USE_CAMERA=0 JUCE_USE_CURL=0)
    target_link_libraries(OnStage PRIVATE
        juce::juce_core juce::juce_events juce::juce_data_structures
        juce::juce_graphics juce::juce_gui_basics juce::juce_gui_extra
        juce::juce_audio_basics juce::juce_audio_devices juce::juce_audio_formats
        juce::juce_audio_utils juce::juce_audio_processors juce::juce_dsp
        OnStageAssets
        "-framework AVFoundation"
        "-framework CoreMedia"
        "-framework CoreVideo"
        "-framework AudioToolbox"
        "-framework CoreAudio"
        "-framework CoreFoundation"
        "-framework CoreGraphics"
        "-framework OpenGLES"
        "-framework QuartzCore"
        "-framework UIKit"
    )
    add_custom_command(TARGET OnStage POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
        "${ASSETS_DIR}" "$<TARGET_FILE_DIR:OnStage>/OnStage.app/assets"
    )

elseif (WIN32)
    message(STATUS "Detected OS: Windows")
    add_definitions(-DJUCE_WINDOWS=1)
    list(APPEND ONSTAGE_SOURCES 
        ${SRC_DIR}/engine/VLCMediaPlayer_Desktop.h
        ${SRC_DIR}/engine/VLCMediaPlayer_Desktop.cpp
    )
    set(ASIO_DIR "${PROJECT_ROOT}/asiosdk")
    set(VLC_DIR  "${PROJECT_ROOT}/vlc-3.0.21")
    include_directories(${ASIO_DIR}/common ${ASIO_DIR}/host ${VLC_DIR}/sdk/include)
    add_executable(OnStage WIN32 ${ONSTAGE_SOURCES} "${PROJECT_ROOT}/resources.rc" "${PROJECT_ROOT}/icon.ico")
    set_target_properties(OnStage PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY_DEBUG "${CMAKE_BINARY_DIR}/Debug"
        RUNTIME_OUTPUT_DIRECTORY_RELEASE "${CMAKE_BINARY_DIR}/Release"
        VS_DEBUGGER_WORKING_DIRECTORY "$<TARGET_FILE_DIR:OnStage>"
    )
    target_compile_definitions(OnStage PRIVATE JUCE_STANDALONE_APPLICATION=1 JUCE_ASIO=1 JUCE_WEB_BROWSER=0 JUCE_USE_CAMERA=0 JUCE_USE_CURL=0 _CRT_SECURE_NO_WARNINGS)
    set(VLC_LIB "${VLC_DIR}/sdk/lib/libvlc.lib")
    set(VLC_CORE_LIB "${VLC_DIR}/sdk/lib/libvlccore.lib")
    target_link_libraries(OnStage PRIVATE 
        juce::juce_core juce::juce_events juce::juce_data_structures juce::juce_graphics juce::juce_gui_basics juce::juce_gui_extra juce::juce_audio_basics juce::juce_audio_devices juce::juce_audio_formats juce::juce_audio_utils juce::juce_audio_processors juce::juce_dsp
        OnStageAssets ${VLC_LIB} ${VLC_CORE_LIB} winmm ws2_32 gdi32 ole32 uuid comdlg32)
    add_custom_command(TARGET OnStage POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "${VLC_DIR}/libvlc.dll" "$<TARGET_FILE_DIR:OnStage>")
    add_custom_command(TARGET OnStage POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "${VLC_DIR}/libvlccore.dll" "$<TARGET_FILE_DIR:OnStage>")
    add_custom_command(TARGET OnStage POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_directory "${VLC_DIR}/plugins" "$<TARGET_FILE_DIR:OnStage>/plugins")

elseif (APPLE)
    message(STATUS "Detected OS: macOS")
    add_definitions(-DJUCE_MAC=1)
    list(APPEND ONSTAGE_SOURCES 
        ${SRC_DIR}/engine/NativeMediaPlayer_Apple.h
        ${SRC_DIR}/engine/NativeMediaPlayer_Apple.mm
    )
    add_executable(OnStage MACOSX_BUNDLE ${ONSTAGE_SOURCES} "${PROJECT_ROOT}/icon.ico")
    set_target_properties(OnStage PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "OnStage" MACOSX_BUNDLE_GUI_IDENTIFIER "com.fanan.onstage" MACOSX_BUNDLE_ICON_FILE "icon.ico")
    target_compile_definitions(OnStage PRIVATE JUCE_STANDALONE_APPLICATION=1 JUCE_WEB_BROWSER=0 JUCE_USE_CAMERA=0 JUCE_USE_CURL=0)
    target_link_libraries(OnStage PRIVATE 
        juce::juce_core juce::juce_events juce::juce_data_structures juce::juce_graphics juce::juce_gui_basics juce::juce_gui_extra juce::juce_audio_basics juce::juce_audio_devices juce::juce_audio_formats juce::juce_audio_utils juce::juce_audio_processors juce::juce_dsp
        OnStageAssets
        "-framework AVFoundation"
        "-framework CoreMedia"
        "-framework CoreVideo"
        "-framework Cocoa" "-framework CoreAudio" "-framework CoreMIDI" "-framework AudioToolbox" "-framework IOKit" "-framework Accelerate" "-framework QuartzCore" "-framework WebKit" "-framework Foundation")
    add_custom_command(TARGET OnStage POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_directory "${ASSETS_DIR}" "$<TARGET_FILE_DIR:OnStage>/../Resources/assets")

elseif (UNIX AND NOT APPLE)
    message(STATUS "Detected OS: Linux")
    add_definitions(-DJUCE_LINUX=1)
    list(APPEND ONSTAGE_SOURCES 
        ${SRC_DIR}/engine/VLCMediaPlayer_Desktop.h
        ${SRC_DIR}/engine/VLCMediaPlayer_Desktop.cpp
    )
    find_package(PkgConfig REQUIRED)
    pkg_check_modules(VLC REQUIRED libvlc)
    pkg_check_modules(ALSA REQUIRED alsa)
    pkg_check_modules(FREETYPE REQUIRED freetype2)
    include_directories(${VLC_INCLUDE_DIRS} /usr/include/freetype2)
    link_libraries(dl pthread rt)
    add_executable(OnStage ${ONSTAGE_SOURCES})
    set_target_properties(OnStage PROPERTIES OUTPUT_NAME "OnStage")
    target_compile_definitions(OnStage PRIVATE JUCE_STANDALONE_APPLICATION=1 JUCE_ALSA=1 JUCE_WEB_BROWSER=0 JUCE_USE_CAMERA=0 JUCE_USE_CURL=0 JUCE_USE_X11=1)
    target_link_libraries(OnStage PRIVATE 
        juce::juce_core juce::juce_events juce::juce_data_structures juce::juce_graphics juce::juce_gui_basics juce::juce_gui_extra juce::juce_audio_basics juce::juce_audio_devices juce::juce_audio_formats juce::juce_audio_utils juce::juce_audio_processors juce::juce_dsp
        OnStageAssets 
        ${VLC_LIBRARIES} ${ALSA_LIBRARIES} ${FREETYPE_LIBRARIES} X11 Xext Xinerama asound)
endif()

include_directories(
    ${PROJECT_ROOT}
    ${SRC_DIR}
    ${SRC_DIR}/engine
    ${SRC_DIR}/dsp
    ${SRC_DIR}/UI
    ${JUCE_DIR}/modules
    ${JUCE_DIR}/modules/juce_core
    ${JUCE_DIR}/modules/juce_events
    ${JUCE_DIR}/modules/juce_data_structures
    ${JUCE_DIR}/modules/juce_graphics
    ${JUCE_DIR}/modules/juce_gui_basics
    ${JUCE_DIR}/modules/juce_gui_extra
    ${JUCE_DIR}/modules/juce_audio_basics
    ${JUCE_DIR}/modules/juce_audio_devices
    ${JUCE_DIR}/modules/juce_audio_formats
    ${JUCE_DIR}/modules/juce_audio_utils
    ${JUCE_DIR}/modules/juce_audio_processors
    ${JUCE_DIR}/modules/juce_dsp
)

juce_add_binary_data(OnStageAssets
    SOURCES
        "${PROJECT_ROOT}/icon.ico"
        "${ASSETS_DIR}/logo.png"
        "${ASSETS_DIR}/On_stage_logo.png"
        "${ASSETS_DIR}/ir.wav"
        "${ASSETS_DIR}/license.mid"
)

message(STATUS "OnStage build configuration complete.")


================================================================================
End of Documentation
Generated by Code PDF Builder on December 12, 2025
================================================================================
